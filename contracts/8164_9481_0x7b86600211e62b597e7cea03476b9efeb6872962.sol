{{
  "language": "Solidity",
  "sources": {
    "contracts/Supernova.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./interfaces/IDiamondCut.sol\";\nimport \"./interfaces/IDiamondLoupe.sol\";\nimport \"./libraries/LibDiamond.sol\";\nimport \"./libraries/LibOwnership.sol\";\nimport \"./libraries/LibDiamondStorage.sol\";\nimport \"./interfaces/IERC165.sol\";\nimport \"./interfaces/IERC173.sol\";\n\ncontract Supernova {\n    constructor(IDiamondCut.FacetCut[] memory _diamondCut, address _owner) payable {\n        require(_owner != address(0), \"owner must not be 0x0\");\n\n        LibDiamond.diamondCut(_diamondCut, address(0), new bytes(0));\n        LibOwnership.setContractOwner(_owner);\n\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n        // adding ERC165 data\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n        address facet = address(bytes20(ds.facets[msg.sig].facetAddress));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return (0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"../interfaces/IDiamondCut.sol\";\nimport \"./LibDiamondStorage.sol\";\n\nlibrary LibDiamond {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        uint256 selectorCount = LibDiamondStorage.diamondStorage().selectors.length;\n\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            selectorCount = executeDiamondCut(selectorCount, _diamondCut[facetIndex]);\n        }\n\n        emit DiamondCut(_diamondCut, _init, _calldata);\n\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    // executeDiamondCut takes one single FacetCut action and executes it\n    // if FacetCutAction can't be identified, it reverts\n    function executeDiamondCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\n        require(cut.functionSelectors.length > 0, \"LibDiamond: No selectors in facet to cut\");\n\n        if (cut.action == IDiamondCut.FacetCutAction.Add) {\n            require(cut.facetAddress != address(0), \"LibDiamond: add facet address can't be address(0)\");\n            enforceHasContractCode(cut.facetAddress, \"LibDiamond: add facet must have code\");\n\n            return _handleAddCut(selectorCount, cut);\n        }\n\n        if (cut.action == IDiamondCut.FacetCutAction.Replace) {\n            require(cut.facetAddress != address(0), \"LibDiamond: remove facet address can't be address(0)\");\n            enforceHasContractCode(cut.facetAddress, \"LibDiamond: remove facet must have code\");\n\n            return _handleReplaceCut(selectorCount, cut);\n        }\n\n        if (cut.action == IDiamondCut.FacetCutAction.Remove) {\n            require(cut.facetAddress == address(0), \"LibDiamond: remove facet address must be address(0)\");\n\n            return _handleRemoveCut(selectorCount, cut);\n        }\n\n        revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n    }\n\n    // _handleAddCut executes a cut with the type Add\n    // it reverts if the selector already exists\n    function _handleAddCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n        for (uint256 selectorIndex; selectorIndex < cut.functionSelectors.length; selectorIndex++) {\n            bytes4 selector = cut.functionSelectors[selectorIndex];\n\n            address oldFacetAddress = ds.facets[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"LibDiamondCut: Can't add function that already exists\");\n\n            ds.facets[selector] = LibDiamondStorage.Facet(\n                cut.facetAddress,\n                uint16(selectorCount)\n            );\n            ds.selectors.push(selector);\n\n            selectorCount++;\n        }\n\n        return selectorCount;\n    }\n\n    // _handleReplaceCut executes a cut with the type Replace\n    // it does not allow replacing immutable functions\n    // it does not allow replacing with the same function\n    // it does not allow replacing a function that does not exist\n    function _handleReplaceCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n        for (uint256 selectorIndex; selectorIndex < cut.functionSelectors.length; selectorIndex++) {\n            bytes4 selector = cut.functionSelectors[selectorIndex];\n\n            address oldFacetAddress = ds.facets[selector].facetAddress;\n\n            // only useful if immutable functions exist\n            require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n            require(oldFacetAddress != cut.facetAddress, \"LibDiamondCut: Can't replace function with same function\");\n            require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n\n            // replace old facet address\n            ds.facets[selector].facetAddress = cut.facetAddress;\n        }\n\n        return selectorCount;\n    }\n\n    // _handleRemoveCut executes a cut with the type Remove\n    // for efficiency, the selector to be deleted is replaced with the last one and then the last one is popped\n    // it reverts if the function doesn't exist or it's immutable\n    function _handleRemoveCut(uint256 selectorCount, IDiamondCut.FacetCut memory cut) internal returns (uint256) {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n        for (uint256 selectorIndex; selectorIndex < cut.functionSelectors.length; selectorIndex++) {\n            bytes4 selector = cut.functionSelectors[selectorIndex];\n\n            LibDiamondStorage.Facet memory oldFacet = ds.facets[selector];\n\n            require(oldFacet.facetAddress != address(0), \"LibDiamondCut: Can't remove function that doesn't exist\");\n            require(oldFacet.facetAddress != address(this), \"LibDiamondCut: Can't remove immutable function.\");\n\n            // replace selector with last selector\n            if (oldFacet.selectorPosition != selectorCount - 1) {\n                bytes4 lastSelector = ds.selectors[selectorCount - 1];\n                ds.selectors[oldFacet.selectorPosition] = lastSelector;\n                ds.facets[lastSelector].selectorPosition = oldFacet.selectorPosition;\n            }\n\n            // delete last selector\n            ds.selectors.pop();\n            delete ds.facets[selector];\n\n            selectorCount--;\n        }\n\n        return selectorCount;\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"LibDiamondCut: _init is address(0) but _calldata is not empty\");\n            return;\n        }\n\n        require(_calldata.length > 0, \"LibDiamondCut: _calldata is empty but _init is not address(0)\");\n        if (_init != address(this)) {\n            enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        }\n\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up the error\n                revert(string(error));\n            } else {\n                revert(\"LibDiamondCut: _init function reverted\");\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibOwnership.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nimport \"./LibDiamondStorage.sol\";\n\nlibrary LibOwnership {\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function setContractOwner(address _newOwner) internal {\n        LibDiamondStorage.DiamondStorage storage ds = LibDiamondStorage.diamondStorage();\n\n        address previousOwner = ds.contractOwner;\n        require(previousOwner != _newOwner, \"Previous owner and new owner must be different\");\n\n        ds.contractOwner = _newOwner;\n\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = LibDiamondStorage.diamondStorage().contractOwner;\n    }\n\n    function enforceIsContractOwner() view internal {\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \"Must be contract owner\");\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == LibDiamondStorage.diamondStorage().contractOwner, \"Must be contract owner\");\n        _;\n    }\n}\n"
    },
    "contracts/libraries/LibDiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\nlibrary LibDiamondStorage {\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n\n    struct Facet {\n        address facetAddress;\n        uint16 selectorPosition;\n    }\n\n    struct DiamondStorage {\n        // function selector => facet address and selector position in selectors array\n        mapping(bytes4 => Facet) facets;\n        bytes4[] selectors;\n\n        // ERC165\n        mapping(bytes4 => bool) supportedInterfaces;\n\n        // owner of the contract\n        address contractOwner;\n    }\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\npragma experimental ABIEncoderV2;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity 0.7.6;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 9999
    },
    "outputSelection": {
      "*": {
        "*": [
          "evm.bytecode",
          "evm.deployedBytecode",
          "abi"
        ]
      }
    },
    "libraries": {}
  }
}}