{"SourceCode": "pragma solidity ^0.4.19;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title EjectableOwnable\r\n * @dev The EjectableOwnable contract provides the function to remove the ownership of the contract.\r\n */\r\ncontract EjectableOwnable is Ownable {\r\n\r\n    /**\r\n     * @dev Remove the ownership by setting the owner address to null,\r\n     * after calling this function, all onlyOwner function will be be able to be called by anyone anymore,\r\n     * the contract will achieve truly decentralisation.\r\n    */\r\n    function removeOwnership() onlyOwner public {\r\n        owner = 0x0;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title JointOwnable\r\n * @dev Extension for the Ownable contract, where the owner can assign at most 2 other addresses\r\n *  to manage some functions of the contract, using the eitherOwner modifier.\r\n *  Note that onlyOwner modifier would still be accessible only for the original owner.\r\n */\r\ncontract JointOwnable is Ownable {\r\n\r\n  event AnotherOwnerAssigned(address indexed anotherOwner);\r\n\r\n  address public anotherOwner1;\r\n  address public anotherOwner2;\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner or anotherOwner.\r\n   */\r\n  modifier eitherOwner() {\r\n    require(msg.sender == owner || msg.sender == anotherOwner1 || msg.sender == anotherOwner2);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to assign another owner.\r\n   * @param _anotherOwner The address to another owner.\r\n   */\r\n  function assignAnotherOwner1(address _anotherOwner) onlyOwner public {\r\n    require(_anotherOwner != 0);\r\n    AnotherOwnerAssigned(_anotherOwner);\r\n    anotherOwner1 = _anotherOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to assign another owner.\r\n   * @param _anotherOwner The address to another owner.\r\n   */\r\n  function assignAnotherOwner2(address _anotherOwner) onlyOwner public {\r\n    require(_anotherOwner != 0);\r\n    AnotherOwnerAssigned(_anotherOwner);\r\n    anotherOwner2 = _anotherOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title PullPayment\r\n * @dev Base contract supporting async send for pull payments. Inherit from this\r\n * contract and use asyncSend instead of send.\r\n */\r\ncontract PullPayment {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n\r\n  /**\r\n   * @dev withdraw accumulated balance, called by payee.\r\n   */\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(this.balance >= payment);\r\n\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n\r\n    assert(payee.send(payment));\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n   * @param dest The destination address of the funds.\r\n   * @param amount The amount to transfer.\r\n   */\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title A simplified interface of ERC-721, but without approval functions\r\n */\r\ncontract ERC721 {\r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint tokenId);\r\n\r\n    // ERC20 compatible functions\r\n    // function name() public view returns (string);\r\n    // function symbol() public view returns (string);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address _owner) public view returns (uint);\r\n\r\n    // Functions that define ownership\r\n    function ownerOf(uint _tokenId) external view returns (address);\r\n    function transfer(address _to, uint _tokenId) external;\r\n\r\n}\r\n\r\ncontract DungeonStructs {\r\n\r\n    /**\r\n     * @dev The main Dungeon struct. Every dungeon in the game is represented by this structure.\r\n     * A dungeon is consists of an unlimited number of floors for your heroes to challenge,\r\n     * the power level of a dungeon is encoded in the floorGenes. Some dungeons are in fact more \"challenging\" than others,\r\n     * the secret formula for that is left for user to find out.\r\n     *\r\n     * Each dungeon also has a \"training area\", heroes can perform trainings and upgrade their stat,\r\n     * and some dungeons are more effective in the training, which is also a secret formula!\r\n     *\r\n     * When player challenge or do training in a dungeon, the fee will be collected as the dungeon rewards,\r\n     * which will be rewarded to the player who successfully challenged the current floor.\r\n     *\r\n     * Each dungeon fits in fits into three 256-bit words.\r\n     */\r\n    struct Dungeon {\r\n\r\n        // Each dungeon has an ID which is the index in the storage array.\r\n\r\n        // The timestamp of the block when this dungeon is created.\r\n        uint32 creationTime;\r\n\r\n        // The status of the dungeon, each dungeon can have 5 status, namely:\r\n        // 0: Active | 1: Transport Only | 2: Challenge Only | 3: Train Only | 4: InActive\r\n        uint8 status;\r\n\r\n        // The dungeon's difficulty, the higher the difficulty,\r\n        // normally, the \"rarer\" the seedGenes, the higher the diffculty,\r\n        // and the higher the contribution fee it is to challenge, train, and transport to the dungeon,\r\n        // the formula for the contribution fee is in DungeonChallenge and DungeonTraining contracts.\r\n        // A dungeon's difficulty never change.\r\n        uint8 difficulty;\r\n\r\n        // The dungeon's capacity, maximum number of players allowed to stay on this dungeon.\r\n        // The capacity of the newbie dungeon (Holyland) is set at 0 (which is infinity).\r\n        // Using 16-bit unsigned integers can have a maximum of 65535 in capacity.\r\n        // A dungeon's capacity never change.\r\n        uint16 capacity;\r\n\r\n        // The current floor number, a dungeon is consists of an umlimited number of floors,\r\n        // when there is heroes successfully challenged a floor, the next floor will be\r\n        // automatically generated. Using 32-bit unsigned integer can have a maximum of 4 billion floors.\r\n        uint32 floorNumber;\r\n\r\n        // The timestamp of the block when the current floor is generated.\r\n        uint32 floorCreationTime;\r\n\r\n        // Current accumulated rewards, successful challenger will get a large proportion of it.\r\n        uint128 rewards;\r\n\r\n        // The seed genes of the dungeon, it is used as the base gene for first floor,\r\n        // some dungeons are rarer and some are more common, the exact details are,\r\n        // of course, top secret of the game!\r\n        // A dungeon's seedGenes never change.\r\n        uint seedGenes;\r\n\r\n        // The genes for current floor, it encodes the difficulty level of the current floor.\r\n        // We considered whether to store the entire array of genes for all floors, but\r\n        // in order to save some precious gas we're willing to sacrifice some functionalities with that.\r\n        uint floorGenes;\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev The main Hero struct. Every hero in the game is represented by this structure.\r\n     */\r\n    struct Hero {\r\n\r\n        // Each hero has an ID which is the index in the storage array.\r\n\r\n        // The timestamp of the block when this dungeon is created.\r\n        uint64 creationTime;\r\n\r\n        // The timestamp of the block where a challenge is performed, used to calculate when a hero is allowed to engage in another challenge.\r\n        uint64 cooldownStartTime;\r\n\r\n        // Every time a hero challenge a dungeon, its cooldown index will be incremented by one.\r\n        uint32 cooldownIndex;\r\n\r\n        // The seed of the hero, the gene encodes the power level of the hero.\r\n        // This is another top secret of the game! Hero's gene can be upgraded via\r\n        // training in a dungeon.\r\n        uint genes;\r\n\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title The ERC-721 compliance token contract for the Dungeon tokens.\r\n * @dev See the DungeonStructs contract to see the details of the Dungeon token data structure.\r\n */\r\ncontract DungeonToken is ERC721, DungeonStructs, Pausable, JointOwnable {\r\n\r\n    /**\r\n     * @notice Limits the number of dungeons the contract owner can ever create.\r\n     */\r\n    uint public constant DUNGEON_CREATION_LIMIT = 1024;\r\n\r\n    /**\r\n     * @dev The Mint event is fired whenever a new dungeon is created.\r\n     */\r\n    event Mint(address indexed owner, uint newTokenId, uint difficulty, uint capacity, uint seedGenes);\r\n\r\n    /**\r\n     * @dev The NewDungeonFloor event is fired whenever a new dungeon floor is added.\r\n     */\r\n    event NewDungeonFloor(uint timestamp, uint indexed dungeonId, uint32 newFloorNumber, uint128 newRewards , uint newFloorGenes);\r\n\r\n    /**\r\n     * @dev Transfer event as defined in current draft of ERC721. Emitted every time a token\r\n     *  ownership (Dungeon Master) is assigned, including token creation.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint tokenId);\r\n\r\n    /**\r\n     * @dev Name of token.\r\n     */\r\n    string public constant name = \"Dungeon\";\r\n\r\n    /**\r\n     * @dev Symbol of token.\r\n     */\r\n    string public constant symbol = \"DUNG\";\r\n\r\n    /**\r\n     * @dev An array containing the Dungeon struct, which contains all the dungeons in existance.\r\n     *  The ID for each dungeon is the index of this array.\r\n     */\r\n    Dungeon[] public dungeons;\r\n\r\n    /**\r\n     * @dev A mapping from token IDs to the address that owns them.\r\n     */\r\n    mapping(uint => address) tokenIndexToOwner;\r\n\r\n    /**\r\n     * @dev A mapping from owner address to count of tokens that address owns.\r\n     */\r\n    mapping(address => uint) ownershipTokenCount;\r\n\r\n    /**\r\n     * Each non-fungible token owner can own more than one token at one time.\r\n     * Because each token is referenced by its unique ID, however,\r\n     * it can get difficult to keep track of the individual tokens that a user may own.\r\n     * To do this, the contract keeps a record of the IDs of each token that each user owns.\r\n     */\r\n    mapping(address => uint[]) public ownerTokens;\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens currently in existence.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return dungeons.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of tokens owned by a specific address.\r\n     * @param _owner The owner address to check.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given address is the current owner of a particular token.\r\n     * @param _claimant The address we are validating against.\r\n     * @param _tokenId Token ID\r\n     */\r\n    function _owns(address _claimant, uint _tokenId) internal view returns (bool) {\r\n        return tokenIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address currently assigned ownership of a given token.\r\n     */\r\n    function ownerOf(uint _tokenId) external view returns (address) {\r\n        require(tokenIndexToOwner[_tokenId] != address(0));\r\n\r\n        return tokenIndexToOwner[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns ownership of a specific token to an address.\r\n     */\r\n    function _transfer(address _from, address _to, uint _tokenId) internal {\r\n        // Increment the ownershipTokenCount.\r\n        ownershipTokenCount[_to]++;\r\n\r\n        // Transfer ownership.\r\n        tokenIndexToOwner[_tokenId] = _to;\r\n\r\n        // Add the _tokenId to ownerTokens[_to]\r\n        ownerTokens[_to].push(_tokenId);\r\n\r\n        // When creating new token, _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n\r\n            // Remove the _tokenId from ownerTokens[_from]\r\n            uint[] storage fromTokens = ownerTokens[_from];\r\n            bool iFound = false;\r\n\r\n            for (uint i = 0; i < fromTokens.length - 1; i++) {\r\n                if (iFound) {\r\n                    fromTokens[i] = fromTokens[i + 1];\r\n                } else if (fromTokens[i] == _tokenId) {\r\n                    iFound = true;\r\n                    fromTokens[i] = fromTokens[i + 1];\r\n                }\r\n            }\r\n\r\n            fromTokens.length--;\r\n        }\r\n\r\n        // Emit the Transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev External function to transfers a token to another address.\r\n     * @param _to The address of the recipient, can be a user or contract.\r\n     * @param _tokenId The ID of the token to transfer.\r\n     */\r\n    function transfer(address _to, uint _tokenId) whenNotPaused external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n\r\n        // You can only send your own token.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Get an array of IDs of each token that an user owns.\r\n     */\r\n    function getOwnerTokens(address _owner) external view returns(uint[]) {\r\n        return ownerTokens[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev The external function that creates a new dungeon and stores it, only contract owners\r\n     *  can create new token, and will be restricted by the DUNGEON_CREATION_LIMIT.\r\n     *  Will generate a Mint event, a  NewDungeonFloor event, and a Transfer event.\r\n     * @param _difficulty The difficulty of the new dungeon.\r\n     * @param _capacity The capacity of the new dungeon.\r\n     * @param _seedGenes The seed genes of the new dungeon.\r\n     * @param _firstFloorGenes The genes of the first dungeon floor.\r\n     * @return The dungeon ID of the new dungeon.\r\n     */\r\n    function createDungeon(uint _difficulty, uint _capacity, uint _seedGenes, uint _firstFloorGenes, address _owner) eitherOwner external returns (uint) {\r\n        // Ensure the total supply is within the fixed limit.\r\n        require(totalSupply() < DUNGEON_CREATION_LIMIT);\r\n\r\n        // UPDATE STORAGE\r\n        // Create a new dungeon.\r\n        dungeons.push(Dungeon(uint32(now), 0, uint8(_difficulty), uint16(_capacity), 0, 0, 0, _seedGenes, 0));\r\n\r\n        // Token id is the index in the storage array.\r\n        uint newTokenId = dungeons.length - 1;\r\n\r\n        // Emit the token mint event.\r\n        Mint(_owner, newTokenId, _difficulty, _capacity, _seedGenes);\r\n\r\n        // Initialize the fist floor, this will emit the NewDungeonFloor event.\r\n        addDungeonNewFloor(newTokenId, 0, _firstFloorGenes);\r\n\r\n        // This will assign ownership, and also emit the Transfer event.\r\n        _transfer(0, _owner, newTokenId);\r\n\r\n        return newTokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to set dungeon status by its ID,\r\n     *  refer to DungeonStructs for more information about dungeon status.\r\n     *  Only contract owners can alter dungeon state.\r\n     */\r\n    function setDungeonStatus(uint _id, uint _newStatus) eitherOwner tokenExists(_id) external {\r\n        dungeons[_id].status = uint8(_newStatus);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to add additional dungeon rewards by its ID,\r\n     *  only contract owners can alter dungeon state.\r\n     */\r\n    function addDungeonRewards(uint _id, uint _additinalRewards) eitherOwner tokenExists(_id) external {\r\n        dungeons[_id].rewards += uint128(_additinalRewards);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to add another dungeon floor by its ID,\r\n     *  only contract owners can alter dungeon state.\r\n     *  Will generate both a NewDungeonFloor event.\r\n     */\r\n    function addDungeonNewFloor(uint _id, uint _newRewards, uint _newFloorGenes) eitherOwner tokenExists(_id) public {\r\n        Dungeon storage dungeon = dungeons[_id];\r\n\r\n        dungeon.floorNumber++;\r\n        dungeon.floorCreationTime = uint32(now);\r\n        dungeon.rewards = uint128(_newRewards);\r\n        dungeon.floorGenes = _newFloorGenes;\r\n\r\n        // Emit the NewDungeonFloor event.\r\n        NewDungeonFloor(now, _id, dungeon.floorNumber, dungeon.rewards, dungeon.floorGenes);\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Throws if _dungeonId is not created yet.\r\n     */\r\n    modifier tokenExists(uint _tokenId) {\r\n        require(_tokenId < totalSupply());\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title The ERC-721 compliance token contract for the Hero tokens.\r\n * @dev See the DungeonStructs contract to see the details of the Hero token data structure.\r\n */\r\ncontract HeroToken is ERC721, DungeonStructs, Pausable, JointOwnable {\r\n\r\n    /**\r\n     * @dev The Mint event is fired whenever a new hero is created.\r\n     */\r\n    event Mint(address indexed owner, uint newTokenId, uint _genes);\r\n\r\n    /**\r\n     * @dev Transfer event as defined in current draft of ERC721. Emitted every time a token\r\n     *  ownership is assigned, including token creation.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint tokenId);\r\n\r\n    /**\r\n     * @dev Name of token.\r\n     */\r\n    string public constant name = \"Hero\";\r\n\r\n    /**\r\n     * @dev Symbol of token.\r\n     */\r\n    string public constant symbol = \"HERO\";\r\n\r\n    /**\r\n     * @dev An array containing the Hero struct, which contains all the heroes in existance.\r\n     *  The ID for each hero is the index of this array.\r\n     */\r\n    Hero[] public heroes;\r\n\r\n    /**\r\n     * @dev A mapping from token IDs to the address that owns them.\r\n     */\r\n    mapping(uint => address) tokenIndexToOwner;\r\n\r\n    /**\r\n     * @dev A mapping from owner address to count of tokens that address owns.\r\n     */\r\n    mapping(address => uint) ownershipTokenCount;\r\n\r\n    /**\r\n     * Each non-fungible token owner can own more than one token at one time.\r\n     * Because each token is referenced by its unique ID, however,\r\n     * it can get difficult to keep track of the individual tokens that a user may own.\r\n     * To do this, the contract keeps a record of the IDs of each token that each user owns.\r\n     */\r\n    mapping(address => uint[]) public ownerTokens;\r\n\r\n    /**\r\n     * @dev Returns the total number of tokens currently in existence.\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return heroes.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of tokens owned by a specific address.\r\n     * @param _owner The owner address to check.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint) {\r\n        return ownershipTokenCount[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if a given address is the current owner of a particular token.\r\n     * @param _claimant The address we are validating against.\r\n     * @param _tokenId Token ID\r\n     */\r\n    function _owns(address _claimant, uint _tokenId) internal view returns (bool) {\r\n        return tokenIndexToOwner[_tokenId] == _claimant;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address currently assigned ownership of a given token.\r\n     */\r\n    function ownerOf(uint _tokenId) external view returns (address) {\r\n        require(tokenIndexToOwner[_tokenId] != address(0));\r\n\r\n        return tokenIndexToOwner[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns ownership of a specific token to an address.\r\n     */\r\n    function _transfer(address _from, address _to, uint _tokenId) internal {\r\n        // Increment the ownershipTokenCount.\r\n        ownershipTokenCount[_to]++;\r\n\r\n        // Transfer ownership.\r\n        tokenIndexToOwner[_tokenId] = _to;\r\n\r\n        // Add the _tokenId to ownerTokens[_to]\r\n        ownerTokens[_to].push(_tokenId);\r\n\r\n        // When creating new token, _from is 0x0, but we can't account that address.\r\n        if (_from != address(0)) {\r\n            ownershipTokenCount[_from]--;\r\n\r\n            // Remove the _tokenId from ownerTokens[_from]\r\n            uint[] storage fromTokens = ownerTokens[_from];\r\n            bool iFound = false;\r\n\r\n            for (uint i = 0; i < fromTokens.length - 1; i++) {\r\n                if (iFound) {\r\n                    fromTokens[i] = fromTokens[i + 1];\r\n                } else if (fromTokens[i] == _tokenId) {\r\n                    iFound = true;\r\n                    fromTokens[i] = fromTokens[i + 1];\r\n                }\r\n            }\r\n\r\n            fromTokens.length--;\r\n        }\r\n\r\n        // Emit the Transfer event.\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev External function to transfers a token to another address.\r\n     * @param _to The address of the recipient, can be a user or contract.\r\n     * @param _tokenId The ID of the token to transfer.\r\n     */\r\n    function transfer(address _to, uint _tokenId) whenNotPaused external {\r\n        // Safety check to prevent against an unexpected 0x0 default.\r\n        require(_to != address(0));\r\n\r\n        // Disallow transfers to this contract to prevent accidental misuse.\r\n        require(_to != address(this));\r\n\r\n        // You can only send your own token.\r\n        require(_owns(msg.sender, _tokenId));\r\n\r\n        // Reassign ownership, clear pending approvals, emit Transfer event.\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Get an array of IDs of each token that an user owns.\r\n     */\r\n    function getOwnerTokens(address _owner) external view returns(uint[]) {\r\n        return ownerTokens[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev An external function that creates a new hero and stores it,\r\n     *  only contract owners can create new token.\r\n     *  method doesn't do any checking and should only be called when the\r\n     *  input data is known to be valid.\r\n     * @param _genes The gene of the new hero.\r\n     * @param _owner The inital owner of this hero.\r\n     * @return The hero ID of the new hero.\r\n     */\r\n    function createHero(uint _genes, address _owner) eitherOwner external returns (uint) {\r\n        // UPDATE STORAGE\r\n        // Create a new hero.\r\n        heroes.push(Hero(uint64(now), 0, 0, _genes));\r\n\r\n        // Token id is the index in the storage array.\r\n        uint newTokenId = heroes.length - 1;\r\n\r\n        // Emit the token mint event.\r\n        Mint(_owner, newTokenId, _genes);\r\n\r\n        // This will assign ownership, and also emit the Transfer event.\r\n        _transfer(0, _owner, newTokenId);\r\n\r\n        return newTokenId;\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to set the hero genes by its ID,\r\n     *  only contract owners can alter hero state.\r\n     */\r\n    function setHeroGenes(uint _id, uint _newGenes) eitherOwner tokenExists(_id) external {\r\n        heroes[_id].genes = _newGenes;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the cooldownStartTime for the given hero. Also increments the cooldownIndex.\r\n     */\r\n    function triggerCooldown(uint _id) eitherOwner tokenExists(_id) external {\r\n        Hero storage hero = heroes[_id];\r\n\r\n        hero.cooldownStartTime = uint64(now);\r\n        hero.cooldownIndex++;\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Throws if _dungeonId is not created yet.\r\n     */\r\n    modifier tokenExists(uint _tokenId) {\r\n        require(_tokenId < totalSupply());\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * SECRET\r\n */\r\ncontract ChallengeScienceInterface {\r\n\r\n    /**\r\n     * @dev given genes of current floor and dungeon seed, return a genetic combination - may have a random factor.\r\n     * @param _floorGenes Genes of floor.\r\n     * @param _seedGenes Seed genes of dungeon.\r\n     * @return The resulting genes.\r\n     */\r\n    function mixGenes(uint _floorGenes, uint _seedGenes) external returns (uint);\r\n\r\n}\r\n\r\n/**\r\n * SECRET\r\n */\r\ncontract TrainingScienceInterface {\r\n\r\n    /**\r\n     * @dev given genes of hero and current floor, return a genetic combination - may have a random factor.\r\n     * @param _heroGenes Genes of hero.\r\n     * @param _floorGenes Genes of current floor.\r\n     * @param _equipmentId Equipment index to train for, 0 is train all attributes.\r\n     * @return The resulting genes.\r\n     */\r\n    function mixGenes(uint _heroGenes, uint _floorGenes, uint _equipmentId) external returns (uint);\r\n\r\n}\r\n\r\n/**\r\n * @title DungeonBase\r\n * @dev Base contract for Ether Dungeon. It implements all necessary sub-classes,\r\n * holds all the base storage variables, and some commonly used functions.\r\n */\r\ncontract DungeonBase is EjectableOwnable, Pausable, PullPayment, DungeonStructs {\r\n\r\n    /* ======== TOKEN CONTRACTS ======== */\r\n\r\n    /**\r\n     * @dev The address of the ERC721 token contract managing all Dungeon tokens.\r\n     */\r\n    DungeonToken public dungeonTokenContract;\r\n\r\n    /**\r\n     * @dev The address of the ERC721 token contract managing all Hero tokens.\r\n     */\r\n    HeroToken public heroTokenContract;\r\n\r\n\r\n    /* ======== CLOSED SOURCE CONTRACTS ======== */\r\n\r\n    /**\r\n     * @dev The address of the ChallengeScience contract that handles the floor generation mechanics after challenge success.\r\n     */\r\n    ChallengeScienceInterface challengeScienceContract;\r\n\r\n    /**\r\n     * @dev The address of the TrainingScience contract that handles the hero training mechanics.\r\n     */\r\n    TrainingScienceInterface trainingScienceContract;\r\n\r\n\r\n    /* ======== CONSTANTS ======== */\r\n\r\n    uint16[32] EQUIPMENT_POWERS = [\r\n        1, 2, 4, 5, 16, 17, 18, 19, 0, 0, 0, 0, 0, 0, 0, 0,\r\n        4, 16, 32, 33, 0, 0, 0, 0, 32, 64, 0, 0, 128, 0, 0, 0\r\n    ];\r\n\r\n    uint SUPER_HERO_MULTIPLIER = 32;\r\n\r\n    /* ======== SETTER FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Set the address of the dungeon token contract.\r\n     * @param _newDungeonTokenContract An address of a DungeonToken contract.\r\n     */\r\n    function setDungeonTokenContract(address _newDungeonTokenContract) onlyOwner external {\r\n        dungeonTokenContract = DungeonToken(_newDungeonTokenContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the hero token contract.\r\n     * @param _newHeroTokenContract An address of a HeroToken contract.\r\n     */\r\n    function setHeroTokenContract(address _newHeroTokenContract) onlyOwner external {\r\n        heroTokenContract = HeroToken(_newHeroTokenContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the secret dungeon challenge formula contract.\r\n     * @param _newChallengeScienceAddress An address of a ChallengeScience contract.\r\n     */\r\n    function setChallengeScienceContract(address _newChallengeScienceAddress) onlyOwner external {\r\n        challengeScienceContract = ChallengeScienceInterface(_newChallengeScienceAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev Set the address of the secret hero training formula contract.\r\n     * @param _newTrainingScienceAddress An address of a TrainingScience contract.\r\n     */\r\n    function setTrainingScienceContract(address _newTrainingScienceAddress) onlyOwner external {\r\n        trainingScienceContract = TrainingScienceInterface(_newTrainingScienceAddress);\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Throws if _dungeonId is not created yet.\r\n     */\r\n    modifier dungeonExists(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        _;\r\n    }\r\n\r\n\r\n    /* ======== HELPER FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev An internal function to calculate the top 5 heroes power of a player.\r\n     */\r\n    function _getTop5HeroesPower(address _address, uint _dungeonId) internal view returns (uint) {\r\n        uint heroCount = heroTokenContract.balanceOf(_address);\r\n\r\n        if (heroCount == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // Compute all hero powers for further calculation.\r\n        uint[] memory heroPowers = new uint[](heroCount);\r\n\r\n        for (uint i = 0; i < heroCount; i++) {\r\n            uint heroId = heroTokenContract.ownerTokens(_address, i);\r\n            uint genes;\r\n            (,,, genes) = heroTokenContract.heroes(heroId);\r\n            // Power of dungeonId = 0 (no super hero boost).\r\n            heroPowers[i] = _getHeroPower(genes, _dungeonId);\r\n        }\r\n\r\n        // Calculate the top 5 heroes power.\r\n        uint result;\r\n        uint curMax;\r\n        uint curMaxIndex;\r\n\r\n        for (uint j; j < 5; j++){\r\n            for (uint k = 0; k < heroPowers.length; k++) {\r\n                if (heroPowers[k] > curMax) {\r\n                    curMax = heroPowers[k];\r\n                    curMaxIndex = k;\r\n                }\r\n            }\r\n\r\n            result += curMax;\r\n            heroPowers[curMaxIndex] = 0;\r\n            curMax = 0;\r\n            curMaxIndex = 0;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev An internal function to calculate the power of a hero,\r\n     *  it calculates the base equipment power, stats power, and \"Super\" multiplier.\r\n     */\r\n    function _getHeroPower(uint _genes, uint _dungeonId) internal view returns (uint) {\r\n        uint difficulty;\r\n        (,, difficulty,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Calculate total stats power.\r\n        uint statsPower;\r\n\r\n        for (uint i = 0; i < 4; i++) {\r\n            statsPower += _genes % 32 + 1;\r\n            _genes /= 32 ** 4;\r\n        }\r\n\r\n        // Calculate total equipment power.\r\n        uint equipmentPower;\r\n        uint superRank = _genes % 32;\r\n\r\n        for (uint j = 4; j < 12; j++) {\r\n            uint curGene = _genes % 32;\r\n            equipmentPower += EQUIPMENT_POWERS[curGene];\r\n            _genes /= 32 ** 4;\r\n\r\n            if (superRank != curGene) {\r\n                superRank = 0;\r\n            }\r\n        }\r\n\r\n        // Calculate super power boost.\r\n        bool isSuper = superRank >= 16;\r\n        uint superBoost;\r\n\r\n        if (isSuper) {\r\n            superBoost = (difficulty - 1) * SUPER_HERO_MULTIPLIER;\r\n        }\r\n\r\n        return statsPower + equipmentPower + superBoost;\r\n    }\r\n\r\n    /**\r\n     * @dev An internal function to calculate the difficulty of a dungeon floor.\r\n     */\r\n    function _getDungeonPower(uint _genes) internal view returns (uint) {\r\n        // Calculate total dungeon power.\r\n        uint dungeonPower;\r\n\r\n        for (uint j = 0; j < 12; j++) {\r\n            dungeonPower += EQUIPMENT_POWERS[_genes % 32];\r\n            _genes /= 32 ** 4;\r\n        }\r\n\r\n        return dungeonPower;\r\n    }\r\n\r\n}\r\n\r\ncontract DungeonTransportation is DungeonBase {\r\n\r\n    /**\r\n     * @dev The PlayerTransported event is fired when user transported to another dungeon.\r\n     */\r\n    event PlayerTransported(uint timestamp, address indexed playerAddress, uint indexed originDungeonId, uint indexed destinationDungeonId);\r\n\r\n\r\n    /* ======== GAME SETTINGS ======== */\r\n\r\n    /**\r\n     * @notice The actual fee contribution required to call transport() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty of destination dungeon. The payment is accumulated to the rewards of the origin dungeon,\r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     *  1000 szabo = 0.001 ether\r\n     */\r\n    uint public transportationFeeMultiplier = 500 szabo;\r\n\r\n\r\n    /* ======== STORAGE ======== */\r\n\r\n\r\n    /**\r\n     * @dev A mapping from token IDs to the address that owns them.\r\n     */\r\n    mapping(address => uint) public playerToDungeonID;\r\n\r\n    /**\r\n     * @dev A mapping from owner address to count of tokens that address owns.\r\n     */\r\n    mapping(uint => uint) public dungeonPlayerCount;\r\n\r\n    /**\r\n     * @dev The main external function to call when a player transport to another dungeon.\r\n     *  Will generate a PlayerTransported event.\r\n     */\r\n    function transport(uint _destinationDungeonId) whenNotPaused dungeonCanTransport(_destinationDungeonId) external payable {\r\n        uint originDungeonId = playerToDungeonID[msg.sender];\r\n\r\n        // Disallow transport to the same dungeon.\r\n        require(_destinationDungeonId != originDungeonId);\r\n\r\n        // Get the dungeon details from the token contract.\r\n        uint difficulty;\r\n        uint capacity;\r\n        (,, difficulty, capacity,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\r\n\r\n        // Disallow weaker user to transport to \"difficult\" dungeon.\r\n        uint top5HeroesPower = _getTop5HeroesPower(msg.sender, _destinationDungeonId);\r\n        require(top5HeroesPower >= difficulty * 12);\r\n\r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        uint baseFee = difficulty * transportationFeeMultiplier;\r\n        uint additionalFee = top5HeroesPower / 48 * transportationFeeMultiplier;\r\n        uint requiredFee = baseFee + additionalFee;\r\n        require(msg.value >= requiredFee);\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(originDungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n\r\n        _transport(originDungeonId, _destinationDungeonId);\r\n    }\r\n\r\n    /**\r\n     * Private function to assigns location of a player\r\n     */\r\n    function _transport(uint _originDungeonId, uint _destinationDungeonId) private {\r\n        // If a player do not have any hero, claim first hero.\r\n        if (heroTokenContract.balanceOf(msg.sender) == 0) {\r\n            claimHero();\r\n        }\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Update the ownershipTokenCount.\r\n        dungeonPlayerCount[_originDungeonId]--;\r\n        dungeonPlayerCount[_destinationDungeonId]++;\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Update player location.\r\n        playerToDungeonID[msg.sender] = _destinationDungeonId;\r\n\r\n        // Emit the DungeonChallenged event.\r\n        PlayerTransported(now, msg.sender, _originDungeonId, _destinationDungeonId);\r\n    }\r\n\r\n\r\n    /* ======== OWNERSHIP FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @notice Used in transport, challenge and train, to get the genes of a specific hero,\r\n     *  a claim a hero if didn't have any.\r\n     */\r\n    function _getHeroGenesOrClaimFirstHero(uint _heroId) internal returns (uint heroId, uint heroGenes) {\r\n        heroId = _heroId;\r\n\r\n        // If a player do not have any hero, claim first hero first.\r\n        if (heroTokenContract.balanceOf(msg.sender) == 0) {\r\n            heroId = claimHero();\r\n        }\r\n\r\n        (,,,heroGenes) = heroTokenContract.heroes(heroId);\r\n    }\r\n\r\n    /**\r\n     * @dev Claim a new hero with empty genes.\r\n     */\r\n    function claimHero() public returns (uint) {\r\n        // If a player do not tranport to any dungeon yet, and it is the first time claiming the hero,\r\n        // set the dungeon location, increment the #0 Holyland player count by 1.\r\n        if (playerToDungeonID[msg.sender] == 0 && heroTokenContract.balanceOf(msg.sender) == 0) {\r\n            dungeonPlayerCount[0]++;\r\n        }\r\n\r\n        return heroTokenContract.createHero(0, msg.sender);\r\n    }\r\n\r\n\r\n    /* ======== SETTER FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Updates the fee contribution multiplier required for calling transport().\r\n     */\r\n    function setTransportationFeeMultiplier(uint _newTransportationFeeMultiplier) onlyOwner external {\r\n        transportationFeeMultiplier = _newTransportationFeeMultiplier;\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Throws if dungeon status do not allow transportation, also check for dungeon existence.\r\n     *  Also check if the capacity of the destination dungeon is reached.\r\n     */\r\n    modifier dungeonCanTransport(uint _destinationDungeonId) {\r\n        require(_destinationDungeonId < dungeonTokenContract.totalSupply());\r\n        uint status;\r\n        uint capacity;\r\n        (,status,,capacity,,,,,) = dungeonTokenContract.dungeons(_destinationDungeonId);\r\n        require(status == 0 || status == 1);\r\n\r\n        // Check if the capacity of the destination dungeon is reached.\r\n        // Capacity 0 = Infinity\r\n        require(capacity == 0 || dungeonPlayerCount[_destinationDungeonId] < capacity);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract DungeonChallenge is DungeonTransportation {\r\n\r\n    /**\r\n     * @dev The DungeonChallenged event is fired when user finished a dungeon challenge.\r\n     */\r\n    event DungeonChallenged(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint indexed heroId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newFloorGenes, uint successRewards, uint masterRewards);\r\n\r\n\r\n    /* ======== GAME SETTINGS ======== */\r\n\r\n    /**\r\n     * @notice The actual fee contribution required to call challenge() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty. The payment is accumulated to the dungeon rewards,\r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     *  1 finney = 0.001 ether\r\n     */\r\n    uint public challengeFeeMultiplier = 1 finney;\r\n\r\n    /**\r\n     * @dev The percentage for which successful challenger be rewarded of the dungeons' accumulated rewards.\r\n     *  The remaining rewards subtract dungeon master rewards will be used as the base rewards for new floor.\r\n     */\r\n    uint public challengeRewardsPercent = 64;\r\n\r\n    /**\r\n     * @dev The developer fee for owner\r\n     *  Note that when Ether Dungeon becomes truly decentralised, contract ownership will be ejected,\r\n     *  and the master rewards will be rewarded to the dungeon owner (Dungeon Masters).\r\n     */\r\n    uint public masterRewardsPercent = 8;\r\n\r\n    /**\r\n     * @dev The cooldown time period where a hero can engage in challenge again.\r\n     *  This settings will likely be changed to 20 minutes when multiple heroes system is launched in Version 1.\r\n     */\r\n    uint public challengeCooldownTime = 3 minutes;\r\n\r\n    /**\r\n     * @dev The preparation time period where a new dungeon is created, before it can be challenged.\r\n     *  This settings will likely be changed to a smaller period (e.g. 20-30 minutes) .\r\n     */\r\n    uint public dungeonPreparationTime = 60 minutes;\r\n\r\n    /**\r\n     * @dev The challenge rewards percentage used right after the preparation period.\r\n     */\r\n    uint public rushTimeChallengeRewardsPercent = 30;\r\n\r\n    /**\r\n     * @dev The number of floor in which the rushTimeChallengeRewardsPercent be applied.\r\n     */\r\n    uint public rushTimeFloorCount = 30;\r\n\r\n    /**\r\n     * @dev The main external function to call when a player challenge a dungeon,\r\n     *  it determines whether if the player successfully challenged the current floor.\r\n     *  Will generate a DungeonChallenged event.\r\n     */\r\n    function challenge(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanChallenge(_dungeonId) heroAllowedToChallenge(_heroId) external payable {\r\n        // Get the dungeon details from the token contract.\r\n        uint difficulty;\r\n        uint seedGenes;\r\n        (,, difficulty,,,,, seedGenes,) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        uint requiredFee = difficulty * challengeFeeMultiplier;\r\n        require(msg.value >= requiredFee);\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n\r\n        // Split the challenge function into multiple parts because of stack too deep error.\r\n        _challengePart2(_dungeonId, _heroId);\r\n    }\r\n\r\n    /**\r\n     * Split the challenge function into multiple parts because of stack too deep error.\r\n     */\r\n    function _challengePart2(uint _dungeonId, uint _heroId) private {\r\n        uint floorNumber;\r\n        uint rewards;\r\n        uint floorGenes;\r\n        (,,,, floorNumber,, rewards,, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Get the hero gene, or claim first hero.\r\n        uint heroGenes;\r\n        (_heroId, heroGenes) = _getHeroGenesOrClaimFirstHero(_heroId);\r\n\r\n        bool success = _getChallengeSuccess(heroGenes, _dungeonId, floorGenes);\r\n\r\n        uint newFloorGenes;\r\n        uint masterRewards;\r\n        uint successRewards;\r\n        uint newRewards;\r\n\r\n        // Whether a challenge is success or not is determined by a simple comparison between hero power and floor power.\r\n        if (success) {\r\n            newFloorGenes = _getNewFloorGene(_dungeonId);\r\n\r\n            masterRewards = rewards * masterRewardsPercent / 100;\r\n\r\n            if (floorNumber < rushTimeFloorCount) { // rush time right after prepration period\r\n                successRewards = rewards * rushTimeChallengeRewardsPercent / 100;\r\n\r\n                // The dungeon rewards for new floor as total rewards - challenge rewards - devleoper fee.\r\n                newRewards = rewards * (100 - rushTimeChallengeRewardsPercent - masterRewardsPercent) / 100;\r\n            } else {\r\n                successRewards = rewards * challengeRewardsPercent / 100;\r\n                newRewards = rewards * (100 - challengeRewardsPercent - masterRewardsPercent) / 100;\r\n            }\r\n\r\n            // TRIPLE CONFIRM sanity check.\r\n            require(successRewards + masterRewards + newRewards <= rewards);\r\n\r\n            // ** STORAGE UPDATE **\r\n            // Add new floor with the new floor genes and new rewards.\r\n            dungeonTokenContract.addDungeonNewFloor(_dungeonId, newRewards, newFloorGenes);\r\n\r\n            // Mark the challenge rewards available to be withdrawed by the player.\r\n            asyncSend(msg.sender, successRewards);\r\n\r\n            // Mark the master rewards available to be withdrawed by the dungeon master.\r\n            asyncSend(dungeonTokenContract.ownerOf(_dungeonId), masterRewards);\r\n        }\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Trigger the cooldown for the hero.\r\n        heroTokenContract.triggerCooldown(_heroId);\r\n\r\n        // Emit the DungeonChallenged event.\r\n        DungeonChallenged(now, msg.sender, _dungeonId, _heroId, heroGenes, floorNumber, floorGenes, success, newFloorGenes, successRewards, masterRewards);\r\n    }\r\n\r\n    /**\r\n     * Split the challenge function into multiple parts because of stack too deep error.\r\n     */\r\n    function _getChallengeSuccess(uint _heroGenes, uint _dungeonId, uint _floorGenes) private view returns (bool) {\r\n        // Determine if the player challenge successfuly the dungeon or not.\r\n        uint heroPower = _getHeroPower(_heroGenes, _dungeonId);\r\n        uint floorPower = _getDungeonPower(_floorGenes);\r\n\r\n        return heroPower > floorPower;\r\n    }\r\n\r\n    /**\r\n     * Split the challenge function into multiple parts because of stack too deep error.\r\n     */\r\n    function _getNewFloorGene(uint _dungeonId) private returns (uint) {\r\n        uint seedGenes;\r\n        uint floorGenes;\r\n        (,,,,,, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Calculate the new floor gene.\r\n        uint floorPower = _getDungeonPower(floorGenes);\r\n\r\n        // Call the external closed source secret function that determines the resulting floor \"genes\".\r\n        uint newFloorGenes = challengeScienceContract.mixGenes(floorGenes, seedGenes);\r\n\r\n        uint newFloorPower = _getDungeonPower(newFloorGenes);\r\n\r\n        // If the power decreased, rollback to the current floor genes.\r\n        if (newFloorPower < floorPower) {\r\n            newFloorGenes = floorGenes;\r\n        }\r\n\r\n        return newFloorGenes;\r\n    }\r\n\r\n\r\n    /* ======== SETTER FUNCTIONS ======== */\r\n\r\n    /**\r\n     * @dev Updates the fee contribution multiplier required for calling challenge().\r\n     */\r\n    function setChallengeFeeMultiplier(uint _newChallengeFeeMultiplier) onlyOwner external {\r\n        challengeFeeMultiplier = _newChallengeFeeMultiplier;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the challenge rewards pecentage.\r\n     */\r\n    function setChallengeRewardsPercent(uint _newChallengeRewardsPercent) onlyOwner external {\r\n        challengeRewardsPercent = _newChallengeRewardsPercent;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the master rewards percentage.\r\n     */\r\n    function setMasterRewardsPercent(uint _newMasterRewardsPercent) onlyOwner external {\r\n        masterRewardsPercent = _newMasterRewardsPercent;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the challenge cooldown time.\r\n     */\r\n    function setChallengeCooldownTime(uint _newChallengeCooldownTime) onlyOwner external {\r\n        challengeCooldownTime = _newChallengeCooldownTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the challenge cooldown time.\r\n     */\r\n    function setDungeonPreparationTime(uint _newDungeonPreparationTime) onlyOwner external {\r\n        dungeonPreparationTime = _newDungeonPreparationTime;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the rush time challenge rewards percentage.\r\n     */\r\n    function setRushTimeChallengeRewardsPercent(uint _newRushTimeChallengeRewardsPercent) onlyOwner external {\r\n        rushTimeChallengeRewardsPercent = _newRushTimeChallengeRewardsPercent;\r\n    }\r\n\r\n    /**\r\n     * @dev Updates the rush time floor count.\r\n     */\r\n    function setRushTimeFloorCount(uint _newRushTimeFloorCount) onlyOwner external {\r\n        rushTimeFloorCount = _newRushTimeFloorCount;\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Throws if dungeon status do not allow challenge, also check for dungeon existence.\r\n     *  Also check if the user is in the dungeon.\r\n     *  Also check if the dungeon is not in preparation period.\r\n     */\r\n    modifier dungeonCanChallenge(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        uint creationTime;\r\n        uint status;\r\n        (creationTime, status,,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        require(status == 0 || status == 2);\r\n\r\n        // Check if the user is in the dungeon.\r\n        require(playerToDungeonID[msg.sender] == _dungeonId);\r\n\r\n        // Check if the dungeon is not in preparation period.\r\n        require(creationTime + dungeonPreparationTime <= now);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if player does not own the hero, or it is still in cooldown.\r\n     *  Unless the player does not have any hero yet, which will auto claim one during first challenge / train.\r\n     */\r\n    modifier heroAllowedToChallenge(uint _heroId) {\r\n        if (heroTokenContract.balanceOf(msg.sender) > 0) {\r\n            // You can only challenge with your own hero.\r\n            require(heroTokenContract.ownerOf(_heroId) == msg.sender);\r\n\r\n            uint cooldownStartTime;\r\n            (, cooldownStartTime,,) = heroTokenContract.heroes(_heroId);\r\n            require(cooldownStartTime + challengeCooldownTime <= now);\r\n        }\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract DungeonTraining is DungeonChallenge {\r\n\r\n    /**\r\n     * @dev The HeroTrained event is fired when user finished a training.\r\n     */\r\n    event HeroTrained(uint timestamp, address indexed playerAddress, uint indexed dungeonId, uint indexed heroId, uint heroGenes, uint floorNumber, uint floorGenes, bool success, uint newHeroGenes);\r\n\r\n\r\n    /* ======== GAME SETTINGS ======== */\r\n\r\n    /**\r\n     * @dev The actual fee contribution required to call trainX() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty, times X. The payment is accumulated to the dungeon rewards,\r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     *  1 finney = 0.001 ether\r\n     */\r\n    uint public trainingFeeMultiplier = 2 finney;\r\n\r\n    /**\r\n     * @dev The discounted training fee multiplier to be used in the preparation period.\r\n     * 1000 szabo = 0.001 ether\r\n     */\r\n    uint public preparationPeriodTrainingFeeMultiplier = 1800 szabo;\r\n\r\n    /**\r\n     * @dev The actual fee contribution required to call trainEquipment() is calculated by this feeMultiplier,\r\n     *  times the dungeon difficulty, times X. The payment is accumulated to the dungeon rewards,\r\n     *  and a large proportion will be claimed by whoever successfully challenged the floor.\r\n     *  (No preparation period discount on equipment training.)\r\n     *  1000 szabo = 0.001 ether\r\n     */\r\n    uint public equipmentTrainingFeeMultiplier = 500 szabo;\r\n\r\n    /**\r\n     * @dev The external function to call when a hero train with a dungeon,\r\n     *  it determines whether whether a training is successfully, and the resulting genes.\r\n     *  Will generate a DungeonChallenged event.\r\n     */\r\n    function train1(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        _train(_dungeonId, _heroId, 0, 1);\r\n    }\r\n\r\n    function train2(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        _train(_dungeonId, _heroId, 0, 2);\r\n    }\r\n\r\n    function train3(uint _dungeonId, uint _heroId) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        _train(_dungeonId, _heroId, 0, 3);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to call when a hero train a particular equipment with a dungeon,\r\n     *  it determines whether whether a training is successfully, and the resulting genes.\r\n     *  Will generate a DungeonChallenged event.\r\n     *  _equipmentIndex is the index of equipment: 0 is train all attributes, including equipments and stats.\r\n     *  1: weapon | 2: shield | 3: armor | 4: shoe | 5: helmet | 6: gloves | 7: belt | 8: shawl\r\n     */\r\n    function trainEquipment(uint _dungeonId, uint _heroId, uint _equipmentIndex) whenNotPaused dungeonCanTrain(_dungeonId) heroAllowedToTrain(_heroId) external payable {\r\n        require(_equipmentIndex <= 8);\r\n\r\n        _train(_dungeonId, _heroId, _equipmentIndex, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev An internal function of a hero train with dungeon,\r\n     *  it determines whether whether a training is successfully, and the resulting genes.\r\n     *  Will generate a DungeonChallenged event.\r\n     */\r\n    function _train(uint _dungeonId, uint _heroId, uint _equipmentIndex, uint _trainingTimes) private {\r\n        // Get the dungeon details from the token contract.\r\n        uint creationTime;\r\n        uint difficulty;\r\n        uint floorNumber;\r\n        uint rewards;\r\n        uint seedGenes;\r\n        uint floorGenes;\r\n        (creationTime,,difficulty,,floorNumber,,rewards,seedGenes,floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Check for _trainingTimes abnormality, we probably won't have any feature that train a hero 10 times with a single call.\r\n        require(_trainingTimes < 10);\r\n\r\n        // Checks for payment, any exceeding funds will be transferred back to the player.\r\n        uint requiredFee;\r\n\r\n        if (_equipmentIndex > 0) { // train specific equipments\r\n            requiredFee = difficulty * equipmentTrainingFeeMultiplier * _trainingTimes;\r\n        } else if (now < creationTime + dungeonPreparationTime) { // train all attributes, preparation period\r\n            requiredFee = difficulty * preparationPeriodTrainingFeeMultiplier * _trainingTimes;\r\n        } else { // train all attributes, normal period\r\n            requiredFee = difficulty * trainingFeeMultiplier * _trainingTimes;\r\n        }\r\n\r\n        require(msg.value >= requiredFee);\r\n\r\n        // Get the hero gene, or claim first hero.\r\n        uint heroGenes;\r\n        (_heroId, heroGenes) = _getHeroGenesOrClaimFirstHero(_heroId);\r\n\r\n        // ** STORAGE UPDATE **\r\n        // Increment the accumulated rewards for the dungeon.\r\n        dungeonTokenContract.addDungeonRewards(_dungeonId, requiredFee);\r\n\r\n        // Calculate any excess funds and make it available to be withdrawed by the player.\r\n        asyncSend(msg.sender, msg.value - requiredFee);\r\n\r\n        // Split the _train function into multiple parts because of stack too deep error.\r\n        _trainPart2(_dungeonId, _heroId, heroGenes, _equipmentIndex, _trainingTimes);\r\n    }\r\n\r\n    /**\r\n     * Split the _train function into multiple parts because of Stack Too Deep error.\r\n     */\r\n    function _trainPart2(uint _dungeonId, uint _heroId, uint _heroGenes, uint _equipmentIndex, uint _trainingTimes) private {\r\n        // Get the dungeon details from the token contract.\r\n        uint floorNumber;\r\n        uint floorGenes;\r\n        (,,,, floorNumber,,,, floorGenes) = dungeonTokenContract.dungeons(_dungeonId);\r\n\r\n        // Determine if the hero training is successful or not, and the resulting genes.\r\n        uint heroPower = _getHeroPower(_heroGenes, _dungeonId);\r\n\r\n        uint newHeroGenes = _heroGenes;\r\n        uint newHeroPower = heroPower;\r\n\r\n        // Train the hero multiple times according to _trainingTimes,\r\n        // each time if the resulting power is larger, update new hero power.\r\n        for (uint i = 0; i < _trainingTimes; i++) {\r\n            // Call the external closed source secret function that determines the resulting hero \"genes\".\r\n            uint tmpHeroGenes = trainingScienceContract.mixGenes(newHeroGenes, floorGenes, _equipmentIndex);\r\n\r\n            uint tmpHeroPower = _getHeroPower(tmpHeroGenes, _dungeonId);\r\n\r\n            if (tmpHeroPower > newHeroPower) {\r\n                newHeroGenes = tmpHeroGenes;\r\n                newHeroPower = tmpHeroPower;\r\n            }\r\n        }\r\n\r\n        // Prevent reduced power.\r\n        if (newHeroPower > heroPower) {\r\n            // ** STORAGE UPDATE **\r\n            // Set the upgraded hero genes.\r\n            heroTokenContract.setHeroGenes(_heroId, newHeroGenes);\r\n        }\r\n\r\n        // Emit the HeroTrained event.\r\n        HeroTrained(now, msg.sender, _dungeonId, _heroId, _heroGenes, floorNumber, floorGenes, newHeroPower > heroPower, newHeroGenes);\r\n    }\r\n\r\n\r\n    /* ======== SETTER FUNCTIONS ======== */\r\n\r\n    /// @dev Updates the fee contribution multiplier required for calling trainX().\r\n    function setTrainingFeeMultiplier(uint _newTrainingFeeMultiplier) onlyOwner external {\r\n        trainingFeeMultiplier = _newTrainingFeeMultiplier;\r\n    }\r\n\r\n    /// @dev Updates the fee contribution multiplier for preparation period required for calling trainX().\r\n    function setPreparationPeriodTrainingFeeMultiplier(uint _newPreparationPeriodTrainingFeeMultiplier) onlyOwner external {\r\n        preparationPeriodTrainingFeeMultiplier = _newPreparationPeriodTrainingFeeMultiplier;\r\n    }\r\n\r\n    /// @dev Updates the fee contribution multiplier required for calling trainEquipment().\r\n    function setEquipmentTrainingFeeMultiplier(uint _newEquipmentTrainingFeeMultiplier) onlyOwner external {\r\n        equipmentTrainingFeeMultiplier = _newEquipmentTrainingFeeMultiplier;\r\n    }\r\n\r\n\r\n    /* ======== MODIFIERS ======== */\r\n\r\n    /**\r\n     * @dev Throws if dungeon status do not allow training, also check for dungeon existence.\r\n     *  Also check if the user is in the dungeon.\r\n     */\r\n    modifier dungeonCanTrain(uint _dungeonId) {\r\n        require(_dungeonId < dungeonTokenContract.totalSupply());\r\n        uint status;\r\n        (,status,,,,,,,) = dungeonTokenContract.dungeons(_dungeonId);\r\n        require(status == 0 || status == 3);\r\n\r\n        // Also check if the user is in the dungeon.\r\n        require(playerToDungeonID[msg.sender] == _dungeonId);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if player does not own the hero.\r\n     *  Unless the player does not have any hero yet, which will auto claim one during first challenge / train.\r\n     */\r\n    modifier heroAllowedToTrain(uint _heroId) {\r\n        if (heroTokenContract.balanceOf(msg.sender) > 0) {\r\n            // You can only train with your own hero.\r\n            require(heroTokenContract.ownerOf(_heroId) == msg.sender);\r\n        }\r\n        _;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title DungeonCoreBeta\r\n * @dev Core Contract of Ether Dungeon.\r\n *  When Version 1 launches, DungeonCoreVersion1 contract will be deployed and DungeonCoreBeta will be destroyed.\r\n *  Since all dungeons and heroes are stored as tokens in external contracts, they remains immutable.\r\n */\r\ncontract DungeonCoreBeta is Destructible, DungeonTraining {\r\n\r\n    /**\r\n     * Initialize the DungeonCore contract with all the required contract addresses.\r\n     */\r\n    function DungeonCoreBeta(\r\n        address _dungeonTokenAddress,\r\n        address _heroTokenAddress,\r\n        address _challengeScienceAddress,\r\n        address _trainingScienceAddress\r\n    ) public {\r\n        dungeonTokenContract = DungeonToken(_dungeonTokenAddress);\r\n        heroTokenContract = HeroToken(_heroTokenAddress);\r\n        challengeScienceContract = ChallengeScienceInterface(_challengeScienceAddress);\r\n        trainingScienceContract = TrainingScienceInterface(_trainingScienceAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific dungeon by its ID.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonDetails(uint _id) external view returns (uint creationTime, uint status, uint difficulty, uint capacity, bool isReady, uint playerCount) {\r\n        require(_id < dungeonTokenContract.totalSupply());\r\n\r\n        // Didn't get the \"floorCreationTime\" because of Stack Too Deep error.\r\n        (creationTime, status, difficulty, capacity,,,,,) = dungeonTokenContract.dungeons(_id);\r\n\r\n        // Dungeon is ready to be challenged (not in preparation mode).\r\n        isReady = creationTime + dungeonPreparationTime <= now;\r\n        playerCount = dungeonPlayerCount[_id];\r\n    }\r\n\r\n    /**\r\n     * @dev Split floor related details out of getDungeonDetails, just to avoid Stack Too Deep error.\r\n     * @param _id The ID of the dungeon.\r\n     */\r\n    function getDungeonFloorDetails(uint _id) external view returns (uint floorNumber, uint floorCreationTime, uint rewards, uint seedGenes, uint floorGenes) {\r\n        require(_id < dungeonTokenContract.totalSupply());\r\n\r\n        // Didn't get the \"floorCreationTime\" because of Stack Too Deep error.\r\n        (,,,, floorNumber, floorCreationTime, rewards, seedGenes, floorGenes) = dungeonTokenContract.dungeons(_id);\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific hero by its ID.\r\n     * @param _id The ID of the hero.\r\n     */\r\n    function getHeroDetails(uint _id) external view returns (uint creationTime, uint cooldownStartTime, uint cooldownIndex, uint genes, bool isReady) {\r\n        require(_id < heroTokenContract.totalSupply());\r\n\r\n        (creationTime, cooldownStartTime, cooldownIndex, genes) = heroTokenContract.heroes(_id);\r\n\r\n        // Hero is ready to challenge (not in cooldown mode).\r\n        isReady = cooldownStartTime + challengeCooldownTime <= now;\r\n    }\r\n\r\n    /**\r\n     * @dev The external function to get all the relevant information about a specific player by its address.\r\n     * @param _address The address of the player.\r\n     */\r\n    function getPlayerDetails(address _address) external view returns (uint dungeonId, uint payment) {\r\n        dungeonId = playerToDungeonID[_address];\r\n        payment = payments[_address];\r\n    }\r\n\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeCooldownTime\",\"type\":\"uint256\"}],\"name\":\"setChallengeCooldownTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dungeonPlayerCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dungeonTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rushTimeFloorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDungeonDetails\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"uint256\"},{\"name\":\"difficulty\",\"type\":\"uint256\"},{\"name\":\"capacity\",\"type\":\"uint256\"},{\"name\":\"isReady\",\"type\":\"bool\"},{\"name\":\"playerCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"challenge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDungeonPreparationTime\",\"type\":\"uint256\"}],\"name\":\"setDungeonPreparationTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRushTimeChallengeRewardsPercent\",\"type\":\"uint256\"}],\"name\":\"setRushTimeChallengeRewardsPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTrainingFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setTrainingFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"train1\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heroTokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTransportationFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setTransportationFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transportationFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newHeroTokenContract\",\"type\":\"address\"}],\"name\":\"setHeroTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerToDungeonID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDungeonTokenContract\",\"type\":\"address\"}],\"name\":\"setDungeonTokenContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEquipmentTrainingFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setEquipmentTrainingFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getDungeonFloorDetails\",\"outputs\":[{\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"name\":\"floorCreationTime\",\"type\":\"uint256\"},{\"name\":\"rewards\",\"type\":\"uint256\"},{\"name\":\"seedGenes\",\"type\":\"uint256\"},{\"name\":\"floorGenes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getHeroDetails\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"cooldownStartTime\",\"type\":\"uint256\"},{\"name\":\"cooldownIndex\",\"type\":\"uint256\"},{\"name\":\"genes\",\"type\":\"uint256\"},{\"name\":\"isReady\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"train3\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeCooldownTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMasterRewardsPercent\",\"type\":\"uint256\"}],\"name\":\"setMasterRewardsPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preparationPeriodTrainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destinationDungeonId\",\"type\":\"uint256\"}],\"name\":\"transport\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setChallengeFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"},{\"name\":\"_equipmentIndex\",\"type\":\"uint256\"}],\"name\":\"trainEquipment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTrainingScienceAddress\",\"type\":\"address\"}],\"name\":\"setTrainingScienceContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dungeonId\",\"type\":\"uint256\"},{\"name\":\"_heroId\",\"type\":\"uint256\"}],\"name\":\"train2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rushTimeChallengeRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeRewardsPercent\",\"type\":\"uint256\"}],\"name\":\"setChallengeRewardsPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dungeonPreparationTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPreparationPeriodTrainingFeeMultiplier\",\"type\":\"uint256\"}],\"name\":\"setPreparationPeriodTrainingFeeMultiplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPlayerDetails\",\"outputs\":[{\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"name\":\"payment\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimHero\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newChallengeScienceAddress\",\"type\":\"address\"}],\"name\":\"setChallengeScienceContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"equipmentTrainingFeeMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRushTimeFloorCount\",\"type\":\"uint256\"}],\"name\":\"setRushTimeFloorCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeRewardsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dungeonTokenAddress\",\"type\":\"address\"},{\"name\":\"_heroTokenAddress\",\"type\":\"address\"},{\"name\":\"_challengeScienceAddress\",\"type\":\"address\"},{\"name\":\"_trainingScienceAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"heroGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newHeroGenes\",\"type\":\"uint256\"}],\"name\":\"HeroTrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dungeonId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"heroId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"heroGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"newFloorGenes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"successRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"masterRewards\",\"type\":\"uint256\"}],\"name\":\"DungeonChallenged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"originDungeonId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"destinationDungeonId\",\"type\":\"uint256\"}],\"name\":\"PlayerTransported\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]", "ContractName": "DungeonCoreBeta", "CompilerVersion": "v0.4.19+commit.c4cbbb05", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "000000000000000000000000dc81a13cfd9aecb8ddc9e4c3c87c3ec9fbc98583000000000000000000000000f93a631cd05a88be1b0077fd2ade62a54382cc6a000000000000000000000000aa57ada57c1e6a391eebdfbc599d7fc0870eae38000000000000000000000000fdf4fdc7a3505aac4b57ad23fa620194d6703444", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://d721d6d6fbeffa8acf2055f2516130153ed75ff8cbdc7c0dd8943a9d0b6575f5"}