{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"/contracts/BubblehouseNFTV3.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ncontract OwnableDelegateProxy {}\\n// Used to delegate ownership of a contract to another address, to save on unneeded transactions to approve contract use for users\\ncontract OpenSeaProxyRegistry {\\n    mapping(address => OwnableDelegateProxy) public proxies;\\n}\\n\\ninterface IERC165 {\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\\ninterface IERC721 is IERC165 {\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    function approve(address to, uint256 tokenId) external;\\n    function setApprovalForAll(address operator, bool _approved) external;\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\\ninterface IERC721Metadata is IERC721 {\\n    function name() external view returns (string memory);\\n    function symbol() external view returns (string memory);\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\\ncontract BubblehouseNFT3 is IERC165, IERC721, IERC721Metadata {\\n\\n    // --- Init ---\\n\\n    constructor(string memory name_, address openSeaProxyRegistryAddress_, string memory baseURI_, address sharedWallet_) {\\n        _name = name_;\\n        _owner = msg.sender;\\n        openSeaProxyRegistryAddress = openSeaProxyRegistryAddress_;\\n        isOpenSeaEnabled = (openSeaProxyRegistryAddress_ != address(0));\\n        _baseURI = baseURI_;\\n        if (sharedWallet_ != address(0)) {\\n            _isMinter[sharedWallet_] = true;\\n        }\\n    }\\n\\n\\n    // --- Name and symbol ---\\n\\n    string private _name;\\n\\n    function name() public view override returns (string memory) {\\n        return _name;\\n    }\\n\\n    function symbol() public pure override returns (string memory) {\\n        return \\\"BUBBLENFT3\\\";\\n    }\\n\\n\\n    // --- ERC165 ---\\n\\n    function supportsInterface(bytes4 interfaceId) public pure override returns (bool) {\\n        return\\n            interfaceId == type(IERC721).interfaceId ||\\n            interfaceId == type(IERC721Metadata).interfaceId ||\\n            interfaceId == type(IERC165).interfaceId;\\n    }\\n\\n\\n    // --- Delegation ---\\n\\n    function _msgSender() internal view returns (address) {\\n        // TODO: support for OpenSea's metatransactions?\\n        return msg.sender;\\n    }\\n\\n\\n    // --- Balances ----\\n\\n    // owner address => token count\\n    mapping(address => uint256) private _balances;\\n\\n    function balanceOf(address owner) public view override returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDR\\\");\\n        return _balances[owner];\\n    }\\n\\n\\n    // --- Owners ---\\n\\n    // token ID => owner address\\n    mapping(uint256 => address) private _owners;\\n\\n    function ownerOf(uint256 tokenId) public view override returns (address) {\\n        address owner = _owners[tokenId];\\n        require(owner != address(0), \\\"INVALID_TOKEN\\\");\\n        return owner;\\n    }\\n\\n    function _exists(uint256 tokenId) internal view returns (bool) {\\n        return _owners[tokenId] != address(0);\\n    }\\n\\n\\n\\n    // --- Approvals ---\\n\\n    // token ID => approved address\\n    mapping(uint256 => address) private _tokenApprovals;\\n\\n    // owner => operator approvals\\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\\n\\n    function approve(address to, uint256 tokenId) public override {\\n        address owner = ownerOf(tokenId);\\n        require(to != owner, \\\"IDEMPOTENT\\\");\\n        require(_msgSender() == owner || isApprovedForAll(owner, _msgSender()), \\\"Forbidden\\\");\\n        _approve(to, tokenId);\\n    }\\n\\n    function getApproved(uint256 tokenId) public view override returns (address) {\\n        require(_exists(tokenId), \\\"INVALID_TOKEN\\\");\\n        return _tokenApprovals[tokenId];\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    function isApprovedForAll(address owner, address operator) public view override returns (bool) {\\n        return _operatorApprovals[owner][operator] || isOpenSeaOperator(owner, operator);\\n    }\\n\\n    function _approve(address to, uint256 tokenId) internal {\\n        _tokenApprovals[tokenId] = to;\\n        emit Approval(ownerOf(tokenId), to, tokenId);\\n    }\\n\\n    function _clearApproval(uint256 tokenId) internal {\\n        _approve(address(0), tokenId);\\n    }\\n\\n    function _setApprovalForAll(address owner, address operator, bool approved) internal {\\n        require(owner != operator, \\\"IDEMPOTENT\\\");\\n        _operatorApprovals[owner][operator] = approved;\\n        emit ApprovalForAll(owner, operator, approved);\\n    }\\n\\n\\n    // --- OpenSea ---\\n\\n    bool public isOpenSeaEnabled = true;\\n    address public openSeaProxyRegistryAddress;\\n\\n    function isOpenSeaOperator(address owner, address operator) internal view returns (bool) {\\n        if (!isOpenSeaEnabled) {\\n            return false;\\n        }\\n        OpenSeaProxyRegistry proxyRegistry = OpenSeaProxyRegistry(openSeaProxyRegistryAddress);\\n        return (address(proxyRegistry.proxies(owner)) == operator);\\n    }\\n\\n    function setOpenSeaEnabled(bool enabled) external onlyOwner {\\n        isOpenSeaEnabled = enabled;\\n    }\\n\\n    function setOpenSeaProxyRegistryAddress(address addr) external onlyOwner {\\n        openSeaProxyRegistryAddress = addr;\\n    }\\n\\n\\n    // -- Access checks ---\\n\\n    // Returns whether `spender` is allowed to manage `tokenId`.\\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view returns (bool) {\\n        address owner = _owners[tokenId];\\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\\n    }\\n\\n\\n    // --- Metadata ---\\n\\n    string private _baseURI;\\n\\n    function setBaseURI(string memory newBaseURI) public onlyOwner {\\n        _baseURI = newBaseURI;\\n    }\\n\\n    function baseTokenURI() public view returns (string memory) {\\n        return _baseURI;\\n    }\\n\\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\\n        require(_exists(tokenId), \\\"INVALID_TOKEN\\\");\\n        return string(abi.encodePacked(_baseURI, intToString(tokenId)));\\n    }\\n\\n\\n\\n    // --- Minting ---\\n\\n    function mint(address to, uint256 tokenId) public onlyMinter {\\n        _mint(to, tokenId);\\n    }\\n\\n    function _mint(address to, uint256 tokenId) internal {\\n        require(to != address(0), \\\"ZERO_ADDR\\\");\\n\\n        address owner = _owners[tokenId];\\n        if (owner != address(0)) {\\n            if (owner == to) {\\n                revert(\\\"IDEMPOTENT\\\");\\n            }\\n            revert(\\\"TOKEN_EXISTS\\\");\\n        }\\n\\n        _beforeTokenTransfer(address(0), to, tokenId);\\n\\n        unchecked { _balances[to] += 1; }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(address(0), to, tokenId);\\n\\n        _afterTokenTransfer(address(0), to, tokenId);\\n    }\\n\\n\\n    // --- Transfers ---\\n\\n    function transferFrom(address from, address to, uint256 tokenId) public override {\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"FORBIDDEN\\\");\\n        _transfer(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId) public override {\\n        transferFrom(from, to, tokenId);\\n    }\\n\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory /*data*/) public override {\\n        transferFrom(from, to, tokenId);\\n    }\\n\\n    function _transfer(address from, address to, uint256 tokenId) internal {\\n        require(_owners[tokenId] == from, \\\"FORBIDDEN\\\");\\n        require(to != address(0), \\\"ZERO_ADDR\\\");\\n\\n        _beforeTokenTransfer(from, to, tokenId);\\n\\n        _clearApproval(tokenId);\\n\\n        unchecked {\\n            _balances[from] -= 1;\\n            _balances[to] += 1;\\n        }\\n        _owners[tokenId] = to;\\n\\n        emit Transfer(from, to, tokenId);\\n\\n        _afterTokenTransfer(from, to, tokenId);\\n    }\\n\\n\\n    // --- Burn ---\\n\\n    function burn(uint256 tokenId) public {\\n        address owner = _owners[tokenId];\\n        if (owner == address(0)) {\\n            revert(\\\"ALREADY_BURNED\\\");\\n        }\\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \\\"FORBIDDEN\\\");\\n        _burn(tokenId);\\n    }\\n\\n    function _burn(uint256 tokenId) internal {\\n        address owner = ownerOf(tokenId);\\n\\n        _beforeTokenTransfer(owner, address(0), tokenId);\\n\\n        _clearApproval(tokenId);\\n\\n        unchecked {\\n            _balances[owner] -= 1;\\n        }\\n        delete _owners[tokenId];\\n\\n        emit Transfer(owner, address(0), tokenId);\\n\\n        _afterTokenTransfer(owner, address(0), tokenId);\\n    }\\n\\n\\n    // --- Hooks ---\\n    //\\n    // Zero `from` is mint, zero `to` is burn.\\n\\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal {}\\n    function _afterTokenTransfer(address from, address to, uint256 tokenId) internal {}\\n\\n\\n    // --- Ownership ---\\n\\n    address private _owner;\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender, \\\"FORBIDDEN\\\");\\n        _;\\n    }\\n\\n    function getOwner() public view returns (address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address newOwner) public onlyOwner {\\n        require(newOwner != address(0), \\\"ZERO_ADDR\\\");\\n        _owner = newOwner;\\n    }\\n\\n\\n    // --- Minters ---\\n\\n    mapping(address => bool) private _isMinter;\\n\\n    modifier onlyMinter() {\\n        require(_isMinter[msg.sender], \\\"FORBIDDEN\\\");\\n        _;\\n    }\\n\\n    function setMinter(address addr, bool authorized) external onlyOwner {\\n        require(addr != address(0), \\\"ZERO_ADDR\\\");\\n        _isMinter[addr] = authorized;\\n    }\\n\\n\\n    // --- Utils ---\\n    \\n    // From @openzeppelin/contracts/utils/Strings.sol\\n    function intToString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"evmVersion\": \"constantinople\",\r\n    \"libraries\": {},\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    }\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"openSeaProxyRegistryAddress_\",\"type\":\"address\"},{\"internalType\":\"string\",\"name\":\"baseURI_\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"sharedWallet_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseTokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isOpenSeaEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"openSeaProxyRegistryAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"newBaseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"authorized\",\"type\":\"bool\"}],\"name\":\"setMinter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setOpenSeaEnabled\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setOpenSeaProxyRegistryAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BubblehouseNFT3", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000080000000000000000000000000a5409ec958c83c3f309868babaca7c86dcb077c100000000000000000000000000000000000000000000000000000000000000c000000000000000000000000060bdb84551e1e0e42a54a1951015410dfa54f81d0000000000000000000000000000000000000000000000000000000000000012427562626c65686f757365204e46542056330000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002568747470733a2f2f6170692e627562626c65686f7573652e636f6d2f746f6b656e732f302f000000000000000000000000000000000000000000000000000000", "EVMVersion": "constantinople", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}