{"SourceCode": "// SPDX-License-Identifier: AGPL-3.0-only\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\r\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\r\nabstract contract ERC721 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                 EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\r\n\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                          METADATA STORAGE/LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    function tokenURI(uint256 id) public view virtual returns (string memory);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ERC721 STORAGE                        \r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(uint256 => address) public ownerOf;\r\n\r\n    mapping(uint256 => address) public getApproved;\r\n\r\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(string memory _name, string memory _symbol) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC721 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 id) public virtual {\r\n        address owner = ownerOf[id];\r\n\r\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\r\n\r\n        getApproved[id] = spender;\r\n\r\n        emit Approval(owner, spender, id);\r\n    }\r\n\r\n    function setApprovalForAll(address operator, bool approved) public virtual {\r\n        isApprovedForAll[msg.sender][operator] = approved;\r\n\r\n        emit ApprovalForAll(msg.sender, operator, approved);\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        require(from == ownerOf[id], \"WRONG_FROM\");\r\n\r\n        require(to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        require(\r\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\r\n            \"NOT_AUTHORIZED\"\r\n        );\r\n\r\n        // Underflow of the sender's balance is impossible because we check for\r\n        // ownership above and the recipient's balance can't realistically overflow.\r\n        unchecked {\r\n            balanceOf[from]--;\r\n\r\n            balanceOf[to]++;\r\n        }\r\n\r\n        ownerOf[id] = to;\r\n\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(from, to, id);\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 id,\r\n        bytes memory data\r\n    ) public virtual {\r\n        transferFrom(from, to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC165 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\r\n        return\r\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\r\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\r\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 id) internal virtual {\r\n        require(to != address(0), \"INVALID_RECIPIENT\");\r\n\r\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\r\n\r\n        // Counter overflow is incredibly unrealistic.\r\n        unchecked {\r\n            balanceOf[to]++;\r\n        }\r\n\r\n        ownerOf[id] = to;\r\n\r\n        emit Transfer(address(0), to, id);\r\n    }\r\n\r\n    function _burn(uint256 id) internal virtual {\r\n        address owner = ownerOf[id];\r\n\r\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\r\n\r\n        // Ownership check above ensures no underflow.\r\n        unchecked {\r\n            balanceOf[owner]--;\r\n        }\r\n\r\n        delete ownerOf[id];\r\n\r\n        delete getApproved[id];\r\n\r\n        emit Transfer(owner, address(0), id);\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL SAFE MINT LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _safeMint(address to, uint256 id) internal virtual {\r\n        _mint(to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n\r\n    function _safeMint(\r\n        address to,\r\n        uint256 id,\r\n        bytes memory data\r\n    ) internal virtual {\r\n        _mint(to, id);\r\n\r\n        require(\r\n            to.code.length == 0 ||\r\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\r\n                ERC721TokenReceiver.onERC721Received.selector,\r\n            \"UNSAFE_RECIPIENT\"\r\n        );\r\n    }\r\n}\r\n\r\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(\r\n        address operator,\r\n        address from,\r\n        uint256 id,\r\n        bytes calldata data\r\n    ) external returns (bytes4);\r\n}\r\n\r\n\r\n// File @rari-capital/solmate/src/tokens/ERC20.sol@v6.2.0\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\r\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\r\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\r\nabstract contract ERC20 {\r\n    /*///////////////////////////////////////////////////////////////\r\n                                  EVENTS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 amount);\r\n\r\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             METADATA STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint8 public immutable decimals;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    uint256 public totalSupply;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                             EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    bytes32 public constant PERMIT_TYPEHASH =\r\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\r\n\r\n    uint256 internal immutable INITIAL_CHAIN_ID;\r\n\r\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\r\n\r\n    mapping(address => uint256) public nonces;\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                               CONSTRUCTOR\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    constructor(\r\n        string memory _name,\r\n        string memory _symbol,\r\n        uint8 _decimals\r\n    ) {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n\r\n        INITIAL_CHAIN_ID = block.chainid;\r\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              ERC20 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\r\n        allowance[msg.sender][spender] = amount;\r\n\r\n        emit Approval(msg.sender, spender, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\r\n        balanceOf[msg.sender] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(msg.sender, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) public virtual returns (bool) {\r\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\r\n\r\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\r\n\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(from, to, amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                              EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(\r\n        address owner,\r\n        address spender,\r\n        uint256 value,\r\n        uint256 deadline,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s\r\n    ) public virtual {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        // Unchecked because the only math done is incrementing\r\n        // the owner's nonce which cannot realistically overflow.\r\n        unchecked {\r\n            bytes32 digest = keccak256(\r\n                abi.encodePacked(\r\n                    \"\\x19\\x01\",\r\n                    DOMAIN_SEPARATOR(),\r\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\r\n                )\r\n            );\r\n\r\n            address recoveredAddress = ecrecover(digest, v, r, s);\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n\r\n            allowance[recoveredAddress][spender] = value;\r\n        }\r\n\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\r\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\r\n    }\r\n\r\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\r\n                    keccak256(bytes(name)),\r\n                    keccak256(\"1\"),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                       INTERNAL MINT/BURN LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function _mint(address to, uint256 amount) internal virtual {\r\n        totalSupply += amount;\r\n\r\n        // Cannot overflow because the sum of all user\r\n        // balances can't exceed the max uint256 value.\r\n        unchecked {\r\n            balanceOf[to] += amount;\r\n        }\r\n\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    function _burn(address from, uint256 amount) internal virtual {\r\n        balanceOf[from] -= amount;\r\n\r\n        // Cannot underflow because a user's balance\r\n        // will never be larger than the total supply.\r\n        unchecked {\r\n            totalSupply -= amount;\r\n        }\r\n\r\n        emit Transfer(from, address(0), amount);\r\n    }\r\n}\r\n\r\n\r\n// File @rari-capital/solmate/src/utils/SafeTransferLib.sol@v6.2.0\r\n\r\n\r\npragma solidity >=0.8.0;\r\n\r\n/// @notice Safe ETH and ERC20 transfer library that gracefully handles missing return values.\r\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SafeTransferLib.sol)\r\n/// @author Modified from Gnosis (https://github.com/gnosis/gp-v2-contracts/blob/main/src/contracts/libraries/GPv2SafeERC20.sol)\r\n/// @dev Use with caution! Some functions in this library knowingly create dirty bits at the destination of the free memory pointer.\r\nlibrary SafeTransferLib {\r\n    /*///////////////////////////////////////////////////////////////\r\n                            ETH OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferETH(address to, uint256 amount) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Transfer the ETH and store if it succeeded or not.\r\n            callStatus := call(gas(), to, amount, 0, 0, 0, 0)\r\n        }\r\n\r\n        require(callStatus, \"ETH_TRANSFER_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                           ERC20 OPERATIONS\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function safeTransferFrom(\r\n        ERC20 token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x23b872dd00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(from, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"from\" argument.\r\n            mstore(add(freeMemoryPointer, 36), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 68), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 100 because the calldata length is 4 + 32 * 3.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 100, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FROM_FAILED\");\r\n    }\r\n\r\n    function safeTransfer(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0xa9059cbb00000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"TRANSFER_FAILED\");\r\n    }\r\n\r\n    function safeApprove(\r\n        ERC20 token,\r\n        address to,\r\n        uint256 amount\r\n    ) internal {\r\n        bool callStatus;\r\n\r\n        assembly {\r\n            // Get a pointer to some free memory.\r\n            let freeMemoryPointer := mload(0x40)\r\n\r\n            // Write the abi-encoded calldata to memory piece by piece:\r\n            mstore(freeMemoryPointer, 0x095ea7b300000000000000000000000000000000000000000000000000000000) // Begin with the function selector.\r\n            mstore(add(freeMemoryPointer, 4), and(to, 0xffffffffffffffffffffffffffffffffffffffff)) // Mask and append the \"to\" argument.\r\n            mstore(add(freeMemoryPointer, 36), amount) // Finally append the \"amount\" argument. No mask as it's a full 32 byte value.\r\n\r\n            // Call the token and store if it succeeded or not.\r\n            // We use 68 because the calldata length is 4 + 32 * 2.\r\n            callStatus := call(gas(), token, 0, freeMemoryPointer, 68, 0, 0)\r\n        }\r\n\r\n        require(didLastOptionalReturnCallSucceed(callStatus), \"APPROVE_FAILED\");\r\n    }\r\n\r\n    /*///////////////////////////////////////////////////////////////\r\n                         INTERNAL HELPER LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function didLastOptionalReturnCallSucceed(bool callStatus) private pure returns (bool success) {\r\n        assembly {\r\n            // Get how many bytes the call returned.\r\n            let returnDataSize := returndatasize()\r\n\r\n            // If the call reverted:\r\n            if iszero(callStatus) {\r\n                // Copy the revert message into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Revert with the same message.\r\n                revert(0, returnDataSize)\r\n            }\r\n\r\n            switch returnDataSize\r\n            case 32 {\r\n                // Copy the return data into memory.\r\n                returndatacopy(0, 0, returnDataSize)\r\n\r\n                // Set success to whether it returned true.\r\n                success := iszero(iszero(mload(0)))\r\n            }\r\n            case 0 {\r\n                // There was no return data.\r\n                success := 1\r\n            }\r\n            default {\r\n                // It returned some malformed input.\r\n                success := 0\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Ownable.sol\r\n\r\n\r\npragma solidity 0.8.10;\r\n\r\nerror NotOwner();\r\n\r\nabstract contract Ownable {\r\n  address internal _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  constructor() {\r\n    _owner = msg.sender;\r\n  }\r\n\r\n  function owner() external view returns (address) {\r\n    return _owner;\r\n  }\r\n\r\n  function transferOwnership(address _newOwner) external {\r\n    if (msg.sender != _owner) revert NotOwner();\r\n\r\n    _owner = _newOwner;\r\n  }\r\n\r\n  function renounceOwnership() public {\r\n    if (msg.sender != _owner) revert NotOwner();\r\n\r\n    _owner = address(0);\r\n  }\r\n}\r\n\r\n\r\n// File contracts/IERC721.sol\r\n\r\n\r\n\r\npragma solidity 0.8.10;\r\n\r\n/**\r\n * @dev Required interface of an ERC721 compliant contract.\r\n */\r\ninterface IERC721 {\r\n  /**\r\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\r\n   */\r\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n  /**\r\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\r\n   */\r\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n  /**\r\n   * @dev Returns the number of tokens in ``owner``'s account.\r\n   */\r\n  function balanceOf(address owner) external view returns (uint256 balance);\r\n\r\n  /**\r\n   * @dev Returns the owner of the `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function ownerOf(uint256 tokenId) external view returns (address owner);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\r\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\r\n   * The approval is cleared when the token is transferred.\r\n   *\r\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The caller must own the token or be an approved operator.\r\n   * - `tokenId` must exist.\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address to, uint256 tokenId) external;\r\n\r\n  /**\r\n   * @dev Returns the account approved for `tokenId` token.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `tokenId` must exist.\r\n   */\r\n  function getApproved(uint256 tokenId) external view returns (address operator);\r\n\r\n  /**\r\n   * @dev Approve or remove `operator` as an operator for the caller.\r\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - The `operator` cannot be the caller.\r\n   *\r\n   * Emits an {ApprovalForAll} event.\r\n   */\r\n  function setApprovalForAll(address operator, bool _approved) external;\r\n\r\n  /**\r\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\r\n   *\r\n   * See {setApprovalForAll}\r\n   */\r\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\r\n\r\n  /**\r\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\r\n   *\r\n   * Requirements:\r\n   *\r\n   * - `from` cannot be the zero address.\r\n   * - `to` cannot be the zero address.\r\n   * - `tokenId` token must exist and be owned by `from`.\r\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\r\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function safeTransferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 tokenId,\r\n    bytes calldata data\r\n  ) external;\r\n\r\n  // Original 0xApes contract specifc\r\n  function getPhunksBelongingToOwner(address _owner) external view returns (uint256[] memory);\r\n}\r\n\r\n\r\n// File contracts/Strings.sol\r\n\r\n\r\npragma solidity 0.8.10;\r\n\r\nlibrary Strings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n            value /= 10;\r\n        }\r\n        return string(buffer);\r\n    }\r\n}\r\n\r\n\r\n// File contracts/Ape721.sol\r\n\r\n\r\npragma solidity 0.8.10;\r\nerror DoesNotExist();\r\nerror NoTokensLeft();\r\nerror NotEnoughETH();\r\nerror AssertionError();\r\nerror NotTokenOwner();\r\nerror MintNotActive();\r\nerror MintAlreadyActive();\r\nerror MintLimitPerTx();\r\n\r\ncontract xApe721 is Ownable, ERC721 {\r\n  using Strings for uint256;\r\n\r\n  uint256 public constant TOTAL_SUPPLY = 10_000;\r\n  uint256 public constant PRICE_PER_MINT = 0.05 ether;\r\n  uint256 public constant MAX_MINT_PER_TX = 20;\r\n\r\n  bool public mintActive;\r\n\r\n  uint256 public totalSupply;\r\n  uint256 internal nextMintableId = 10038; // IDs start at 10038\r\n\r\n  string public baseURI;\r\n\r\n  IERC721 public oldContract = IERC721(0x090b1DE324fEA5f0A0B4226101Db645819102629);\r\n  address private teamWallet = 0x26CDE90abDD4e41ECA2948d79fE383E8103678b5;\r\n\r\n  constructor(\r\n    string memory name,\r\n    string memory symbol,\r\n    string memory _baseURI,\r\n    address _oldContract,\r\n    address[] memory recipients,\r\n    uint256[] memory tokens\r\n  ) payable ERC721(name, symbol) {\r\n    require(recipients.length == tokens.length, \"Airdrop lengths\");\r\n    baseURI = _baseURI;\r\n\r\n    if (_oldContract != address(0)) {\r\n      oldContract = IERC721(_oldContract);\r\n    }\r\n\r\n    uint256 length = tokens.length;\r\n\r\n    for (uint i; i < length; ++i) {\r\n      _mint(recipients[i], tokens[i]);\r\n      totalSupply++;\r\n    }\r\n  }\r\n\r\n  modifier onlyTeamWallet() {\r\n    require(msg.sender == teamWallet, \"Not callable except by team wallet\");\r\n    _;\r\n  }\r\n\r\n  function mint(uint16 amount) external payable {\r\n    if (!mintActive) revert MintNotActive();\r\n    if (totalSupply + amount >= TOTAL_SUPPLY) revert NoTokensLeft();\r\n    if (msg.value < amount * PRICE_PER_MINT) revert NotEnoughETH();\r\n    if (amount > MAX_MINT_PER_TX) revert MintLimitPerTx();\r\n\r\n    uint256 supply = totalSupply;\r\n\r\n    unchecked {\r\n      for (uint16 index = 0; index < amount; index++) {\r\n        uint256 newId = _getNextUnusedID();\r\n        _mint(msg.sender, newId);\r\n        supply++;\r\n      }\r\n    }\r\n\r\n    totalSupply = supply;\r\n  }\r\n\r\n  function claim(uint256 tokenId) external payable {\r\n    if (_ownsOldToken(msg.sender, tokenId))  {\r\n      // Transfering into this contract effectively burns the old\r\n      // token as there is no way to get it out of here\r\n      oldContract.safeTransferFrom(msg.sender, address(this), tokenId);\r\n      _mint(msg.sender, tokenId);\r\n      totalSupply++;\r\n      return;\r\n    }\r\n    revert NotTokenOwner();\r\n  }\r\n\r\n  function claimAll() external payable {\r\n    uint256[] memory ownedTokens = oldContract.getPhunksBelongingToOwner(msg.sender);\r\n    uint256 length = ownedTokens.length; // gas saving\r\n\r\n    uint256 supply = totalSupply;\r\n\r\n    for (uint256 i; i < length; ++i) {\r\n      if (ownerOf[ownedTokens[i]] == address(0)) {\r\n        // Has not been claimed yet\r\n\r\n        // Transfering into this contract effectively burns the\r\n        // old token as there is no way to get it out of here\r\n        oldContract.safeTransferFrom(msg.sender, address(this), ownedTokens[i]);\r\n        _mint(msg.sender, ownedTokens[i]);\r\n        supply++;\r\n      }\r\n    }\r\n\r\n    totalSupply = supply;\r\n  }\r\n\r\n  function _ownsOldToken(address account, uint256 tokenId) internal view returns(bool) {\r\n    try oldContract.ownerOf(tokenId) returns (address tokenOwner) {\r\n      return account == tokenOwner;\r\n    } catch Error(string memory /*reason*/) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  function _getNextUnusedID() internal returns (uint256) {\r\n    uint256 newId = nextMintableId;\r\n\r\n    // Using 10 iterations instead of while loop as it is known\r\n    // that the maximum contiguous group of successive IDs in\r\n    // the original contract is 7 (14960-14966). Cannot have unbounded gas usage\r\n    for (uint256 i; i < 10; ++i) {\r\n      if (ownerOf[newId] != address(0)) {\r\n        // Token is owned in this contract\r\n        newId++;\r\n        continue;\r\n      }\r\n\r\n      try oldContract.ownerOf(newId) returns (address) {\r\n        // Token is owned in the old contract\r\n        // ownerOf always reverts if the token isn't owned\r\n        // so no need for zero check here\r\n        newId++;\r\n        continue;\r\n      } catch Error(string memory /*reason*/) {\r\n        nextMintableId = newId + 1;\r\n        return newId;\r\n      }\r\n    }\r\n    revert AssertionError();\r\n  }\r\n\r\n  function tokenURI(uint256 id) public view override returns (string memory) {\r\n    if (ownerOf[id] == address(0)) revert DoesNotExist();\r\n\r\n    return string(abi.encodePacked(baseURI, id.toString()));\r\n  }\r\n\r\n  function withdraw() external onlyTeamWallet() {\r\n    SafeTransferLib.safeTransferETH(teamWallet, address(this).balance);\r\n  }\r\n\r\n  function pauseMint() external {\r\n    if (msg.sender != _owner) revert NotOwner();\r\n    if (!mintActive) revert MintNotActive();\r\n\r\n    mintActive = false;\r\n  }\r\n\r\n  function startMint() external {\r\n    if (msg.sender != _owner) revert NotOwner();\r\n    if (mintActive) revert MintAlreadyActive();\r\n\r\n    mintActive = true;\r\n  }\r\n\r\n  function setBaseURI(string memory _baseURI) external {\r\n    if (msg.sender != _owner) revert NotOwner();\r\n      baseURI = _baseURI;\r\n  }\r\n\r\n  function supportsInterface(bytes4 interfaceId)\r\n    public\r\n    pure\r\n    override\r\n    returns (bool)\r\n  {\r\n    return\r\n      interfaceId == 0x7f5828d0 || // ERC165 Interface ID for ERC173\r\n      interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\r\n      interfaceId == 0x5b5e139f || // ERC165 Interface ID for ERC165\r\n      interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC721Metadata\r\n      interfaceId == 0x150b7a02;   // ERC721 Receiver\r\n  }\r\n\r\n  function onERC721Received(\r\n      address operator,\r\n      address from,\r\n      uint256 tokenId,\r\n      bytes calldata data\r\n  ) external returns (bytes4) {\r\n      return 0x150b7a02;\r\n  }\r\n}", "ABI": "[{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"_oldContract\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"recipients\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AssertionError\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"DoesNotExist\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintAlreadyActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintLimitPerTx\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MintNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoTokensLeft\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotEnoughETH\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotTokenOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"MAX_MINT_PER_TX\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_PER_MINT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"TOTAL_SUPPLY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"baseURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimAll\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"amount\",\"type\":\"uint16\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oldContract\",\"outputs\":[{\"internalType\":\"contract IERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pauseMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"_baseURI\",\"type\":\"string\"}],\"name\":\"setBaseURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"startMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "xApe721", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000140000000000000000000000000090b1de324fea5f0a0b4226101db64581910262900000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000006307841706573000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000053078417065000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005168747470733a2f2f676174657761792e70696e6174612e636c6f75642f697066732f516d563972467973324c6b7339706961525348696a637545717465625a596854384c416462327a5a5a4c347832432f0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000031000000000000000000000000a502803bf1e9d2bc05b0afe9c7bdcaaa56a6246e000000000000000000000000c6c6fdfe7f5a6c89178b28b9e700f3ee26be478b000000000000000000000000c6c6fdfe7f5a6c89178b28b9e700f3ee26be478b0000000000000000000000009ff88381453bbfdce1ac32df3218dcb57031033b000000000000000000000000890861d1a967e519668cc8f8dd4f4ca8c430ea60000000000000000000000000890861d1a967e519668cc8f8dd4f4ca8c430ea60000000000000000000000000890861d1a967e519668cc8f8dd4f4ca8c430ea6000000000000000000000000043d3086f1f329227dae2341a0daf19132578c8670000000000000000000000007124db5cc3e23f7d6ba95c58df56596e3917f2d8000000000000000000000000ef2aa50b46d5f78a80fc96385275a8dfd82ead8c000000000000000000000000ef2aa50b46d5f78a80fc96385275a8dfd82ead8c000000000000000000000000ef2aa50b46d5f78a80fc96385275a8dfd82ead8c000000000000000000000000ef2aa50b46d5f78a80fc96385275a8dfd82ead8c000000000000000000000000ef2aa50b46d5f78a80fc96385275a8dfd82ead8c000000000000000000000000ac02744d1796717ab6e93264becf7086530376db0000000000000000000000009408819a662845b13dc3ab848c7450ab874e1a870000000000000000000000009408819a662845b13dc3ab848c7450ab874e1a870000000000000000000000009408819a662845b13dc3ab848c7450ab874e1a8700000000000000000000000084dc717cc359ac9cda863e5a68dc3aaf156abf90000000000000000000000000fdf3df1c1bbe75e33c33b3335a305ff7233479fa0000000000000000000000007ccebfaf53dc478794372785a854bb762a037f7f00000000000000000000000087c0700498758a6b884dd5f270b21161953395320000000000000000000000003673904cf718d7dd4d1f1799a0d22f3fcaf3b3d60000000000000000000000003673904cf718d7dd4d1f1799a0d22f3fcaf3b3d6000000000000000000000000b0903ae41ee0be365929a0258daa5f13ce9dd5310000000000000000000000000c4618ffbe21f926d040043976457d0a489ea3600000000000000000000000000c4618ffbe21f926d040043976457d0a489ea3600000000000000000000000000c4618ffbe21f926d040043976457d0a489ea360000000000000000000000000c2a79ddaf7e95c141c20aa1b10f3411540562ff70000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e50000000000000000000000001e01e4f8c0591a6940a0ef80c9de6a6a94d067e500000000000000000000000000000000000000000000000000000000000000310000000000000000000000000000000000000000000000000000000000004539000000000000000000000000000000000000000000000000000000000000481700000000000000000000000000000000000000000000000000000000000028f60000000000000000000000000000000000000000000000000000000000002bb6000000000000000000000000000000000000000000000000000000000000486f0000000000000000000000000000000000000000000000000000000000003e580000000000000000000000000000000000000000000000000000000000002dcb000000000000000000000000000000000000000000000000000000000000375c0000000000000000000000000000000000000000000000000000000000002e760000000000000000000000000000000000000000000000000000000000004b4e000000000000000000000000000000000000000000000000000000000000332300000000000000000000000000000000000000000000000000000000000041d7000000000000000000000000000000000000000000000000000000000000324f000000000000000000000000000000000000000000000000000000000000389a00000000000000000000000000000000000000000000000000000000000027b30000000000000000000000000000000000000000000000000000000000002d3a0000000000000000000000000000000000000000000000000000000000004d9e0000000000000000000000000000000000000000000000000000000000002712000000000000000000000000000000000000000000000000000000000000365500000000000000000000000000000000000000000000000000000000000028f10000000000000000000000000000000000000000000000000000000000002734000000000000000000000000000000000000000000000000000000000000393f00000000000000000000000000000000000000000000000000000000000027330000000000000000000000000000000000000000000000000000000000004a700000000000000000000000000000000000000000000000000000000000002731000000000000000000000000000000000000000000000000000000000000272c000000000000000000000000000000000000000000000000000000000000272e0000000000000000000000000000000000000000000000000000000000002730000000000000000000000000000000000000000000000000000000000000271000000000000000000000000000000000000000000000000000000000000027140000000000000000000000000000000000000000000000000000000000002715000000000000000000000000000000000000000000000000000000000000271600000000000000000000000000000000000000000000000000000000000027170000000000000000000000000000000000000000000000000000000000002719000000000000000000000000000000000000000000000000000000000000271a000000000000000000000000000000000000000000000000000000000000271b000000000000000000000000000000000000000000000000000000000000271c000000000000000000000000000000000000000000000000000000000000271d000000000000000000000000000000000000000000000000000000000000271e000000000000000000000000000000000000000000000000000000000000271f0000000000000000000000000000000000000000000000000000000000002720000000000000000000000000000000000000000000000000000000000000272400000000000000000000000000000000000000000000000000000000000027250000000000000000000000000000000000000000000000000000000000002726000000000000000000000000000000000000000000000000000000000000272700000000000000000000000000000000000000000000000000000000000027280000000000000000000000000000000000000000000000000000000000002729000000000000000000000000000000000000000000000000000000000000272a000000000000000000000000000000000000000000000000000000000000272b", "EVMVersion": "Default", "Library": "", "LicenseType": "Unknown", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://b03eae39a07df02cf0d2d9d94a3da5806276115115c5ab50b593c818923589e9"}