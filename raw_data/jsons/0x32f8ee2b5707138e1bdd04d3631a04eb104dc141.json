{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"src/AlphaDogs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\nimport {Ownable} from \\\"@openzeppelin/access/Ownable.sol\\\";\\nimport {Strings} from \\\"@openzeppelin/utils/Strings.sol\\\";\\nimport {MerkleProof} from \\\"@openzeppelin/utils/cryptography/MerkleProof.sol\\\";\\nimport {ReentrancyGuard} from \\\"@solmate/utils/ReentrancyGuard.sol\\\";\\n\\nimport {IAlphaToken} from \\\"$/interfaces/IAlphaToken.sol\\\";\\nimport {IAlphaDogs} from \\\"$/interfaces/IAlphaDogs.sol\\\";\\nimport {IAlphaDogsAttributes} from \\\"$/interfaces/IAlphaDogsAttributes.sol\\\";\\n\\nimport {Genetics} from \\\"$/libraries/Genetics.sol\\\";\\nimport {Gene} from \\\"$/libraries/Gene.sol\\\";\\nimport {ERC721} from \\\"$/ERC721.sol\\\";\\n\\n/// @title  AlphaDogs\\n/// @author Aleph Retamal <github.com/alephao>, Gustavo Tiago <github.com/gutiago>\\ncontract AlphaDogs is IAlphaDogs, ERC721, Ownable, ReentrancyGuard {\\n    using Gene for uint256;\\n    using Strings for uint160;\\n    // ========================================\\n    // Immutable\\n    // ========================================\\n\\n    address private constant BLACKHOLE = address(0);\\n\\n    /// @notice amount of $ALPHA a staked genesis dog earn per day\\n    uint256 public constant GENESIS_TOKEN_PER_DAY = 10 ether;\\n\\n    /// @notice amount of $ALPHA a staked puppy dog earn per day\\n    uint256 public constant PUPPY_TOKEN_PER_DAY = 2.5 ether;\\n\\n    /// @notice price in $ALPHA to breed\\n    uint256 public constant BREEDING_PRICE = 600 ether;\\n\\n    /// @notice price in $ALPHA to update name or lore of a dog\\n    uint256 public constant UPDATE_PRICE = 100 ether;\\n\\n    /// @notice max amount of genesis tokens\\n    uint32 public immutable maxGenesis;\\n\\n    /// @notice max amount of puppy tokens\\n    uint32 public immutable maxPuppies;\\n\\n    /// @notice address of the $ALPHA ERC20\\n    IAlphaToken public immutable alphaToken;\\n\\n    /// @notice merkle tree root for allow-list\\n    bytes32 public immutable merkleRoot;\\n\\n    /// @notice number of reserved genesis tokens for wallets in the allow-list\\n    uint32 public immutable maxReserved;\\n\\n    // ========================================\\n    // Mutable\\n    // ========================================\\n\\n    /// @notice if the mint function is open\\n    bool public isSaleActive = false;\\n\\n    /// @notice if supply should be reserved for allow-list\\n    bool public isSupplyReserved = true;\\n\\n    /// @notice amount of genesis minted so far not via allow-list\\n    uint32 public genesisNonReservedSupply = 0;\\n\\n    /// @notice amount of genesis minted so far via allow-list\\n    uint32 public genesisReservedSupply = 0;\\n\\n    /// @notice amount of puppied minted so far\\n    uint32 public puppySupply = 0;\\n\\n    /// @notice map from dog id to custom Name and Lore\\n    mapping(uint256 => CustomMetadata) internal metadata;\\n\\n    /// @notice map from dog id to its staked state\\n    mapping(uint256 => Stake) public getStake;\\n\\n    /// @notice check if an address already minted\\n    mapping(address => bool) public didMint;\\n\\n    /// @notice address of the AlphaDogsAttributes contract\\n    IAlphaDogsAttributes public attributes;\\n\\n    // ========================================\\n    // Constructor\\n    // ========================================\\n\\n    constructor(\\n        uint32 _maxGenesis,\\n        uint32 _maxPuppies,\\n        uint32 _maxReserved,\\n        IAlphaToken _alphaToken,\\n        IAlphaDogsAttributes _attributes,\\n        bytes32 _merkleRoot\\n    ) ERC721(\\\"AlphaDogs\\\", \\\"AD\\\") {\\n        maxGenesis = _maxGenesis;\\n        maxPuppies = _maxPuppies;\\n        maxReserved = _maxReserved;\\n        alphaToken = _alphaToken;\\n        attributes = _attributes;\\n        merkleRoot = _merkleRoot;\\n    }\\n\\n    // ========================================\\n    // Modifiers\\n    // ========================================\\n\\n    modifier dogzOwner(uint256 id) {\\n        if (ownerOf[id] != msg.sender) revert InvalidTokenOwner();\\n        _;\\n    }\\n\\n    modifier whenSaleIsActive() {\\n        if (!isSaleActive) revert NotActive();\\n        _;\\n    }\\n\\n    // \\\" and \\\\ are not valid\\n    modifier isValidString(string calldata value) {\\n        bytes memory str = bytes(value);\\n\\n        for (uint256 i; i < str.length; i++) {\\n            bytes1 char = str[i];\\n            if ((char == 0x22) || (char == 0x5c)) revert InvalidChar();\\n        }\\n        _;\\n    }\\n\\n    // ========================================\\n    // Owner only\\n    // ========================================\\n\\n    function setIsSaleActive(bool _isSaleActive) external onlyOwner {\\n        if (isSaleActive == _isSaleActive) revert NotChanged();\\n        isSaleActive = _isSaleActive;\\n    }\\n\\n    function setIsSupplyReserved(bool _isSupplyReserved) external onlyOwner {\\n        if (isSupplyReserved == _isSupplyReserved) revert NotChanged();\\n        isSupplyReserved = _isSupplyReserved;\\n    }\\n\\n    // ========================================\\n    // Change NFT Data\\n    // ========================================\\n\\n    function setName(uint256 id, string calldata newName)\\n        external\\n        override\\n        dogzOwner(id)\\n        isValidString(newName)\\n    {\\n        bytes memory n = bytes(newName);\\n\\n        if (n.length > 25) revert InvalidNameLength();\\n        if (keccak256(n) == keccak256(bytes(metadata[id].name)))\\n            revert InvalidSameValue();\\n\\n        metadata[id].name = newName;\\n        alphaToken.burn(msg.sender, UPDATE_PRICE);\\n        emit NameChanged(id, newName);\\n    }\\n\\n    function setLore(uint256 id, string calldata newLore)\\n        external\\n        override\\n        dogzOwner(id)\\n        isValidString(newLore)\\n    {\\n        bytes memory n = bytes(newLore);\\n\\n        if (keccak256(n) == keccak256(bytes(metadata[id].lore)))\\n            revert InvalidSameValue();\\n\\n        metadata[id].lore = newLore;\\n        alphaToken.burn(msg.sender, UPDATE_PRICE);\\n        emit LoreChanged(id, newLore);\\n    }\\n\\n    // ========================================\\n    // Breeding\\n    // ========================================\\n\\n    function breed(uint256 mom, uint256 dad)\\n        external\\n        override\\n        dogzOwner(mom)\\n        dogzOwner(dad)\\n    {\\n        if (genesisLeft() != 0) revert NotActive();\\n\\n        uint256 mintIndex = puppySupply;\\n        if (mintIndex == maxPuppies) revert InsufficientTokensAvailable();\\n        if (Gene.isPuppy(mom) || Gene.isPuppy(dad))\\n            revert FusionWithPuppyForbidden();\\n        if (mom == dad) revert FusionWithSameParentsForbidden();\\n\\n        unchecked {\\n            puppySupply++;\\n        }\\n\\n        uint256 puppyId = _generatePuppyTokenIdWithNoCollision(\\n            mom,\\n            dad,\\n            random(mintIndex)\\n        );\\n        alphaToken.burn(msg.sender, BREEDING_PRICE);\\n        //slither-disable-next-line reentrancy-no-eth\\n        _mint(msg.sender, puppyId);\\n\\n        emit Breeded(puppyId, mom, dad);\\n    }\\n\\n    function _generatePuppyTokenIdWithNoCollision(\\n        uint256 mom,\\n        uint256 dad,\\n        uint256 seed\\n    ) internal view returns (uint256 tokenId) {\\n        tokenId = Genetics.uniformCrossOver(mom, dad, seed);\\n        uint256 i = 3;\\n        while (ownerOf[tokenId] != BLACKHOLE) {\\n            tokenId = Genetics.incrementByte(tokenId, i);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    // ========================================\\n    // Stake / Unstake\\n    // ========================================\\n\\n    function stake(uint256[] calldata tokenIds) external override {\\n        if (tokenIds.length == 0) revert InvalidInput();\\n        if (msg.sender == address(0)) revert InvalidSender();\\n\\n        uint256 tokenId;\\n        for (uint256 i = 0; i < tokenIds.length; ) {\\n            tokenId = tokenIds[i];\\n            // No need to check ownership since transferFrom already checks that\\n            // and the caller of this function should be the token Owner\\n            getStake[tokenId] = Stake(msg.sender, uint96(block.timestamp));\\n            _transfer(msg.sender, address(this), tokenId);\\n            emit Staked(tokenId);\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n    }\\n\\n    function unstake(uint256[] calldata tokenIds) external override {\\n        _claim(tokenIds, true);\\n    }\\n\\n    function claim(uint256[] calldata tokenIds) external override {\\n        _claim(tokenIds, false);\\n    }\\n\\n    function _claim(uint256[] calldata tokenIds, bool shouldUnstake) internal {\\n        if (tokenIds.length == 0) revert InvalidInput();\\n        if (msg.sender == address(0)) revert InvalidSender();\\n\\n        // total rewards amount to claim\\n        uint256 totalRewards;\\n\\n        // loop variables\\n\\n        // rewards for current genzee in the loop below\\n        uint256 rewards;\\n\\n        // current genzeeid in the loop below\\n        uint256 tokenId;\\n\\n        // staking information for the current genzee in the loop below\\n        Stake memory stakeInfo;\\n\\n        for (uint256 i = 0; i < tokenIds.length; ) {\\n            tokenId = tokenIds[i];\\n            stakeInfo = getStake[tokenId];\\n\\n            if (stakeInfo.owner != msg.sender) revert InvalidTokenOwner();\\n\\n            uint256 tokensPerDay = tokenId.isPuppy()\\n                ? PUPPY_TOKEN_PER_DAY\\n                : GENESIS_TOKEN_PER_DAY;\\n\\n            rewards = stakeInfo.stakedAt > 1\\n                ? ((tokensPerDay * (block.timestamp - stakeInfo.stakedAt)) /\\n                    1 days)\\n                : 0;\\n            totalRewards += rewards;\\n\\n            if (shouldUnstake) {\\n                getStake[tokenId] = Stake(BLACKHOLE, 1);\\n                _transfer(address(this), msg.sender, tokenId);\\n                emit Unstaked(tokenId, rewards);\\n            } else {\\n                //slither-disable-next-line incorrect-equality\\n                if (rewards == 0) revert InvalidAmountToClaim();\\n                getStake[tokenId].stakedAt = uint96(block.timestamp);\\n                emit ClaimedTokens(tokenId, rewards);\\n            }\\n\\n            unchecked {\\n                ++i;\\n            }\\n        }\\n\\n        //slither-disable-next-line incorrect-equality\\n        if (totalRewards == 0) return;\\n        alphaToken.mint(msg.sender, totalRewards);\\n    }\\n\\n    // ========================================\\n    // Mint\\n    // ========================================\\n\\n    function _generateTokenIdWithNoCollision(uint256 seed)\\n        internal\\n        view\\n        returns (uint256 tokenId)\\n    {\\n        tokenId = Genetics.generateGenes(seed);\\n        uint256 i = 3;\\n        while (ownerOf[tokenId] != BLACKHOLE) {\\n            tokenId = Genetics.incrementByte(tokenId, i);\\n            unchecked {\\n                i++;\\n            }\\n        }\\n    }\\n\\n    function premint(bytes32[] calldata proof) external whenSaleIsActive {\\n        uint256 reservedSupply = genesisReservedSupply;\\n\\n        if (didMint[msg.sender]) revert TokenLimitReached();\\n        if (reservedSupply + 2 > maxReserved)\\n            revert InsufficientReservedTokensAvailable();\\n        if (reservedSupply + genesisNonReservedSupply + 2 > maxGenesis)\\n            revert InsufficientTokensAvailable();\\n\\n        bytes32 leaf = keccak256(\\n            abi.encodePacked(uint160(msg.sender).toHexString(20))\\n        );\\n        bool isProofValid = MerkleProof.verify(proof, merkleRoot, leaf);\\n        if (!isProofValid) revert InvalidMerkleProof();\\n\\n        didMint[msg.sender] = true;\\n\\n        unchecked {\\n            uint256 mintIndex = genesisSupply();\\n            genesisReservedSupply += 2;\\n            _safeMint(\\n                msg.sender,\\n                _generateTokenIdWithNoCollision(random(mintIndex + 1))\\n            );\\n            _safeMint(\\n                msg.sender,\\n                _generateTokenIdWithNoCollision(random(mintIndex + 2))\\n            );\\n        }\\n    }\\n\\n    function mint() external whenSaleIsActive {\\n        // Can only mint once per address\\n        if (didMint[msg.sender]) {\\n            revert TokenLimitReached();\\n        }\\n\\n        uint256 reservedSupply = genesisReservedSupply;\\n        uint256 nonReservedSupply = genesisNonReservedSupply;\\n\\n        if (reservedSupply + nonReservedSupply + 2 > maxGenesis)\\n            revert InsufficientTokensAvailable();\\n\\n        // When minting, if isSupplyReserved is on, public minters won't be able\\n        // to mint the amount reserved for allow-listed wallets\\n        if (\\n            isSupplyReserved && nonReservedSupply + 2 > maxGenesis - maxReserved\\n        ) {\\n            revert InsufficientNonReservedTokensAvailable();\\n        }\\n\\n        didMint[msg.sender] = true;\\n\\n        unchecked {\\n            uint256 mintIndex = genesisSupply();\\n            genesisNonReservedSupply += 2;\\n            _safeMint(\\n                msg.sender,\\n                _generateTokenIdWithNoCollision(random(mintIndex + 1))\\n            );\\n            _safeMint(\\n                msg.sender,\\n                _generateTokenIdWithNoCollision(random(mintIndex + 2))\\n            );\\n        }\\n    }\\n\\n    function random(uint256 nonce) internal view returns (uint256) {\\n        return\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        tx.origin, // solhint-disable-line avoid-tx-origin\\n                        tx.gasprice,\\n                        nonce,\\n                        block.number,\\n                        block.timestamp\\n                    )\\n                )\\n            );\\n    }\\n\\n    // ========================================\\n    // View\\n    // ========================================\\n\\n    function genesisSupply() public view returns (uint32) {\\n        unchecked {\\n            return genesisReservedSupply + genesisNonReservedSupply;\\n        }\\n    }\\n\\n    /// @notice amount of tokens left to be minted\\n    function genesisLeft() public view returns (uint32) {\\n        unchecked {\\n            return maxGenesis - genesisSupply();\\n        }\\n    }\\n\\n    /// @notice amount do puppies left to be created\\n    function puppyTokensLeft() external view returns (uint32) {\\n        unchecked {\\n            return maxPuppies - puppySupply;\\n        }\\n    }\\n\\n    /// @notice total supply of nfts\\n    function totalSupply() external view returns (uint32) {\\n        unchecked {\\n            return genesisSupply() + puppySupply;\\n        }\\n    }\\n\\n    function getMetadata(uint256 id)\\n        external\\n        view\\n        override\\n        returns (CustomMetadata memory)\\n    {\\n        return metadata[id];\\n    }\\n\\n    // ========================================\\n    // Overrides\\n    // ========================================\\n\\n    function tokenURI(uint256 id)\\n        public\\n        view\\n        override(ERC721)\\n        returns (string memory)\\n    {\\n        if (ownerOf[id] == BLACKHOLE) revert InvalidTokenID();\\n        CustomMetadata memory md = metadata[id];\\n        return attributes.tokenURI(id, bytes(md.name), md.lore);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/cryptography/MerkleProof.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = _efficientHash(computedHash, proofElement);\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = _efficientHash(proofElement, computedHash);\\n            }\\n        }\\n        return computedHash;\\n    }\\n\\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\\n        assembly {\\n            mstore(0x00, a)\\n            mstore(0x20, b)\\n            value := keccak256(0x00, 0x40)\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"lib/solmate/src/utils/ReentrancyGuard.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.0;\\n\\n/// @notice Gas optimized reentrancy protection for smart contracts.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/ReentrancyGuard.sol)\\n/// @author Modified from OpenZeppelin (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/security/ReentrancyGuard.sol)\\nabstract contract ReentrancyGuard {\\n    uint256 private locked = 1;\\n\\n    modifier nonReentrant() {\\n        require(locked == 1, \\\"REENTRANCY\\\");\\n\\n        locked = 2;\\n\\n        _;\\n\\n        locked = 1;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAlphaToken.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\ninterface IAlphaToken {\\n    /// @dev 0x36a1c33f\\n    error NotChanged();\\n    /// @dev 0x3d693ada\\n    error NotAllowed();\\n\\n    function mint(address addr, uint256 amount) external;\\n\\n    function burn(address from, uint256 amount) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAlphaDogs.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\nimport {IAlphaDogsEvents} from \\\"./IAlphaDogsEvents.sol\\\";\\nimport {IAlphaDogsErrors} from \\\"./IAlphaDogsErrors.sol\\\";\\n\\ninterface IAlphaDogs is IAlphaDogsEvents, IAlphaDogsErrors {\\n    struct CustomMetadata {\\n        string name;\\n        string lore;\\n    }\\n\\n    struct Stake {\\n        address owner;\\n        uint96 stakedAt;\\n    }\\n\\n    // mapping(uint256 => CustomMetadata) getMetadata;\\n    function getMetadata(uint256 id)\\n        external\\n        view\\n        returns (CustomMetadata memory);\\n\\n    function setName(uint256 id, string calldata newName) external;\\n\\n    function setLore(uint256 id, string calldata newLore) external;\\n\\n    function stake(uint256[] calldata tokenIds) external;\\n\\n    function unstake(uint256[] calldata tokenIds) external;\\n\\n    function claim(uint256[] calldata tokenIds) external;\\n\\n    function premint(bytes32[] calldata proof) external;\\n\\n    function mint() external;\\n\\n    function breed(uint256 mom, uint256 dad) external;\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAlphaDogsAttributes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\ninterface IAlphaDogsAttributes {\\n    function tokenURI(\\n        uint256 id,\\n        bytes memory name,\\n        string memory lore\\n    ) external view returns (string memory);\\n}\\n\"\r\n    },\r\n    \"src/libraries/Genetics.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\nimport {Chromossomes} from \\\"./Chromossomes.sol\\\";\\n\\n/// @title  AlphaDogs Genetics Library\\n/// @author Aleph Retamal <github.com/alephao>, Gustavo Tiago <github.com/gutiago>\\n/// @notice Library containing functions for creating and manipulating genes.\\n///\\n/// ### Creating a new gene\\n///\\n/// \u2022 When creating a new gene, we get a pseudo-random seed derive other seeds for each trait\\n/// \u2022 We're using A.J. Walker Alias Algorithm to pick traits with pre-defined rarity table\\n///   these are the weird hard-coded arrays in the `seedTo{Trait}` functions\\n/// \u2022 Note: we use a pseudo-random seed, meaning that the result can be somewhat manipulated\\n///   by mad-scientists of the chain.\\n///\\n/// ### Breeding\\n///\\n/// \u2022 For breeding we use uniform cross-over algorithm which is commonly used\\n///   in genetic algorithms. We walk throught each chromossome, picking from either mom or dad.\\nlibrary Genetics {\\n    /// @dev    Generate genes from a seed\\n    ///\\n    ///         \u2022 Start with                  0x0\\n    ///         \u2022 Add background chromossome  0x77 = 0x0 + 0x77\\n    ///         \u2022 Shift 1 byte to the left    0x7700 = 0x77 << 8\\n    ///         \u2022 Add fur chromossome         0x7766 = 0x7700 + 0x66\\n    ///         \u2022 Same for each chromossome\\n    function generateGenes(uint256 seed) internal pure returns (uint256 genes) {\\n        genes |= Chromossomes.seedToBackground(seed);\\n        genes <<= 8;\\n\\n        genes |= Chromossomes.seedToFur(seed);\\n        genes <<= 8;\\n\\n        genes |= Chromossomes.seedToNeck(seed);\\n        genes <<= 8;\\n\\n        genes |= Chromossomes.seedToEyes(seed);\\n        genes <<= 8;\\n\\n        genes |= Chromossomes.seedToHat(seed);\\n        genes <<= 8;\\n\\n        genes |= Chromossomes.seedToMouth(seed);\\n        genes <<= 8;\\n\\n        genes |= Chromossomes.seedToNosering(seed);\\n    }\\n\\n    /// @dev Increments the gene i in n (big endian/from right to left)\\n    ///\\n    /// ### Examples\\n    ///\\n    /// \u2022 incrementByte(0x110000, 0) = 0x110001\\n    /// \u2022 incrementByte(0x110000, 1) = 0x110100\\n    /// \u2022 incrementByte(0x110000, 2) = 0x120000\\n    ///\\n    /// ### A more readable version of the code\\n    ///\\n    /// unchecked {\\n    ///   uint256 shift = (i % 7) * 8;\\n    ///   uint256 mask = 0xFF << shift;\\n    ///   uint256 trait = gene & mask;\\n    ///   uint256 traitRaw = trait >> shift;\\n    ///   uint256 newTrait = (traitRaw + 1) % [4, 28, 11, 70, 36, 10, 21][i];\\n    ///   uint256 tokenIdWithoutOldTrait = ~mask & gene;\\n    ///   uint256 newGene = tokenIdWithoutOldTrait | (newTrait << shift);\\n    /// }\\n    ///\\n    /// ### Step by step explanation\\n    ///\\n    /// Explaining this for devs that look into other contracts to learn stuff like myself\\n    ///\\n    /// ### Glossary\\n    /// \u2022 Every 2 positions in an hexadecimal representation of a number = 1 byte\\n    ///   E.g.: In 0x112233, 11 is a byte, 22 is another byte, 33 is another byte\\n    /// \u2022 Zeros on the left can be ignored so 0x00011 = 0x11, using them here to make\\n    ///   it easier to see the math\\n    /// \u2022 1 byte = 8 bits, so 0x1 << 8 will move 1 byte to the left (2 positions) resulting in 0x100\\n    ///\\n    /// In this example we have 0x1111221111 and want to increment `22` to `23`\\n    ///\\n    /// 1. Create a mask to get only the 22\\n    ///\\n    /// 0x1111221111 (gene)\\n    /// AND\\n    /// 0x0000FF0000 (mask)\\n    /// =\\n    /// 0x0000220000 (result)\\n    ///\\n    /// 2. Shift the byte \\\"22\\\" to the least significant byte, so we can increment\\n    ///\\n    /// 0x220000 >> (8 * 2) = 0x22\\n    ///\\n    /// 3. Increment\\n    ///\\n    /// 0x22 + 1 = 0x23. We're also checking against the amount of variants a trait has, that's why\\n    /// we're doing (byte + 1) % [X, X, X][i]\\n    ///\\n    /// 4. Move the byte back to its original position\\n    ///\\n    /// 0x23 << (8 * 2) = 0x230000\\n    ///\\n    /// 5. Invert the original mask to get all original bytes except the position we're manipulating\\n    ///\\n    /// ~0x0000FF0000 = 0xFFFF00FFFF\\n    ///\\n    /// 0xFFFF00FFFF\\n    /// AND\\n    /// 0x1111221111\\n    /// =\\n    /// 0x1111001111\\n    ///\\n    /// 6. Put the incremented byte back in the original value\\n    ///\\n    /// 0x1111001111\\n    /// OR\\n    /// 0x0000230000\\n    /// =\\n    /// 0x1111231111\\n    function incrementByte(uint256 gene, uint256 i)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            // Number of bytes to shift, should be between 0 and 7\\n            uint256 shift = (i % 7) * 8;\\n\\n            // Create the mask to do all the stuff mentioned in natspec\\n            uint256 mask = 0xFF << shift;\\n            return\\n                (~mask & gene) |\\n                (((((gene & mask) >> shift) + 1) %\\n                    [4, 28, 11, 70, 36, 10, 21][i % 7]) << shift);\\n        }\\n    }\\n\\n    /// @dev    Uniform cross-over two \\\"uint7\\\", returns a \\\"uint8\\\" because a child has an extra byte\\n    /// @param  mom genes from mom\\n    /// @param  dad genes from dad\\n    /// @param  seed the seed is used to pick chromossomes between dad and mom.\\n    ///\\n    /// @dev If a specific byte in the seed is even, picks mom, otherwise picks dad.\\n    ///\\n    /// ### Examples\\n    ///\\n    /// \u2022 uniformCrossOver(0x11111111111111, 0x22222222222222, 0x0) = 0x0111111111111111\\n    /// \u2022 uniformCrossOver(0x11111111111111, 0x22222222222222, 0x1) = 0x0111111111111122\\n    /// \u2022 uniformCrossOver(0x11111111111111, 0x22222222222222, 0x0101) = 0x0111111111112222\\n    /// \u2022 uniformCrossOver(0x11111111111111, 0x22222222222222, 0x010101) = 0x0111111111222222\\n    /// \u2022 uniformCrossOver(0x11111111111111, 0x22222222222222, 0x01000100010001) = 0x0122112211221122\\n    function uniformCrossOver(\\n        uint256 mom,\\n        uint256 dad,\\n        uint256 seed\\n    ) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 child = 0x0100000000000000;\\n            for (uint256 i = 0; i < 7; i++) {\\n                // Choose mom or dad to pick the chromossome from\\n                // If the byte on seed is even, pick mom\\n                uint256 chromossome = ((seed >> (8 * i)) & 0xFF) % 2 == 0\\n                    ? mom\\n                    : dad;\\n\\n                // Create a mask to pick only the current byte/chromossome\\n                // E.g.: 3rd byte = 0xFF0000\\n                uint256 mask = 0xFF << (8 * i);\\n\\n                // Add byte/chromossome to the child\\n                child |= (chromossome & mask);\\n            }\\n\\n            return child;\\n        }\\n    }\\n}\\n\"\r\n    },\r\n    \"src/libraries/Gene.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\n/// @title  AlphaDogs Gene Library\\n/// @author Aleph Retamal <github.com/alephao>\\n/// @notice Library containing functions for querying info about a gene.\\nlibrary Gene {\\n    /// @notice A gene is puppy if its 8th byte is greater than 0\\n    function isPuppy(uint256 gene) internal pure returns (bool) {\\n        return (gene & 0xFF00000000000000) > 0;\\n    }\\n\\n    /// @notice Get a specific chromossome in a gene, first position is 0\\n    function getChromossome(uint256 gene, uint32 position)\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        unchecked {\\n            uint32 shift = 8 * position;\\n            return (gene & (0xFF << shift)) >> shift;\\n        }\\n    }\\n\\n    function getBackground(uint256 gene) internal pure returns (uint256) {\\n        return getChromossome(gene, 6);\\n    }\\n\\n    function getFur(uint256 gene) internal pure returns (uint256) {\\n        return getChromossome(gene, 5);\\n    }\\n\\n    function getNeck(uint256 gene) internal pure returns (uint256) {\\n        return getChromossome(gene, 4);\\n    }\\n\\n    function getEyes(uint256 gene) internal pure returns (uint256) {\\n        return getChromossome(gene, 3);\\n    }\\n\\n    function getHat(uint256 gene) internal pure returns (uint256) {\\n        return getChromossome(gene, 2);\\n    }\\n\\n    function getMouth(uint256 gene) internal pure returns (uint256) {\\n        return getChromossome(gene, 1);\\n    }\\n\\n    function getNosering(uint256 gene) internal pure returns (uint256) {\\n        return getChromossome(gene, 0);\\n    }\\n}\\n\"\r\n    },\r\n    \"src/ERC721.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\n// solhint-disable\\n\\n/// @notice A modified version of Solmate's ERC721 (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @author Solmate, Aleph Retamal <github.com/alephao>\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(\\n        address indexed from,\\n        address indexed to,\\n        uint256 indexed id\\n    );\\n\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 indexed id\\n    );\\n\\n    event ApprovalForAll(\\n        address indexed owner,\\n        address indexed operator,\\n        bool approved\\n    );\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address => uint256) public balanceOf;\\n\\n    mapping(uint256 => address) public ownerOf;\\n\\n    mapping(uint256 => address) public getApproved;\\n\\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(\\n            msg.sender == owner || isApprovedForAll[owner][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function _transfer(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) internal {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        // Underflow of the sender's balance is impossible because we check for\\n        // ownership above and the recipient's balance can't realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from ||\\n                msg.sender == getApproved[id] ||\\n                isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        _transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    from,\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    \\\"\\\"\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(\\n                    msg.sender,\\n                    address(0),\\n                    id,\\n                    data\\n                ) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"\r\n    },\r\n    \"lib/openzeppelin-contracts/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAlphaDogsEvents.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\ninterface IAlphaDogsEvents {\\n    event NameChanged(uint256 indexed id, string name);\\n    event LoreChanged(uint256 indexed id, string lore);\\n    event Breeded(uint256 indexed child, uint256 mom, uint256 dad);\\n    event Staked(uint256 indexed id);\\n    event Unstaked(uint256 indexed id, uint256 amount);\\n    event ClaimedTokens(uint256 indexed id, uint256 amount);\\n}\\n\"\r\n    },\r\n    \"src/interfaces/IAlphaDogsErrors.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\ninterface IAlphaDogsErrors {\\n    /// @dev 0x2783839d\\n    error InsufficientTokensAvailable();\\n    /// @dev 0x154e0758\\n    error InsufficientReservedTokensAvailable();\\n    /// @dev 0x8152a42e\\n    error InsufficientNonReservedTokensAvailable();\\n    /// @dev 0x53bb24f9\\n    error TokenLimitReached();\\n    /// @dev 0xb05e92fa\\n    error InvalidMerkleProof();\\n    /// @dev 0x2c5211c6\\n    error InvalidAmount();\\n    /// @dev 0x50e55ae1\\n    error InvalidAmountToClaim();\\n    /// @dev 0x6aa2a937\\n    error InvalidTokenID();\\n    /// @dev 0x1ae3550b\\n    error InvalidNameLength();\\n    /// @dev 0x8a0fcaee\\n    error InvalidSameValue();\\n    /// @dev 0x2a7c6b6e\\n    error InvalidTokenOwner();\\n    /// @dev 0x8e8ede30\\n    error FusionWithSameParentsForbidden();\\n    /// @dev 0x6d074376\\n    error FusionWithPuppyForbidden();\\n    /// @dev 0x36a1c33f\\n    error NotChanged();\\n    /// @dev 0x80cb55e2\\n    error NotActive();\\n    /// @dev 0xb4fa3fb3\\n    error InvalidInput();\\n    /// @dev 0xddb5de5e\\n    error InvalidSender();\\n    /// @dev 0x21029e82\\n    error InvalidChar();\\n}\\n\"\r\n    },\r\n    \"src/libraries/Chromossomes.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity >=0.8.14;\\n\\n// Generated code. Do not modify!\\n\\n/// @title  AlphaDogs Chromossome Generator Library\\n/// @author Aleph Retamal <github.com/alephao>\\n/// @notice Library containing functions to pick AlphaDogs chromossomes from an uint256 seed.\\nlibrary Chromossomes {\\n    // Each of those seedTo{Trait} function select 4 bytes from the seed\\n    // and use those selected bytes to pick a trait using the A.J. Walker\\n    // algorithm. The rarity and aliases are calculated beforehand.\\n\\n    function seedToBackground(uint256 seed) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 traitSeed = (seed >> 16) & 0xFFFF;\\n            uint256 trait = traitSeed % 21;\\n            if (\\n                traitSeed >> 8 <\\n                [\\n                    154,\\n                    222,\\n                    166,\\n                    200,\\n                    150,\\n                    333,\\n                    97,\\n                    158,\\n                    33,\\n                    162,\\n                    44,\\n                    170,\\n                    93,\\n                    234,\\n                    123,\\n                    94,\\n                    345,\\n                    134,\\n                    66,\\n                    255,\\n                    99\\n                ][trait]\\n            ) return trait;\\n            return\\n                [\\n                    1,\\n                    20,\\n                    1,\\n                    2,\\n                    1,\\n                    3,\\n                    3,\\n                    3,\\n                    5,\\n                    5,\\n                    13,\\n                    9,\\n                    16,\\n                    11,\\n                    16,\\n                    16,\\n                    13,\\n                    16,\\n                    19,\\n                    16,\\n                    19\\n                ][trait];\\n        }\\n    }\\n\\n    function seedToFur(uint256 seed) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 traitSeed = (seed >> 32) & 0xFFFF;\\n            uint256 trait = traitSeed % 12;\\n            if (\\n                traitSeed >> 8 <\\n                [44, 345, 299, 450, 460, 88, 166, 177, 369, 470, 188, 277][\\n                    trait\\n                ]\\n            ) return trait;\\n            return [3, 11, 1, 2, 3, 4, 9, 9, 4, 8, 9, 9][trait];\\n        }\\n    }\\n\\n    function seedToNeck(uint256 seed) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 traitSeed = (seed >> 48) & 0xFFFF;\\n            uint256 trait = traitSeed % 34;\\n            if (\\n                traitSeed >> 8 <\\n                [\\n                    140,\\n                    333,\\n                    147,\\n                    134,\\n                    878,\\n                    92,\\n                    53,\\n                    100,\\n                    25,\\n                    115,\\n                    90,\\n                    122,\\n                    40,\\n                    6,\\n                    9,\\n                    130,\\n                    3,\\n                    5,\\n                    222,\\n                    4,\\n                    45,\\n                    52,\\n                    57,\\n                    23,\\n                    98,\\n                    50,\\n                    48,\\n                    95,\\n                    27,\\n                    21,\\n                    55,\\n                    47,\\n                    32,\\n                    35\\n                ][trait]\\n            ) return trait;\\n            return\\n                [\\n                    33,\\n                    0,\\n                    1,\\n                    2,\\n                    3,\\n                    0,\\n                    1,\\n                    4,\\n                    1,\\n                    7,\\n                    1,\\n                    9,\\n                    1,\\n                    2,\\n                    4,\\n                    11,\\n                    4,\\n                    4,\\n                    15,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    4,\\n                    9,\\n                    15,\\n                    18,\\n                    18\\n                ][trait];\\n        }\\n    }\\n\\n    function seedToEyes(uint256 seed) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 traitSeed = (seed >> 64) & 0xFFFF;\\n            uint256 trait = traitSeed % 43;\\n            if (\\n                traitSeed >> 8 <\\n                [\\n                    30,\\n                    21,\\n                    89,\\n                    7,\\n                    500,\\n                    135,\\n                    52,\\n                    59,\\n                    125,\\n                    88,\\n                    22,\\n                    81,\\n                    120,\\n                    228,\\n                    15,\\n                    90,\\n                    32,\\n                    39,\\n                    17,\\n                    83,\\n                    42,\\n                    12,\\n                    82,\\n                    100,\\n                    84,\\n                    20,\\n                    58,\\n                    56,\\n                    28,\\n                    180,\\n                    40,\\n                    35,\\n                    54,\\n                    55,\\n                    86,\\n                    85,\\n                    24,\\n                    53,\\n                    240,\\n                    80,\\n                    44,\\n                    26,\\n                    16\\n                ][trait]\\n            ) return trait;\\n            return\\n                [\\n                    4,\\n                    4,\\n                    42,\\n                    4,\\n                    2,\\n                    4,\\n                    4,\\n                    4,\\n                    5,\\n                    8,\\n                    4,\\n                    9,\\n                    11,\\n                    12,\\n                    4,\\n                    13,\\n                    4,\\n                    4,\\n                    5,\\n                    15,\\n                    8,\\n                    12,\\n                    19,\\n                    22,\\n                    23,\\n                    13,\\n                    13,\\n                    13,\\n                    13,\\n                    24,\\n                    22,\\n                    29,\\n                    29,\\n                    29,\\n                    29,\\n                    34,\\n                    35,\\n                    38,\\n                    35,\\n                    38,\\n                    38,\\n                    38,\\n                    39\\n                ][trait];\\n        }\\n    }\\n\\n    function seedToHat(uint256 seed) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 traitSeed = (seed >> 80) & 0xFFFF;\\n            uint256 trait = traitSeed % 68;\\n            if (\\n                traitSeed >> 8 <\\n                [\\n                    18,\\n                    4,\\n                    30,\\n                    35,\\n                    28,\\n                    45,\\n                    46,\\n                    25,\\n                    48,\\n                    22,\\n                    20,\\n                    1260,\\n                    38,\\n                    43,\\n                    24,\\n                    59,\\n                    38,\\n                    29,\\n                    56,\\n                    30,\\n                    7,\\n                    18,\\n                    25,\\n                    23,\\n                    58,\\n                    42,\\n                    22,\\n                    9,\\n                    6,\\n                    15,\\n                    35,\\n                    22,\\n                    12,\\n                    66,\\n                    27,\\n                    27,\\n                    44,\\n                    46,\\n                    37,\\n                    11,\\n                    28,\\n                    38,\\n                    15,\\n                    42,\\n                    40,\\n                    60,\\n                    37,\\n                    28,\\n                    53,\\n                    50,\\n                    15,\\n                    12,\\n                    5,\\n                    40,\\n                    30,\\n                    8,\\n                    18,\\n                    49,\\n                    48,\\n                    29,\\n                    30,\\n                    10,\\n                    44,\\n                    3,\\n                    35,\\n                    35,\\n                    46,\\n                    35\\n                ][trait]\\n            ) return trait;\\n            return\\n                [\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    67,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    15,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    18,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    24,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    33,\\n                    11,\\n                    11,\\n                    45,\\n                    48,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    11,\\n                    18,\\n                    33,\\n                    33,\\n                    45,\\n                    49\\n                ][trait];\\n        }\\n    }\\n\\n    function seedToMouth(uint256 seed) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 traitSeed = (seed >> 96) & 0xFFFF;\\n            uint256 trait = traitSeed % 18;\\n            if (\\n                traitSeed >> 8 <\\n                [\\n                    156,\\n                    96,\\n                    1480,\\n                    48,\\n                    333,\\n                    96,\\n                    84,\\n                    32,\\n                    156,\\n                    72,\\n                    24,\\n                    60,\\n                    72,\\n                    84,\\n                    120,\\n                    120,\\n                    168,\\n                    132\\n                ][trait]\\n            ) return trait;\\n            return\\n                [2, 2, 17, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 4, 4, 4, 4][trait];\\n        }\\n    }\\n\\n    function seedToNosering(uint256 seed) internal pure returns (uint256) {\\n        unchecked {\\n            uint256 traitSeed = (seed >> 112) & 0xFFFF;\\n            uint256 trait = traitSeed % 4;\\n            if (traitSeed >> 8 < [3201, 12, 84, 36][trait]) return trait;\\n            return [3, 0, 0, 0][trait];\\n        }\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"remappings\": [\r\n      \"$/=src/\",\r\n      \"@ds-test/=lib/ds-test/src/\",\r\n      \"@forge-std/=lib/forge-std/src/\",\r\n      \"@hevm/=lib/hevm/src/\",\r\n      \"@openzeppelin/=lib/openzeppelin-contracts/contracts/\",\r\n      \"@solmate/=lib/solmate/src/\",\r\n      \"ds-test/=lib/ds-test/src/\",\r\n      \"forge-std/=lib/forge-std/src/\",\r\n      \"hardhat/=node_modules/hardhat/\",\r\n      \"openzeppelin-contracts/=lib/openzeppelin-contracts/contracts/\",\r\n      \"solmate/=lib/solmate/src/\",\r\n      \"src/=src/\"\r\n    ],\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"metadata\": {\r\n      \"bytecodeHash\": \"ipfs\"\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"evmVersion\": \"london\",\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_maxGenesis\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_maxPuppies\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_maxReserved\",\"type\":\"uint32\"},{\"internalType\":\"contract IAlphaToken\",\"name\":\"_alphaToken\",\"type\":\"address\"},{\"internalType\":\"contract IAlphaDogsAttributes\",\"name\":\"_attributes\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"_merkleRoot\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"FusionWithPuppyForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FusionWithSameParentsForbidden\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientNonReservedTokensAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientReservedTokensAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InsufficientTokensAvailable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmountToClaim\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidChar\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidInput\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMerkleProof\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidNameLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSameValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSender\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenID\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidTokenOwner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NotChanged\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TokenLimitReached\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"child\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"mom\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dad\",\"type\":\"uint256\"}],\"name\":\"Breeded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"lore\",\"type\":\"string\"}],\"name\":\"LoreChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NameChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Staked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Unstaked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BREEDING_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GENESIS_TOKEN_PER_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PUPPY_TOKEN_PER_DAY\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"UPDATE_PRICE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"alphaToken\",\"outputs\":[{\"internalType\":\"contract IAlphaToken\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"attributes\",\"outputs\":[{\"internalType\":\"contract IAlphaDogsAttributes\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mom\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dad\",\"type\":\"uint256\"}],\"name\":\"breed\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"didMint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisLeft\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisNonReservedSupply\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisReservedSupply\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"genesisSupply\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"lore\",\"type\":\"string\"}],\"internalType\":\"struct IAlphaDogs.CustomMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getStake\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint96\",\"name\":\"stakedAt\",\"type\":\"uint96\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSaleActive\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isSupplyReserved\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxGenesis\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxPuppies\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxReserved\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"premint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"puppySupply\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"puppyTokensLeft\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isSaleActive\",\"type\":\"bool\"}],\"name\":\"setIsSaleActive\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"_isSupplyReserved\",\"type\":\"bool\"}],\"name\":\"setIsSupplyReserved\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newLore\",\"type\":\"string\"}],\"name\":\"setLore\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "AlphaDogs", "CompilerVersion": "v0.8.14+commit.80d49f37", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "0000000000000000000000000000000000000000000000000000000000000d480000000000000000000000000000000000000000000000000000000000001a900000000000000000000000000000000000000000000000000000000000000af000000000000000000000000009a8fb018326a4647488ccb340c211f510a466d3000000000000000000000000e681ae8707182c2464a5d35d7da0571a6dbcc0a7f7e1834c49033499873f3d2f07bb694a1df120ee02569685aad60cf86424718c", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}