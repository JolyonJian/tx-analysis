{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n/* ERC721IM - ERC721IM (ERC721 0xInuarashi Edition), Modifiable - Gas Optimized\r\n    Open Source: with the efforts of the [0x Collective] <3 */\r\n\r\ncontract ERC721IM {\r\n\r\n    string public name; string public symbol;\r\n    string internal baseTokenURI; string internal baseTokenURI_EXT;\r\n    constructor(string memory name_, string memory symbol_) { name = name_; symbol = symbol_; }\r\n\r\n    uint256 public totalSupply; \r\n\r\n    struct ownerAndStake {\r\n        address owner; // 20 | 12\r\n        uint40 timestamp; // 5 | 7\r\n    }\r\n\r\n    mapping(uint256 => ownerAndStake) public _ownerOf;\r\n\r\n    mapping(address => uint256) public balanceOf; \r\n\r\n    mapping(uint256 => address) public getApproved; \r\n    mapping(address => mapping(address => bool)) public isApprovedForAll; \r\n\r\n    // Events\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    function ownerOf(uint256 tokenId_) public virtual view returns (address) {\r\n        return _ownerOf[tokenId_].owner;\r\n    }\r\n\r\n    function isStaked(uint256 tokenId_) public view returns (bool) {\r\n        return _ownerOf[tokenId_].timestamp > 0;\r\n    }\r\n\r\n    function getTimestampOfToken(uint256 tokenId_) public view returns (uint40) {\r\n        return _ownerOf[tokenId_].timestamp;\r\n    }\r\n\r\n    function _stake(uint256 tokenId_) internal virtual {\r\n        require(ownerOf(tokenId_) != address(0),\r\n            \"_stake(): Token doesn't exist!\");\r\n        require(!isStaked(tokenId_),\r\n            \"_stake(): Token is already staked!\");\r\n\r\n        _ownerOf[tokenId_].timestamp = uint40(block.timestamp);\r\n    }\r\n\r\n    function _update(uint256 tokenId_) internal virtual {\r\n        require(ownerOf(tokenId_) != address(0),\r\n            \"_update(): Token doesn't exist!\");\r\n        require(isStaked(tokenId_),\r\n            \"_update(): Token is not staked!\");\r\n\r\n        _ownerOf[tokenId_].timestamp = uint40(block.timestamp);\r\n    }\r\n    \r\n    function _unstake(uint256 tokenId_) internal virtual {\r\n        require(ownerOf(tokenId_) != address(0),\r\n            \"_unstake(): Token doesn't exist!\");\r\n        require(isStaked(tokenId_),\r\n            \"_unstake(): Token is not staked!\");\r\n        \r\n        _ownerOf[tokenId_].timestamp = 0;\r\n    }\r\n\r\n    // // internal write functions\r\n    // mint\r\n    function _mint(address to_, uint256 tokenId_) internal virtual {\r\n        require(to_ != address(0x0), \"ERC721I: _mint() Mint to Zero Address\");\r\n        require(ownerOf(tokenId_) == address(0x0), \"ERC721I: _mint() Token to Mint Already Exists!\");\r\n\r\n        balanceOf[to_]++;\r\n        _ownerOf[tokenId_].owner = to_;\r\n\r\n        emit Transfer(address(0x0), to_, tokenId_);\r\n    }\r\n\r\n    // transfer\r\n    function _transfer(address from_, address to_, uint256 tokenId_) internal virtual {\r\n        require(from_ == ownerOf(tokenId_), \"ERC721I: _transfer() Transfer Not Owner of Token!\");\r\n        require(to_ != address(0x0), \"ERC721I: _transfer() Transfer to Zero Address!\");\r\n\r\n        if (getApproved[tokenId_] != address(0x0)) { \r\n            _approve(address(0x0), tokenId_); \r\n        } \r\n\r\n        _ownerOf[tokenId_].owner = to_; \r\n        balanceOf[from_]--;\r\n        balanceOf[to_]++;\r\n\r\n        emit Transfer(from_, to_, tokenId_);\r\n    }\r\n\r\n    // approve\r\n    function _approve(address to_, uint256 tokenId_) internal virtual {\r\n        if (getApproved[tokenId_] != to_) {\r\n            getApproved[tokenId_] = to_;\r\n            emit Approval(ownerOf(tokenId_), to_, tokenId_);\r\n        }\r\n    }\r\n    function _setApprovalForAll(address owner_, address operator_, bool approved_) internal virtual {\r\n        require(owner_ != operator_, \"ERC721I: _setApprovalForAll() Owner must not be the Operator!\");\r\n        isApprovedForAll[owner_][operator_] = approved_;\r\n        emit ApprovalForAll(owner_, operator_, approved_);\r\n    }\r\n\r\n    // token uri\r\n    function _setBaseTokenURI(string memory uri_) internal virtual {\r\n        baseTokenURI = uri_;\r\n    }\r\n    function _setBaseTokenURI_EXT(string memory ext_) internal virtual {\r\n        baseTokenURI_EXT = ext_;\r\n    }\r\n\r\n    // // Internal View Functions\r\n    // Embedded Libraries\r\n    function _toString(uint256 value_) internal pure returns (string memory) {\r\n        if (value_ == 0) { return \"0\"; }\r\n        uint256 _iterate = value_; uint256 _digits;\r\n        while (_iterate != 0) { _digits++; _iterate /= 10; } // get digits in value_\r\n        bytes memory _buffer = new bytes(_digits);\r\n        while (value_ != 0) { _digits--; _buffer[_digits] = bytes1(uint8(48 + uint256(value_ % 10 ))); value_ /= 10; } // create bytes of value_\r\n        return string(_buffer); // return string converted bytes of value_\r\n    }\r\n\r\n    // Functional Views\r\n    function _isApprovedOrOwner(address spender_, uint256 tokenId_) internal view virtual returns (bool) {\r\n        require(ownerOf(tokenId_) != address(0x0), \"ERC721I: _isApprovedOrOwner() Owner is Zero Address!\");\r\n        address _owner = ownerOf(tokenId_);\r\n        return (spender_ == _owner || spender_ == getApproved[tokenId_] || isApprovedForAll[_owner][spender_]);\r\n    }\r\n    function _exists(uint256 tokenId_) internal view virtual returns (bool) {\r\n        return ownerOf(tokenId_) != address(0x0);\r\n    }\r\n\r\n    // // public write functions\r\n    function approve(address to_, uint256 tokenId_) public virtual {\r\n        address _owner = ownerOf(tokenId_);\r\n        require(to_ != _owner, \"ERC721I: approve() Cannot approve yourself!\");\r\n        require(msg.sender == _owner || isApprovedForAll[_owner][msg.sender], \"ERC721I: Caller not owner or Approved!\");\r\n        _approve(to_, tokenId_);\r\n    }\r\n    function setApprovalForAll(address operator_, bool approved_) public virtual {\r\n        _setApprovalForAll(msg.sender, operator_, approved_);\r\n    }\r\n    function transferFrom(address from_, address to_, uint256 tokenId_) public virtual {\r\n        require(_isApprovedOrOwner(msg.sender, tokenId_), \"ERC721I: transferFrom() _isApprovedOrOwner = false!\");\r\n        require(!isStaked(tokenId_), \"ERC721I: transferFrom() Token is staked!\");\r\n        _transfer(from_, to_, tokenId_);\r\n    }\r\n    function safeTransferFrom(address from_, address to_, uint256 tokenId_, bytes memory data_) public virtual {\r\n        transferFrom(from_, to_, tokenId_);\r\n        if (to_.code.length != 0) {\r\n            (, bytes memory _returned) = to_.staticcall(abi.encodeWithSelector(0x150b7a02, msg.sender, from_, tokenId_, data_));\r\n            bytes4 _selector = abi.decode(_returned, (bytes4));\r\n            require(_selector == 0x150b7a02, \"ERC721I: safeTransferFrom() to_ not ERC721Receivable!\");\r\n        }\r\n    }\r\n    function safeTransferFrom(address from_, address to_, uint256 tokenId_) public virtual {\r\n        safeTransferFrom(from_, to_, tokenId_, \"\");\r\n    }\r\n\r\n    // 0xInuarashi Custom Functions\r\n    function multiTransferFrom(address from_, address to_, uint256[] memory tokenIds_) public virtual {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            transferFrom(from_, to_, tokenIds_[i]);\r\n        }\r\n    }\r\n    function multiSafeTransferFrom(address from_, address to_, uint256[] memory tokenIds_, bytes memory data_) public virtual {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            safeTransferFrom(from_, to_, tokenIds_[i], data_);\r\n        }\r\n    }\r\n\r\n    // OZ Standard Stuff\r\n    function supportsInterface(bytes4 interfaceId_) public pure returns (bool) {\r\n        return (interfaceId_ == 0x80ac58cd || interfaceId_ == 0x5b5e139f);\r\n    }\r\n\r\n    function tokenURI(uint256 tokenId_) public view virtual returns (string memory) {\r\n        require(ownerOf(tokenId_) != address(0x0), \"ERC721I: tokenURI() Token does not exist!\");\r\n        return string(abi.encodePacked(baseTokenURI, _toString(tokenId_), baseTokenURI_EXT));\r\n    }\r\n\r\n    function tokenIdStartsAt() public virtual view returns (uint256) {\r\n        uint256 _loopThrough = totalSupply;\r\n        uint256 _tokenIdStartAt;\r\n\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            if (ownerOf(i) != address(0x0)) { _tokenIdStartAt = i; break; }\r\n        }\r\n\r\n        return _tokenIdStartAt;        \r\n    }\r\n\r\n    function balanceOfStaked(address address_) public virtual view returns (uint256) {\r\n        uint256 _balance;\r\n        uint256 _loopThrough = totalSupply;\r\n        uint256 _tokenIdStartAt = tokenIdStartsAt();\r\n\r\n        for (uint256 i = _tokenIdStartAt; i <= _loopThrough + _tokenIdStartAt; i++) {\r\n            if (_ownerOf[i].owner == address_ && isStaked(i)) {\r\n                _balance++;\r\n            }\r\n        }\r\n\r\n        return _balance;\r\n    }\r\n    function balanceOfUnstaked(address address_) public virtual view \r\n    returns (uint256) {\r\n        uint256 _balance;\r\n        uint256 _loopThrough = totalSupply;\r\n        uint256 _tokenIdStartAt = tokenIdStartsAt();\r\n\r\n        for (uint256 i = _tokenIdStartAt; i <= _loopThrough + _tokenIdStartAt; i++) {\r\n            if (_ownerOf[i].owner == address_ && !isStaked(i)) {\r\n                _balance++;\r\n            }\r\n        }\r\n\r\n        return _balance;\r\n    }\r\n\r\n    // // public view functions\r\n    // never use these for functions ever, they are expensive af and for view only (this will be an issue in the future for interfaces)\r\n    function walletOfOwner(address address_) public virtual view \r\n    returns (uint256[] memory) {\r\n        uint256 _balance = balanceOf[address_];\r\n        if (_balance == 0) return new uint256[](0);\r\n\r\n        uint256[] memory _tokens = new uint256[] (_balance);\r\n        uint256 _index;\r\n        uint256 _loopThrough = totalSupply;\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            if (ownerOf(i) == address(0x0) && _tokens[_balance - 1] == 0) {\r\n                _loopThrough++; \r\n            }\r\n            if (_ownerOf[i].owner == address_) { \r\n                _tokens[_index] = i; _index++; \r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n\r\n    function walletOfOwnerUnstaked(address address_) public virtual view \r\n    returns (uint256[] memory) {\r\n        uint256 _balance = balanceOfUnstaked(address_);\r\n        if (_balance == 0) return new uint256[](0);\r\n\r\n        uint256[] memory _tokens = new uint256[] (_balance);\r\n        uint256 _index;\r\n        uint256 _loopThrough = totalSupply;\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            if (ownerOf(i) == address(0x0) && _tokens[_balance - 1] == 0) {\r\n                _loopThrough++; \r\n            }\r\n            if (_ownerOf[i].owner == address_ && !isStaked(i)) { \r\n                _tokens[_index] = i; _index++; \r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n\r\n    function walletOfOwnerStaked(address address_) public virtual view \r\n    returns (uint256[] memory) {\r\n        uint256 _balance = balanceOfStaked(address_);\r\n        if (_balance == 0) return new uint256[](0);\r\n\r\n        uint256[] memory _tokens = new uint256[] (_balance);\r\n        uint256 _index;\r\n        uint256 _loopThrough = totalSupply;\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            if (ownerOf(i) == address(0x0) && _tokens[_balance - 1] == 0) { \r\n                _loopThrough++; \r\n            }\r\n            // if (ownerOf(i) == address_) { _tokens[_index] = i; _index++; }\r\n            if (_ownerOf[i].owner == address_ && isStaked(i)) { \r\n                _tokens[_index] = i; _index++; \r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n\r\n    // so not sure when this will ever be really needed but it conforms to erc721 enumerable\r\n    function tokenOfOwnerByIndex(address address_, uint256 index_) public virtual view returns (uint256) {\r\n        uint256[] memory _wallet = walletOfOwner(address_);\r\n        return _wallet[index_];\r\n    }\r\n}\r\n\r\n/*\r\n    administrative functions marked as internal because you should have\r\n    owner access in order to use them. so, write them in your contract yourself!\r\n*/\r\n\r\nabstract contract MerkleWhitelist {\r\n    bytes32 internal _merkleRoot = 0xa67a6c6810aaf3dec2d76d522ab50128c8a08e7e5574456aa3c4b0c6f3eb9732;\r\n    function _setMerkleRoot(bytes32 merkleRoot_) internal virtual {\r\n        _merkleRoot = merkleRoot_;\r\n    }\r\n    function isWhitelisted(address address_, bytes32[] memory proof_) public view returns (bool) {\r\n        bytes32 _leaf = keccak256(abi.encodePacked(address_));\r\n        for (uint256 i = 0; i < proof_.length; i++) {\r\n            _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) \r\n                : keccak256(abi.encodePacked(proof_[i], _leaf));\r\n        }\r\n        return _leaf == _merkleRoot;\r\n    }\r\n}\r\n\r\n// Open0x Ownable (by 0xInuarashi)\r\nabstract contract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed oldOwner_, address indexed newOwner_);\r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function _transferOwnership(address newOwner_) internal virtual {\r\n        address _oldOwner = owner;\r\n        owner = newOwner_;\r\n        emit OwnershipTransferred(_oldOwner, newOwner_);    \r\n    }\r\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\r\n        require(newOwner_ != address(0x0), \"Ownable: new owner is the zero address!\");\r\n        _transferOwnership(newOwner_);\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0x0));\r\n    }\r\n}\r\n\r\n\r\n// Open0x Payable Governance Module by 0xInuarashi\r\n// This abstract contract utilizes for loops in order to iterate things in order to be modular\r\n// It is not the most gas-effective implementation. \r\n// We sacrified gas-effectiveness for Modularity instead.\r\nabstract contract PayableGovernance is Ownable {\r\n    // Special Access\r\n    address _payableGovernanceSetter;\r\n    constructor() payable { _payableGovernanceSetter = msg.sender; }\r\n    modifier onlyPayableGovernanceSetter {\r\n        require(msg.sender == _payableGovernanceSetter, \"PayableGovernance: Caller is not Setter!\"); _; }\r\n    function reouncePayableGovernancePermissions() public onlyPayableGovernanceSetter {\r\n        _payableGovernanceSetter = address(0x0); }\r\n\r\n    // Receivable Fallback\r\n    event Received(address from, uint amount);\r\n    receive() external payable { emit Received(msg.sender, msg.value); }\r\n\r\n    // Required Variables\r\n    address payable[] internal _payableGovernanceAddresses;\r\n    uint256[] internal _payableGovernanceShares;    \r\n    mapping(address => bool) public addressToEmergencyUnlocked;\r\n\r\n    // Withdraw Functionality\r\n    function _withdraw(address payable address_, uint256 amount_) internal {\r\n        (bool success, ) = payable(address_).call{value: amount_}(\"\");\r\n        require(success, \"Transfer failed\");\r\n    }\r\n\r\n    // Governance Functions\r\n    function setPayableGovernanceShareholders(address payable[] memory addresses_, uint256[] memory shares_) public onlyPayableGovernanceSetter {\r\n        require(_payableGovernanceAddresses.length == 0 && _payableGovernanceShares.length == 0, \"Payable Governance already set! To set again, reset first!\");\r\n        require(addresses_.length == shares_.length, \"Address and Shares length mismatch!\");\r\n        uint256 _totalShares;\r\n        for (uint256 i = 0; i < addresses_.length; i++) {\r\n            _totalShares += shares_[i];\r\n            _payableGovernanceAddresses.push(addresses_[i]);\r\n            _payableGovernanceShares.push(shares_[i]);\r\n        }\r\n        require(_totalShares == 1000, \"Total Shares is not 1000!\");\r\n    }\r\n    function resetPayableGovernanceShareholders() public onlyPayableGovernanceSetter {\r\n        while (_payableGovernanceAddresses.length != 0) {\r\n            _payableGovernanceAddresses.pop(); }\r\n        while (_payableGovernanceShares.length != 0) {\r\n            _payableGovernanceShares.pop(); }\r\n    }\r\n\r\n    // Governance View Functions\r\n    function balance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    function payableGovernanceAddresses() public view returns (address payable[] memory) {\r\n        return _payableGovernanceAddresses;\r\n    }\r\n    function payableGovernanceShares() public view returns (uint256[] memory) {\r\n        return _payableGovernanceShares;\r\n    }\r\n\r\n    // Withdraw Functions\r\n    function withdrawEther() public onlyOwner {\r\n        // require that there has been payable governance set.\r\n        require(_payableGovernanceAddresses.length > 0 && _payableGovernanceShares.length > 0, \"Payable governance not set yet!\");\r\n         // this should never happen\r\n        require(_payableGovernanceAddresses.length == _payableGovernanceShares.length, \"Payable governance length mismatch!\");\r\n        \r\n        // now, we check that the governance shares equal to 1000.\r\n        uint256 _totalPayableShares;\r\n        for (uint256 i = 0; i < _payableGovernanceShares.length; i++) {\r\n            _totalPayableShares += _payableGovernanceShares[i]; }\r\n        require(_totalPayableShares == 1000, \"Payable Governance Shares is not 1000!\");\r\n        \r\n        // // now, we start the withdrawal process if all conditionals pass\r\n        // store current balance in local memory\r\n        uint256 _totalETH = address(this).balance; \r\n\r\n        // withdraw loop for payable governance\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            uint256 _ethToWithdraw = ((_totalETH * _payableGovernanceShares[i]) / 1000);\r\n            _withdraw(_payableGovernanceAddresses[i], _ethToWithdraw);\r\n        }\r\n    }\r\n\r\n    function viewWithdrawAmounts() public view onlyOwner returns (uint256[] memory) {\r\n        // require that there has been payable governance set.\r\n        require(_payableGovernanceAddresses.length > 0 && _payableGovernanceShares.length > 0, \"Payable governance not set yet!\");\r\n         // this should never happen\r\n        require(_payableGovernanceAddresses.length == _payableGovernanceShares.length, \"Payable governance length mismatch!\");\r\n        \r\n        // now, we check that the governance shares equal to 1000.\r\n        uint256 _totalPayableShares;\r\n        for (uint256 i = 0; i < _payableGovernanceShares.length; i++) {\r\n            _totalPayableShares += _payableGovernanceShares[i]; }\r\n        require(_totalPayableShares == 1000, \"Payable Governance Shares is not 1000!\");\r\n        \r\n        // // now, we start the array creation process if all conditionals pass\r\n        // store current balance in local memory and instantiate array for input\r\n        uint256 _totalETH = address(this).balance; \r\n        uint256[] memory _withdrawals = new uint256[] (_payableGovernanceAddresses.length + 2);\r\n\r\n        // array creation loop for payable governance values \r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            _withdrawals[i] = ( (_totalETH * _payableGovernanceShares[i]) / 1000 );\r\n        }\r\n        \r\n        // push two last array spots as total eth and added eths of withdrawals\r\n        _withdrawals[_payableGovernanceAddresses.length] = _totalETH;\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            _withdrawals[_payableGovernanceAddresses.length + 1] += _withdrawals[i]; }\r\n\r\n        // return the final array data\r\n        return _withdrawals;\r\n    }\r\n\r\n    // Shareholder Governance\r\n    modifier onlyShareholder {\r\n        bool _isShareholder;\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            if (msg.sender == _payableGovernanceAddresses[i]) {\r\n                _isShareholder = true;\r\n            }\r\n        }\r\n        require(_isShareholder, \"You are not a shareholder!\");\r\n        _;\r\n    }\r\n    function unlockEmergencyFunctionsAsShareholder() public onlyShareholder {\r\n        addressToEmergencyUnlocked[msg.sender] = true;\r\n    }\r\n\r\n    // Emergency Functions\r\n    modifier onlyEmergency {\r\n        for (uint256 i = 0; i < _payableGovernanceAddresses.length; i++) {\r\n            require(addressToEmergencyUnlocked[_payableGovernanceAddresses[i]], \"Emergency Functions are not unlocked!\");\r\n        }\r\n        _;\r\n    }\r\n    function emergencyWithdrawEther() public onlyOwner onlyEmergency {\r\n        _withdraw(payable(msg.sender), address(this).balance);\r\n    }\r\n}\r\n\r\n// Open0x Security by 0xInuarashi\r\nabstract contract Security {\r\n    // Prevent Smart Contracts\r\n    modifier onlySender {\r\n        require(msg.sender == tx.origin, \"No Smart Contracts!\"); _; }\r\n}\r\n\r\nabstract contract WhitelistMint {\r\n    // Whitelist Minting\r\n    bool internal _whitelistMintEnabled; uint256 public _whitelistMintTime;\r\n    function _setWhitelistMint(bool bool_, uint256 time_) internal {\r\n        _whitelistMintEnabled = bool_; _whitelistMintTime = time_; }\r\n    modifier whitelistMintEnabled {\r\n        require(_whitelistMintEnabled && _whitelistMintTime <= block.timestamp, \r\n            \"Whitelist Mint is not enabled yet!\"); _; } \r\n    function whitelistMintStatus() external view returns (bool) {\r\n        return _whitelistMintEnabled && _whitelistMintTime <= block.timestamp; }\r\n}\r\n\r\nabstract contract PublicMint {\r\n    // Public Minting\r\n    bool public _publicMintEnabled; uint256 public _publicMintTime;\r\n    function _setPublicMint(bool bool_, uint256 time_) internal {\r\n        _publicMintEnabled = bool_; _publicMintTime = time_; }\r\n    modifier publicMintEnabled { \r\n        require(_publicMintEnabled && _publicMintTime <= block.timestamp, \r\n            \"Public Mint is not enabled yet!\"); _; }\r\n    function publicMintStatus() external view returns (bool) {\r\n        return _publicMintEnabled && _publicMintTime <= block.timestamp; }\r\n}\r\n\r\ninterface isCT {\r\n    function mintStakedTokenAsCyberTurtles(address to_, uint256 tokenId_) external;\r\n}\r\n\r\ncontract CyberTurtles is ERC721IM, MerkleWhitelist, Ownable, PayableGovernance,\r\nSecurity, WhitelistMint, PublicMint {\r\n    constructor() payable ERC721IM(\"CyberTurtles\", \"CYBERT\") {}\r\n\r\n    /*\r\n        CyberTurtles \r\n        Staking with Proof-of-Stake-Token Phantom Minting\r\n        Yield $SHELL\r\n        Whitelist Mint (MerkleWhitelist)\r\n        Public Mint\r\n    */\r\n\r\n    ////// Project Contraints //////\r\n    uint256 public maxTokens = 5555; \r\n    uint256 public mintPrice = 0.07 ether; \r\n    uint256 public maxMintsPerTx = 10;\r\n\r\n    uint256 public maxMintsPerWl = 2;\r\n    mapping(address => uint256) public addressToWlMints;\r\n\r\n    ///// Interfaces /////\r\n    isCT public sCT;\r\n    function setsCT(address address_) external onlyOwner {\r\n        sCT = isCT(address_);\r\n    }\r\n    modifier onlyStaker {\r\n        require(msg.sender == address(sCT), \"You are not staker!\"); _;\r\n    }\r\n\r\n    ///// Ownable /////\r\n    // Constraints\r\n    function setMaxTokens(uint256 maxTokens_) external onlyOwner {\r\n        maxTokens = maxTokens_;\r\n    }\r\n    function setMintPrice(uint256 mintPrice_) external onlyOwner {\r\n        mintPrice = mintPrice_;\r\n    }\r\n\r\n    function setMaxMintsPerTx(uint256 maxMints_) external onlyOwner {\r\n        maxMintsPerTx = maxMints_;\r\n    }\r\n    function setMaxMintsPerWl(uint256 maxMints_) external onlyOwner {\r\n        maxMintsPerWl = maxMints_;\r\n    }\r\n\r\n    // Token URI\r\n    function setBaseTokenURI(string calldata uri_) external onlyOwner { \r\n        _setBaseTokenURI(uri_);\r\n    }\r\n    function setBaseTokenURI_EXT(string calldata ext_) external onlyOwner {\r\n        _setBaseTokenURI_EXT(ext_);\r\n    }\r\n\r\n    // MerkleRoot\r\n    function setMerkleRoot(bytes32 merkleRoot_) external onlyOwner {\r\n        _setMerkleRoot(merkleRoot_);\r\n    }\r\n\r\n    // Public Mint\r\n    function setPublicMint(bool bool_, uint256 time_) external onlyOwner {\r\n        _setPublicMint(bool_, time_);\r\n    }\r\n    \r\n    // Whitelist Mint\r\n    function setWhitelistMint(bool bool_, uint256 time_) external onlyOwner {\r\n        _setWhitelistMint(bool_, time_);\r\n    }\r\n\r\n    // (Withdrawals Handled by PayableGovernance)\r\n\r\n    ///// OwnerOf Override /////\r\n    function ownerOf(uint256 tokenId_) public view override returns (address) {\r\n        if (_ownerOf[tokenId_].timestamp == 0) {\r\n            return _ownerOf[tokenId_].owner;\r\n        } else {\r\n            return address(sCT);\r\n        }\r\n    }\r\n\r\n    // OG Functionality\r\n    bytes32 internal _merkleRootOG = 0x29480e5ce297f9137e60d028b74252fa6019a4334d601f58b2bb4d07cc5c2b55;\r\n    function setMerkleRootOG(bytes32 merkleRoot_) external onlyOwner {\r\n        _merkleRootOG = merkleRoot_;\r\n    }\r\n    function isOG(address address_, bytes32[] memory proof_) \r\n    public view returns (bool) {\r\n        bytes32 _leaf = keccak256(abi.encodePacked(address_));\r\n        for (uint256 i = 0; i < proof_.length; i++) {\r\n            _leaf = _leaf < proof_[i] ? keccak256(abi.encodePacked(_leaf, proof_[i])) \r\n                : keccak256(abi.encodePacked(proof_[i], _leaf));\r\n        }\r\n        return _leaf == _merkleRootOG;\r\n    }\r\n    mapping(address => uint256) public addressToOgMinted;\r\n\r\n    ///// Internal Mint /////\r\n    function _mintMany(address to_, uint256 amount_) internal {\r\n        require(maxTokens >= totalSupply + amount_,\r\n            \"Not enough tokens remaining!\");\r\n            \r\n        uint256 _startId = totalSupply + 1; // iterate from 1\r\n\r\n        for (uint256 i = 0; i < amount_; i++) {\r\n            _mint(to_, _startId + i);\r\n        }\r\n        totalSupply += amount_;\r\n    }\r\n    function _mintAndStakeMany(address to_, uint256 amount_) internal {\r\n        require(maxTokens >= totalSupply + amount_,\r\n            \"Not enough tokens remaining!\");\r\n        \r\n        uint256 _startId = totalSupply + 1; // iterate from 1\r\n\r\n        for (uint256 i = 0; i < amount_; i++) {\r\n            _mint(to_, _startId + i);\r\n            _stake(_startId + i);\r\n            \r\n            emit Transfer(to_, address(sCT), _startId + i);\r\n            sCT.mintStakedTokenAsCyberTurtles(to_, _startId + i);\r\n        }\r\n        totalSupply += amount_;\r\n    }\r\n\r\n    ///// Magic Stake Code /////\r\n    // Turtle Staker / Unstaker -- The validation logic is handled by sCyberTurtles\r\n    function validateOwnershipOfTokens(address owner_, uint256[] calldata tokenIds_)\r\n    external view returns (bool) {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            if (owner_ != ownerOf(tokenIds_[i])) return false;\r\n        }\r\n        return true;\r\n    }\r\n    function validateOwnershipOfStakedTokens(address owner_,\r\n    uint256[] calldata tokenIds_) external view returns (bool) {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            ownerAndStake memory _ownerAndStake = _ownerOf[tokenIds_[i]];\r\n            if (owner_ != _ownerAndStake.owner \r\n                || _ownerAndStake.timestamp == 0) return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    function stakeTurtles(uint256[] calldata tokenIds_) external onlyStaker {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            _stake(tokenIds_[i]);\r\n            emit Transfer(ownerOf(tokenIds_[i]), address(sCT), tokenIds_[i]);\r\n        }\r\n    }\r\n    function updateTurtles(uint256[] calldata tokenIds_) external onlyStaker {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            _update(tokenIds_[i]);\r\n        }\r\n    }\r\n    function unstakeTurtles(uint256[] calldata tokenIds_) external onlyStaker {\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            _unstake(tokenIds_[i]);\r\n            emit Transfer(address(sCT), _ownerOf[tokenIds_[i]].owner, tokenIds_[i]);\r\n        }\r\n    }\r\n\r\n    ///// Minting Functions /////\r\n    function ownerMint(address[] calldata tos_, uint256[] calldata amounts_,\r\n    bool stakeOnMint_) external onlyOwner {\r\n        require(tos_.length == amounts_.length,\r\n            \"Array lengths mismatch!\");\r\n            \r\n        if (stakeOnMint_) {\r\n            for (uint256 i = 0; i < tos_.length; i++) {\r\n                _mintAndStakeMany(tos_[i], amounts_[i]);\r\n            }\r\n        } else {\r\n            for (uint256 i = 0; i < tos_.length; i++) {\r\n                _mintMany(tos_[i], amounts_[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    // OG Claim Function (we reused whitelistMint modifier)\r\n    function ogClaim(bytes32[] calldata proof_, bool stakeOnMint_) \r\n    public onlySender whitelistMintEnabled {\r\n        require(isOG(msg.sender, proof_),\r\n            \"You are not OG!\");\r\n        require(addressToOgMinted[msg.sender] == 0, \r\n            \"You have already minted!\");\r\n\r\n        addressToOgMinted[msg.sender]++;\r\n\r\n        if (stakeOnMint_) {\r\n            _mintAndStakeMany(msg.sender, 1);\r\n        } else {\r\n            _mintMany(msg.sender, 1);\r\n        }\r\n    }\r\n\r\n    // Whitelist Mint Functions\r\n    function whitelistMint(bytes32[] calldata proof_, uint256 amount_,\r\n    bool stakeOnMint_) public payable onlySender whitelistMintEnabled {\r\n        require(isWhitelisted(msg.sender, proof_),\r\n            \"You are not whitelisted!\");\r\n        require(maxMintsPerWl >= addressToWlMints[msg.sender] + amount_,\r\n            \"You dont have enough whitelist mints!\");\r\n        require(msg.value == mintPrice * amount_,\r\n            \"Invalid value sent!\");\r\n        \r\n        // Add address to WL minted\r\n        addressToWlMints[msg.sender] += amount_;\r\n\r\n        if (stakeOnMint_) {\r\n            _mintAndStakeMany(msg.sender, amount_);\r\n        } else {\r\n            _mintMany(msg.sender, amount_);\r\n        }\r\n    }\r\n\r\n    // Public Mint Functions\r\n    function publicMint(uint256 amount_, bool stakeOnMint_) external payable\r\n    onlySender publicMintEnabled {\r\n        require(maxMintsPerTx >= amount_,\r\n            \"Over maximum mints per TX!\");\r\n        require(msg.value == mintPrice * amount_,\r\n            \"Invalid value sent!\");\r\n        \r\n        if (stakeOnMint_) {\r\n            _mintAndStakeMany(msg.sender, amount_);\r\n        } else {\r\n            _mintMany(msg.sender, amount_);\r\n        }\r\n    }\r\n}", "ABI": "[{\"inputs\":[],\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Received\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"uint40\",\"name\":\"timestamp\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_publicMintEnabled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_publicMintTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"_whitelistMintTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToEmergencyUnlocked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToOgMinted\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToWlMints\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"balance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"balanceOfStaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"balanceOfUnstaked\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyWithdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getTimestampOfToken\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"\",\"type\":\"uint40\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"isOG\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"isStaked\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerTx\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxMintsPerWl\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"multiSafeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"multiTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"},{\"internalType\":\"bool\",\"name\":\"stakeOnMint_\",\"type\":\"bool\"}],\"name\":\"ogClaim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tos_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"stakeOnMint_\",\"type\":\"bool\"}],\"name\":\"ownerMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payableGovernanceAddresses\",\"outputs\":[{\"internalType\":\"address payable[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"payableGovernanceShares\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stakeOnMint_\",\"type\":\"bool\"}],\"name\":\"publicMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"publicMintStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reouncePayableGovernancePermissions\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"resetPayableGovernanceShareholders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"sCT\",\"outputs\":[{\"internalType\":\"contract isCT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data_\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator_\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"approved_\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ext_\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI_EXT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxMints_\",\"type\":\"uint256\"}],\"name\":\"setMaxMintsPerTx\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxMints_\",\"type\":\"uint256\"}],\"name\":\"setMaxMintsPerWl\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"maxTokens_\",\"type\":\"uint256\"}],\"name\":\"setMaxTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"merkleRoot_\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRootOG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"mintPrice_\",\"type\":\"uint256\"}],\"name\":\"setMintPrice\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address payable[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"shares_\",\"type\":\"uint256[]\"}],\"name\":\"setPayableGovernanceShareholders\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"time_\",\"type\":\"uint256\"}],\"name\":\"setPublicMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"bool_\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"time_\",\"type\":\"uint256\"}],\"name\":\"setWhitelistMint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setsCT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"stakeTurtles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenIdStartsAt\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"index_\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unlockEmergencyFunctionsAsShareholder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"unstakeTurtles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"updateTurtles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"validateOwnershipOfStakedTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"validateOwnershipOfTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"viewWithdrawAmounts\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletOfOwnerStaked\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletOfOwnerUnstaked\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof_\",\"type\":\"bytes32[]\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"stakeOnMint_\",\"type\":\"bool\"}],\"name\":\"whitelistMint\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"whitelistMintStatus\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}]", "ContractName": "CyberTurtles", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://42d5d33fc25d612eb479449862fe8dc0b09ae4463950a623053c297948b09a4d"}