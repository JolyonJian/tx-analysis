{"SourceCode": "{\"ERC1155.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Minimalist and gas efficient standard ERC1155 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\nabstract contract ERC1155 {\\n    /*///////////////////////////////////////////////////////////////\\n                                EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event TransferSingle(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256 id,\\n        uint256 amount\\n    );\\n\\n    event TransferBatch(\\n        address indexed operator,\\n        address indexed from,\\n        address indexed to,\\n        uint256[] ids,\\n        uint256[] amounts\\n    );\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    event URI(string value, uint256 indexed id);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC1155 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public balanceOf;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function uri(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             ERC1155 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) public virtual {\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        balanceOf[from][id] -= amount;\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, from, to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, from, id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) public virtual {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        require(msg.sender == from || isApprovedForAll[from][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        for (uint256 i = 0; i \\u003c idsLength; ) {\\n            uint256 id = ids[i];\\n            uint256 amount = amounts[i];\\n\\n            balanceOf[from][id] -= amount;\\n            balanceOf[to][id] += amount;\\n\\n            // An array can\\u0027t have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, from, ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function balanceOfBatch(address[] memory owners, uint256[] memory ids)\\n        public\\n        view\\n        virtual\\n        returns (uint256[] memory balances)\\n    {\\n        uint256 ownersLength = owners.length; // Saves MLOADs.\\n\\n        require(ownersLength == ids.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        balances = new uint256[](owners.length);\\n\\n        // Unchecked because the only math done is incrementing\\n        // the array index counter which cannot possibly overflow.\\n        unchecked {\\n            for (uint256 i = 0; i \\u003c ownersLength; i++) {\\n                balances[i] = balanceOf[owners[i]][ids[i]];\\n            }\\n        }\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0xd9b67a26 || // ERC165 Interface ID for ERC1155\\n            interfaceId == 0x0e89341c; // ERC165 Interface ID for ERC1155MetadataURI\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) internal {\\n        balanceOf[to][id] += amount;\\n\\n        emit TransferSingle(msg.sender, address(0), to, id, amount);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155Received(msg.sender, address(0), id, amount, data) ==\\n                    ERC1155TokenReceiver.onERC1155Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchMint(\\n        address to,\\n        uint256[] memory ids,\\n        uint256[] memory amounts,\\n        bytes memory data\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i \\u003c idsLength; ) {\\n            balanceOf[to][ids[i]] += amounts[i];\\n\\n            // An array can\\u0027t have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, address(0), to, ids, amounts);\\n\\n        require(\\n            to.code.length == 0\\n                ? to != address(0)\\n                : ERC1155TokenReceiver(to).onERC1155BatchReceived(msg.sender, address(0), ids, amounts, data) ==\\n                    ERC1155TokenReceiver.onERC1155BatchReceived.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _batchBurn(\\n        address from,\\n        uint256[] memory ids,\\n        uint256[] memory amounts\\n    ) internal {\\n        uint256 idsLength = ids.length; // Saves MLOADs.\\n\\n        require(idsLength == amounts.length, \\\"LENGTH_MISMATCH\\\");\\n\\n        for (uint256 i = 0; i \\u003c idsLength; ) {\\n            balanceOf[from][ids[i]] -= amounts[i];\\n\\n            // An array can\\u0027t have a total length\\n            // larger than the max uint256 value.\\n            unchecked {\\n                i++;\\n            }\\n        }\\n\\n        emit TransferBatch(msg.sender, from, address(0), ids, amounts);\\n    }\\n\\n    function _burn(\\n        address from,\\n        uint256 id,\\n        uint256 amount\\n    ) internal {\\n        balanceOf[from][id] -= amount;\\n\\n        emit TransferSingle(msg.sender, from, address(0), id, amount);\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC1155 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC1155.sol)\\ninterface ERC1155TokenReceiver {\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"},\"ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern and gas efficient ERC20 + EIP-2612 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC20.sol)\\n/// @author Modified from Uniswap (https://github.com/Uniswap/uniswap-v2-core/blob/master/contracts/UniswapV2ERC20.sol)\\n/// @dev Do not manually set balances without updating totalSupply, as the sum of all user balances must not exceed it.\\nabstract contract ERC20 {\\n    /*///////////////////////////////////////////////////////////////\\n                                  EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             METADATA STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    uint8 public immutable decimals;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    uint256 public totalSupply;\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e uint256)) public allowance;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                             EIP-2612 STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    bytes32 public constant PERMIT_TYPEHASH =\\n        keccak256(\\\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\\\");\\n\\n    uint256 internal immutable INITIAL_CHAIN_ID;\\n\\n    bytes32 internal immutable INITIAL_DOMAIN_SEPARATOR;\\n\\n    mapping(address =\\u003e uint256) public nonces;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                               CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(\\n        string memory _name,\\n        string memory _symbol,\\n        uint8 _decimals\\n    ) {\\n        name = _name;\\n        symbol = _symbol;\\n        decimals = _decimals;\\n\\n        INITIAL_CHAIN_ID = block.chainid;\\n        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC20 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 amount) public virtual returns (bool) {\\n        allowance[msg.sender][spender] = amount;\\n\\n        emit Approval(msg.sender, spender, amount);\\n\\n        return true;\\n    }\\n\\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\\n        balanceOf[msg.sender] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(msg.sender, to, amount);\\n\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) public virtual returns (bool) {\\n        uint256 allowed = allowance[from][msg.sender]; // Saves gas for limited approvals.\\n\\n        if (allowed != type(uint256).max) allowance[from][msg.sender] = allowed - amount;\\n\\n        balanceOf[from] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(from, to, amount);\\n\\n        return true;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              EIP-2612 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public virtual {\\n        require(deadline \\u003e= block.timestamp, \\\"PERMIT_DEADLINE_EXPIRED\\\");\\n\\n        // Unchecked because the only math done is incrementing\\n        // the owner\\u0027s nonce which cannot realistically overflow.\\n        unchecked {\\n            bytes32 digest = keccak256(\\n                abi.encodePacked(\\n                    \\\"\\\\x19\\\\x01\\\",\\n                    DOMAIN_SEPARATOR(),\\n                    keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\\n                )\\n            );\\n\\n            address recoveredAddress = ecrecover(digest, v, r, s);\\n\\n            require(recoveredAddress != address(0) \\u0026\\u0026 recoveredAddress == owner, \\\"INVALID_SIGNER\\\");\\n\\n            allowance[recoveredAddress][spender] = value;\\n        }\\n\\n        emit Approval(owner, spender, value);\\n    }\\n\\n    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {\\n        return block.chainid == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();\\n    }\\n\\n    function computeDomainSeparator() internal view virtual returns (bytes32) {\\n        return\\n            keccak256(\\n                abi.encode(\\n                    keccak256(\\\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\\\"),\\n                    keccak256(bytes(name)),\\n                    keccak256(\\\"1\\\"),\\n                    block.chainid,\\n                    address(this)\\n                )\\n            );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 amount) internal virtual {\\n        totalSupply += amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[to] += amount;\\n        }\\n\\n        emit Transfer(address(0), to, amount);\\n    }\\n\\n    function _burn(address from, uint256 amount) internal virtual {\\n        balanceOf[from] -= amount;\\n\\n        // Cannot underflow because a user\\u0027s balance\\n        // will never be larger than the total supply.\\n        unchecked {\\n            totalSupply -= amount;\\n        }\\n\\n        emit Transfer(from, address(0), amount);\\n    }\\n}\\n\"},\"ERC721.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity \\u003e=0.8.0;\\n\\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\\nabstract contract ERC721 {\\n    /*///////////////////////////////////////////////////////////////\\n                                 EVENTS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\\n\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                          METADATA STORAGE/LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    string public name;\\n\\n    string public symbol;\\n\\n    function tokenURI(uint256 id) public view virtual returns (string memory);\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ERC721 STORAGE                        \\n    //////////////////////////////////////////////////////////////*/\\n\\n    mapping(address =\\u003e uint256) public balanceOf;\\n\\n    mapping(uint256 =\\u003e address) public ownerOf;\\n\\n    mapping(uint256 =\\u003e address) public getApproved;\\n\\n    mapping(address =\\u003e mapping(address =\\u003e bool)) public isApprovedForAll;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(string memory _name, string memory _symbol) {\\n        name = _name;\\n        symbol = _symbol;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC721 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function approve(address spender, uint256 id) public virtual {\\n        address owner = ownerOf[id];\\n\\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \\\"NOT_AUTHORIZED\\\");\\n\\n        getApproved[id] = spender;\\n\\n        emit Approval(owner, spender, id);\\n    }\\n\\n    function setApprovalForAll(address operator, bool approved) public virtual {\\n        isApprovedForAll[msg.sender][operator] = approved;\\n\\n        emit ApprovalForAll(msg.sender, operator, approved);\\n    }\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        require(from == ownerOf[id], \\\"WRONG_FROM\\\");\\n\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(\\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\\n            \\\"NOT_AUTHORIZED\\\"\\n        );\\n\\n        // Underflow of the sender\\u0027s balance is impossible because we check for\\n        // ownership above and the recipient\\u0027s balance can\\u0027t realistically overflow.\\n        unchecked {\\n            balanceOf[from]--;\\n\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(from, to, id);\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public virtual {\\n        transferFrom(from, to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                              ERC165 LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\\n        return\\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL MINT/BURN LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _mint(address to, uint256 id) internal virtual {\\n        require(to != address(0), \\\"INVALID_RECIPIENT\\\");\\n\\n        require(ownerOf[id] == address(0), \\\"ALREADY_MINTED\\\");\\n\\n        // Counter overflow is incredibly unrealistic.\\n        unchecked {\\n            balanceOf[to]++;\\n        }\\n\\n        ownerOf[id] = to;\\n\\n        emit Transfer(address(0), to, id);\\n    }\\n\\n    function _burn(uint256 id) internal virtual {\\n        address owner = ownerOf[id];\\n\\n        require(ownerOf[id] != address(0), \\\"NOT_MINTED\\\");\\n\\n        // Ownership check above ensures no underflow.\\n        unchecked {\\n            balanceOf[owner]--;\\n        }\\n\\n        delete ownerOf[id];\\n\\n        delete getApproved[id];\\n\\n        emit Transfer(owner, address(0), id);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                       INTERNAL SAFE MINT LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function _safeMint(address to, uint256 id) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \\\"\\\") ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n\\n    function _safeMint(\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) internal virtual {\\n        _mint(to, id);\\n\\n        require(\\n            to.code.length == 0 ||\\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\\n                ERC721TokenReceiver.onERC721Received.selector,\\n            \\\"UNSAFE_RECIPIENT\\\"\\n        );\\n    }\\n}\\n\\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\\ninterface ERC721TokenReceiver {\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\"},\"ExitPayloadReader.sol\":{\"content\":\"pragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary ExitPayloadReader {\\n    using RLPReader for bytes;\\n    using RLPReader for RLPReader.RLPItem;\\n\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct ExitPayload {\\n        RLPReader.RLPItem[] data;\\n    }\\n\\n    struct Receipt {\\n        RLPReader.RLPItem[] data;\\n        bytes raw;\\n        uint256 logIndex;\\n    }\\n\\n    struct Log {\\n        RLPReader.RLPItem data;\\n        RLPReader.RLPItem[] list;\\n    }\\n\\n    struct LogTopics {\\n        RLPReader.RLPItem[] data;\\n    }\\n\\n    // copy paste of private copy() from RLPReader to avoid changing of existing contracts\\n    function copy(\\n        uint256 src,\\n        uint256 dest,\\n        uint256 len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len \\u003e= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    function toExitPayload(bytes memory data) internal pure returns (ExitPayload memory) {\\n        RLPReader.RLPItem[] memory payloadData = data.toRlpItem().toList();\\n\\n        return ExitPayload(payloadData);\\n    }\\n\\n    function getHeaderNumber(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[0].toUint();\\n    }\\n\\n    function getBlockProof(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[1].toBytes();\\n    }\\n\\n    function getBlockNumber(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[2].toUint();\\n    }\\n\\n    function getBlockTime(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[3].toUint();\\n    }\\n\\n    function getTxRoot(ExitPayload memory payload) internal pure returns (bytes32) {\\n        return bytes32(payload.data[4].toUint());\\n    }\\n\\n    function getReceiptRoot(ExitPayload memory payload) internal pure returns (bytes32) {\\n        return bytes32(payload.data[5].toUint());\\n    }\\n\\n    function getReceipt(ExitPayload memory payload) internal pure returns (Receipt memory receipt) {\\n        receipt.raw = payload.data[6].toBytes();\\n        RLPReader.RLPItem memory receiptItem = receipt.raw.toRlpItem();\\n\\n        if (receiptItem.isList()) {\\n            // legacy tx\\n            receipt.data = receiptItem.toList();\\n        } else {\\n            // pop first byte before parsting receipt\\n            bytes memory typedBytes = receipt.raw;\\n            bytes memory result = new bytes(typedBytes.length - 1);\\n            uint256 srcPtr;\\n            uint256 destPtr;\\n            assembly {\\n                srcPtr := add(33, typedBytes)\\n                destPtr := add(0x20, result)\\n            }\\n\\n            copy(srcPtr, destPtr, result.length);\\n            receipt.data = result.toRlpItem().toList();\\n        }\\n\\n        receipt.logIndex = getReceiptLogIndex(payload);\\n        return receipt;\\n    }\\n\\n    function getReceiptProof(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[7].toBytes();\\n    }\\n\\n    function getBranchMaskAsBytes(ExitPayload memory payload) internal pure returns (bytes memory) {\\n        return payload.data[8].toBytes();\\n    }\\n\\n    function getBranchMaskAsUint(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[8].toUint();\\n    }\\n\\n    function getReceiptLogIndex(ExitPayload memory payload) internal pure returns (uint256) {\\n        return payload.data[9].toUint();\\n    }\\n\\n    // Receipt methods\\n    function toBytes(Receipt memory receipt) internal pure returns (bytes memory) {\\n        return receipt.raw;\\n    }\\n\\n    function getLog(Receipt memory receipt) internal pure returns (Log memory) {\\n        RLPReader.RLPItem memory logData = receipt.data[3].toList()[receipt.logIndex];\\n        return Log(logData, logData.toList());\\n    }\\n\\n    // Log methods\\n    function getEmitter(Log memory log) internal pure returns (address) {\\n        return RLPReader.toAddress(log.list[0]);\\n    }\\n\\n    function getTopics(Log memory log) internal pure returns (LogTopics memory) {\\n        return LogTopics(log.list[1].toList());\\n    }\\n\\n    function getData(Log memory log) internal pure returns (bytes memory) {\\n        return log.list[2].toBytes();\\n    }\\n\\n    function toRlpBytes(Log memory log) internal pure returns (bytes memory) {\\n        return log.data.toRlpBytes();\\n    }\\n\\n    // LogTopics methods\\n    function getField(LogTopics memory topics, uint256 index) internal pure returns (RLPReader.RLPItem memory) {\\n        return topics.data[index];\\n    }\\n}\\n\"},\"FXBaseChildTunnel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// IFxMessageProcessor represents interface to process message\\ninterface IFxMessageProcessor {\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external;\\n}\\n\\n/**\\n * @notice Mock child tunnel contract to receive and send message from L2\\n */\\nabstract contract FxBaseChildTunnel is IFxMessageProcessor {\\n    // MessageTunnel on L1 will get data from this event\\n    event MessageSent(bytes message);\\n\\n    // fx child\\n    address public fxChild;\\n\\n    // fx root tunnel\\n    address public fxRootTunnel;\\n\\n    constructor(address _fxChild) {\\n        fxChild = _fxChild;\\n    }\\n\\n    // Sender must be fxRootTunnel in case of ERC20 tunnel\\n    modifier validateSender(address sender) {\\n        require(sender == fxRootTunnel, \\\"FxBaseChildTunnel: INVALID_SENDER_FROM_ROOT\\\");\\n        _;\\n    }\\n\\n    // set fxRootTunnel if not set already\\n    function setFxRootTunnel(address _fxRootTunnel) external {\\n        require(fxRootTunnel == address(0x0), \\\"FxBaseChildTunnel: ROOT_TUNNEL_ALREADY_SET\\\");\\n        fxRootTunnel = _fxRootTunnel;\\n    }\\n\\n    function processMessageFromRoot(\\n        uint256 stateId,\\n        address rootMessageSender,\\n        bytes calldata data\\n    ) external override {\\n        require(msg.sender == fxChild, \\\"FxBaseChildTunnel: INVALID_SENDER\\\");\\n        _processMessageFromRoot(stateId, rootMessageSender, data);\\n    }\\n\\n    /**\\n     * @notice Emit message that can be received on Root Tunnel\\n     * @dev Call the internal function when need to emit message\\n     * @param message bytes message that will be sent to Root Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToRoot(bytes memory message) internal {\\n        emit MessageSent(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Root Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param stateId unique state id\\n     * @param sender root message sender\\n     * @param message bytes message that was sent from Root Tunnel\\n     */\\n    function _processMessageFromRoot(\\n        uint256 stateId,\\n        address sender,\\n        bytes memory message\\n    ) internal virtual;\\n}\\n\"},\"FxBaseRootTunnel.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\nimport {MerklePatriciaProof} from \\\"./MerklePatriciaProof.sol\\\";\\nimport {Merkle} from \\\"./Merkle.sol\\\";\\nimport \\\"./ExitPayloadReader.sol\\\";\\n\\ninterface IFxStateSender {\\n    function sendMessageToChild(address _receiver, bytes calldata _data) external;\\n}\\n\\ncontract ICheckpointManager {\\n    struct HeaderBlock {\\n        bytes32 root;\\n        uint256 start;\\n        uint256 end;\\n        uint256 createdAt;\\n        address proposer;\\n    }\\n\\n    /**\\n     * @notice mapping of checkpoint header numbers to block details\\n     * @dev These checkpoints are submited by plasma contracts\\n     */\\n    mapping(uint256 =\\u003e HeaderBlock) public headerBlocks;\\n}\\n\\nabstract contract FxBaseRootTunnel {\\n    using RLPReader for RLPReader.RLPItem;\\n    using Merkle for bytes32;\\n    using ExitPayloadReader for bytes;\\n    using ExitPayloadReader for ExitPayloadReader.ExitPayload;\\n    using ExitPayloadReader for ExitPayloadReader.Log;\\n    using ExitPayloadReader for ExitPayloadReader.LogTopics;\\n    using ExitPayloadReader for ExitPayloadReader.Receipt;\\n\\n    // keccak256(MessageSent(bytes))\\n    bytes32 public constant SEND_MESSAGE_EVENT_SIG = 0x8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b036;\\n\\n    // state sender contract\\n    IFxStateSender public fxRoot;\\n    // root chain manager\\n    ICheckpointManager public checkpointManager;\\n    // child tunnel contract which receives and sends messages\\n    address public fxChildTunnel;\\n\\n    // storage to avoid duplicate exits\\n    mapping(bytes32 =\\u003e bool) public processedExits;\\n\\n    constructor(address _checkpointManager, address _fxRoot) {\\n        checkpointManager = ICheckpointManager(_checkpointManager);\\n        fxRoot = IFxStateSender(_fxRoot);\\n    }\\n\\n    // set fxChildTunnel if not set already\\n    function setFxChildTunnel(address _fxChildTunnel) public {\\n        require(fxChildTunnel == address(0x0), \\\"FxBaseRootTunnel: CHILD_TUNNEL_ALREADY_SET\\\");\\n        fxChildTunnel = _fxChildTunnel;\\n    }\\n\\n    /**\\n     * @notice Send bytes message to Child Tunnel\\n     * @param message bytes message that will be sent to Child Tunnel\\n     * some message examples -\\n     *   abi.encode(tokenId);\\n     *   abi.encode(tokenId, tokenMetadata);\\n     *   abi.encode(messageType, messageData);\\n     */\\n    function _sendMessageToChild(bytes memory message) internal {\\n        fxRoot.sendMessageToChild(fxChildTunnel, message);\\n    }\\n\\n    function _validateAndExtractMessage(bytes memory inputData) internal returns (bytes memory) {\\n        ExitPayloadReader.ExitPayload memory payload = inputData.toExitPayload();\\n\\n        bytes memory branchMaskBytes = payload.getBranchMaskAsBytes();\\n        uint256 blockNumber = payload.getBlockNumber();\\n        // checking if exit has already been processed\\n        // unique exit is identified using hash of (blockNumber, branchMask, receiptLogIndex)\\n        bytes32 exitHash = keccak256(\\n            abi.encodePacked(\\n                blockNumber,\\n                // first 2 nibbles are dropped while generating nibble array\\n                // this allows branch masks that are valid but bypass exitHash check (changing first 2 nibbles only)\\n                // so converting to nibble array and then hashing it\\n                MerklePatriciaProof._getNibbleArray(branchMaskBytes),\\n                payload.getReceiptLogIndex()\\n            )\\n        );\\n        require(processedExits[exitHash] == false, \\\"FxRootTunnel: EXIT_ALREADY_PROCESSED\\\");\\n        processedExits[exitHash] = true;\\n\\n        ExitPayloadReader.Receipt memory receipt = payload.getReceipt();\\n        ExitPayloadReader.Log memory log = receipt.getLog();\\n\\n        // check child tunnel\\n        require(fxChildTunnel == log.getEmitter(), \\\"FxRootTunnel: INVALID_FX_CHILD_TUNNEL\\\");\\n\\n        bytes32 receiptRoot = payload.getReceiptRoot();\\n        // verify receipt inclusion\\n        require(\\n            MerklePatriciaProof.verify(receipt.toBytes(), branchMaskBytes, payload.getReceiptProof(), receiptRoot),\\n            \\\"FxRootTunnel: INVALID_RECEIPT_PROOF\\\"\\n        );\\n\\n        // verify checkpoint inclusion\\n        _checkBlockMembershipInCheckpoint(\\n            blockNumber,\\n            payload.getBlockTime(),\\n            payload.getTxRoot(),\\n            receiptRoot,\\n            payload.getHeaderNumber(),\\n            payload.getBlockProof()\\n        );\\n\\n        ExitPayloadReader.LogTopics memory topics = log.getTopics();\\n\\n        require(\\n            bytes32(topics.getField(0).toUint()) == SEND_MESSAGE_EVENT_SIG, // topic0 is event sig\\n            \\\"FxRootTunnel: INVALID_SIGNATURE\\\"\\n        );\\n\\n        // received message data\\n        bytes memory message = abi.decode(log.getData(), (bytes)); // event decodes params again, so decoding bytes to get message\\n        return message;\\n    }\\n\\n    function _checkBlockMembershipInCheckpoint(\\n        uint256 blockNumber,\\n        uint256 blockTime,\\n        bytes32 txRoot,\\n        bytes32 receiptRoot,\\n        uint256 headerNumber,\\n        bytes memory blockProof\\n    ) private view returns (uint256) {\\n        (bytes32 headerRoot, uint256 startBlock, , uint256 createdAt, ) = checkpointManager.headerBlocks(headerNumber);\\n\\n        require(\\n            keccak256(abi.encodePacked(blockNumber, blockTime, txRoot, receiptRoot)).checkMembership(\\n                blockNumber - startBlock,\\n                headerRoot,\\n                blockProof\\n            ),\\n            \\\"FxRootTunnel: INVALID_HEADER\\\"\\n        );\\n        return createdAt;\\n    }\\n\\n    /**\\n     * @notice receive message from  L2 to L1, validated by proof\\n     * @dev This function verifies if the transaction actually happened on child chain\\n     *\\n     * @param inputData RLP encoded data of the reference tx containing following list of fields\\n     *  0 - headerNumber - Checkpoint header block number containing the reference tx\\n     *  1 - blockProof - Proof that the block header (in the child chain) is a leaf in the submitted merkle root\\n     *  2 - blockNumber - Block number containing the reference tx on child chain\\n     *  3 - blockTime - Reference tx block time\\n     *  4 - txRoot - Transactions root of block\\n     *  5 - receiptRoot - Receipts root of block\\n     *  6 - receipt - Receipt of the reference transaction\\n     *  7 - receiptProof - Merkle proof of the reference receipt\\n     *  8 - branchMask - 32 bits denoting the path of receipt in merkle tree\\n     *  9 - receiptLogIndex - Log Index to read from the receipt\\n     */\\n    function receiveMessage(bytes memory inputData) public virtual {\\n        bytes memory message = _validateAndExtractMessage(inputData);\\n        _processMessageFromChild(message);\\n    }\\n\\n    /**\\n     * @notice Process message received from Child Tunnel\\n     * @dev function needs to be implemented to handle message as per requirement\\n     * This is called by onStateReceive function.\\n     * Since it is called via a system call, any event will not be emitted during its execution.\\n     * @param message bytes message that was sent from Child Tunnel\\n     */\\n    function _processMessageFromChild(bytes memory message) internal virtual;\\n}\\n\"},\"LlamaZoo.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport \\\"./ERC1155.sol\\\";\\nimport \\\"./SpitToken.sol\\\";\\nimport \\\"./ERC721.sol\\\";\\nimport \\\"./FxBaseRootTunnel.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n   __ _                                               \\n  / /| | __ _ _ __ ___   __ _/\\\\   /\\\\___ _ __ ___  ___ \\n / / | |/ _` | \\u0027_ ` _ \\\\ / _` \\\\ \\\\ / / _ \\\\ \\u0027__/ __|/ _ \\\\\\n/ /__| | (_| | | | | | | (_| |\\\\ V /  __/ |  \\\\__ \\\\  __/\\n\\\\____/_|\\\\__,_|_| |_| |_|\\\\__,_| \\\\_/ \\\\___|_|  |___/\\\\___|\\n\\n**/\\n\\n/// @title Llama Zoo\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\n\\ncontract LlamaZoo is FxBaseRootTunnel, Ownable {\\n    /*///////////////////////////////////////////////////////////////\\n                            STORAGE\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice ERC721 instance of the PixelatedLlama contract.\\n    ERC721 public pixellatedLlamaContract;\\n    /// @notice ERC721 instance of the LlamaDraws contract.\\n    ERC721 public llamaDrawsContract;\\n    /// @notice ERC1155 instance of the StakingBoost contract.\\n    ERC1155 public boostContract;\\n    /// @notice ERC1155 instance of the Pixlet contract.\\n    ERC1155 public pixletContract;\\n\\n    struct Staker {\\n        uint256[] stakedLlamas;\\n        uint256 stakedPixletCanvas;\\n        uint256 stakedLlamaDraws;\\n        uint128 stakedSilverBoosts;\\n        uint128 stakedGoldBoosts;\\n    }\\n\\n    mapping(address =\\u003e Staker) public userInfo;\\n\\n    bool public stakingPaused;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n    constructor(\\n        address checkpointManager,\\n        address fxRoot,\\n        address _pixellatedLlamaContract,\\n        address _llamaDrawsContract,\\n        address _boostContract,\\n        address _pixletContract\\n    ) FxBaseRootTunnel(checkpointManager, fxRoot) {\\n        pixellatedLlamaContract = ERC721(_pixellatedLlamaContract);\\n        llamaDrawsContract = ERC721(_llamaDrawsContract);\\n        boostContract = ERC1155(_boostContract);\\n        pixletContract = ERC1155(_pixletContract);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        CONTRACT SETTERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Set the contract addresses for all contract instances.\\n    /// @param _pixellatedLlamaContract The contract address of PixellatedLlama.\\n    /// @param _llamaDrawsContract The contract address of LlamaDraws.\\n    /// @param _boostContract The contract address of RewardBooster.\\n    /// @param _pixletContract The contract address of the Pixlet contract.\\n    function setContractAddresses(\\n        address _pixellatedLlamaContract,\\n        address _llamaDrawsContract,\\n        address _boostContract,\\n        address _pixletContract\\n    ) public onlyOwner {\\n        pixellatedLlamaContract = ERC721(_pixellatedLlamaContract);\\n        llamaDrawsContract = ERC721(_llamaDrawsContract);\\n        boostContract = ERC1155(_boostContract);\\n        pixletContract = ERC1155(_pixletContract);\\n    }\\n\\n    /// @notice Pauses staking and unstaking, for emergency purposes\\n    /// @dev If we have to migrate because of Polygon instability or state sync issues, this will save us\\n    function setStakingPaused(bool paused) public onlyOwner {\\n        stakingPaused = paused;\\n    }\\n\\n    /// @notice For collab.land to give a role based on staking status\\n    function balanceOf(address owner) public view returns (uint256) {\\n        uint[] memory llamas = userInfo[owner].stakedLlamas;\\n        if(llamas.length == 0) return 0;\\n        for (uint256 i = 0; i \\u003c llamas.length; i++) {\\n           if(llamas[i] \\u003c 500) return 1;\\n        }\\n        return 2;\\n    }\\n\\n    /// @dev Using the mapping directly wasn\\u0027t returning the array, so we made this helper fuction.\\n    function getStakedTokens(address user)\\n        public\\n        view\\n        returns (\\n            uint256[] memory llamas,\\n            uint256 pixletCanvas,\\n            uint256 llamaDraws,\\n            uint128 silverBoosts,\\n            uint128 goldBoosts\\n        )\\n    {\\n        Staker memory staker = userInfo[user];\\n        return (\\n            staker.stakedLlamas,\\n            staker.stakedPixletCanvas,\\n            staker.stakedLlamaDraws,\\n            staker.stakedSilverBoosts,\\n            staker.stakedGoldBoosts\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        UTILITY STAKING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function bulkStake(\\n        uint256[] memory llamas,\\n        uint128 silverBoosts,\\n        uint128 goldBoosts,\\n        uint256 pixletStudio,\\n        uint256 llamaDraws\\n    ) public {\\n        if (llamas.length \\u003e 0) stakeMultipleLlamas(llamas);\\n        stakeBoosts(silverBoosts, goldBoosts);\\n        if (pixletStudio != 0) stakePixletCanvas(pixletStudio);\\n        if (llamaDraws != 0) stakeLlamaDraws(llamaDraws);\\n    }\\n\\n    function bulkUnstake(\\n        uint256[] memory llamas,\\n        uint128 silverBoosts,\\n        uint128 goldBoosts,\\n        bool pixletStudio,\\n        bool llamaDraws\\n    ) public {\\n        if (llamas.length \\u003e 0) unstakeMultipleLlamas(llamas);\\n        unstakeBoosts(silverBoosts, goldBoosts);\\n        if (pixletStudio) unstakePixletCanvas();\\n        if (llamaDraws) unstakeLlamaDraws();\\n    }\\n\\n    function stakeMultipleLlamas(uint256[] memory tokenIds) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        uint256 animatedCount = 0;\\n        Staker storage staker = userInfo[msg.sender];\\n        for (uint256 i = 0; i \\u003c tokenIds.length; i++) {\\n            if (tokenIds[i] \\u003c 500) ++animatedCount;\\n            staker.stakedLlamas.push(tokenIds[i]);\\n            pixellatedLlamaContract.transferFrom(\\n                msg.sender,\\n                address(this),\\n                tokenIds[i]\\n            );\\n        }\\n        if (animatedCount \\u003e 0) {\\n            _sendMessageToChild(\\n                abi.encode(\\n                    msg.sender,\\n                    uint256(TokenType.AnimatedLlama),\\n                    animatedCount,\\n                    true\\n                )\\n            );\\n        }\\n        if ((tokenIds.length - animatedCount) \\u003e 0) {\\n            _sendMessageToChild(\\n                abi.encode(\\n                    msg.sender,\\n                    uint256(TokenType.StaticLlama),\\n                    tokenIds.length - animatedCount,\\n                    true\\n                )\\n            );\\n        }\\n    }\\n\\n    function unstakeMultipleLlamas(uint256[] memory tokenIds) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        uint256 animatedCount = 0;\\n        Staker storage staker = userInfo[msg.sender];\\n        for (uint256 i = 0; i \\u003c tokenIds.length; i++) {\\n            uint256 tokenId = tokenIds[i];\\n            require(containsElement(staker.stakedLlamas, tokenId), \\\"You do not own this llama.\\\");\\n            if (tokenId \\u003c 500) ++animatedCount;\\n            pixellatedLlamaContract.transferFrom(\\n                address(this),\\n                msg.sender,\\n                tokenId\\n            );\\n\\n            uint256[] memory stakedLlamas = staker.stakedLlamas;\\n            uint256 index;\\n            for (uint256 j; j \\u003c stakedLlamas.length; j++) {\\n                if (stakedLlamas[j] == tokenId) index = j;\\n            }\\n            if (stakedLlamas[index] == tokenId) {\\n                staker.stakedLlamas[index] = stakedLlamas[\\n                    staker.stakedLlamas.length - 1\\n                ];\\n                staker.stakedLlamas.pop();\\n            }\\n        }\\n\\n        if (animatedCount \\u003e 0) {\\n            _sendMessageToChild(\\n                abi.encode(\\n                    msg.sender,\\n                    uint256(TokenType.AnimatedLlama),\\n                    animatedCount,\\n                    false\\n                )\\n            );\\n        }\\n        if ((tokenIds.length - animatedCount) \\u003e 0) {\\n            _sendMessageToChild(\\n                abi.encode(\\n                    msg.sender,\\n                    uint256(TokenType.StaticLlama),\\n                    tokenIds.length - animatedCount,\\n                    false\\n                )\\n            );\\n        }\\n    }\\n\\n    /// @notice Stake a LlamaVerse llama.\\n    /// @param tokenId The tokenId of the llama to stake\\n    function stakeLlama(uint256 tokenId) external {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        bool animated = tokenId \\u003c 500;\\n        Staker storage staker = userInfo[msg.sender];\\n        staker.stakedLlamas.push(tokenId);\\n        pixellatedLlamaContract.transferFrom(\\n            msg.sender,\\n            address(this),\\n            tokenId\\n        );\\n        _sendMessageToChild(\\n            abi.encode(\\n                msg.sender,\\n                uint256(\\n                    animated ? TokenType.AnimatedLlama : TokenType.StaticLlama\\n                ),\\n                1,\\n                true\\n            )\\n        );\\n    }\\n\\n    /// @notice Unstake a LlamaVerse llama.\\n    /// @param tokenId The tokenId of the llama to unstake\\n    function unstakeLlama(uint256 tokenId) external {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        bool animated = tokenId \\u003c 500;\\n        Staker storage staker = userInfo[msg.sender];\\n        require(containsElement(staker.stakedLlamas, tokenId), \\\"You do not own this llama.\\\");\\n\\n        pixellatedLlamaContract.transferFrom(\\n            address(this),\\n            msg.sender,\\n            tokenId\\n        );\\n\\n        uint256[] memory stakedLlamas = staker.stakedLlamas;\\n        uint256 index;\\n        for (uint256 i; i \\u003c stakedLlamas.length; i++) {\\n            if (stakedLlamas[i] == tokenId) index = i;\\n        }\\n        if (stakedLlamas[index] == tokenId) {\\n            _sendMessageToChild(\\n                abi.encode(\\n                    msg.sender,\\n                    uint256(\\n                        animated\\n                            ? TokenType.AnimatedLlama\\n                            : TokenType.StaticLlama\\n                    ),\\n                    1,\\n                    false\\n                )\\n            );\\n            staker.stakedLlamas[index] = stakedLlamas[\\n                staker.stakedLlamas.length - 1\\n            ];\\n            staker.stakedLlamas.pop();\\n        }\\n    }\\n\\n    /// @notice Stake silver boosts.\\n    /// @param amount The amount of boosts to stake.\\n    function stakeSilverBoosts(uint128 amount) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(amount != 0, \\\"Staking 0 is not allowed.\\\");\\n\\n        userInfo[msg.sender].stakedSilverBoosts += amount;\\n        boostContract.safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            2,\\n            amount,\\n            \\\"\\\"\\n        );\\n        _sendMessageToChild(\\n            abi.encode(msg.sender, uint256(TokenType.SilverBoost), amount, true)\\n        );\\n    }\\n\\n    /// @notice Unstake silver boosts.\\n    /// @param amount The amount of boosts to unstake.\\n    function unstakeSilverBoosts(uint128 amount) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(amount != 0, \\\"Unstaking 0 is not allowed.\\\");\\n\\n        userInfo[msg.sender].stakedSilverBoosts -= amount;\\n        boostContract.safeTransferFrom(\\n            address(this),\\n            msg.sender,\\n            2,\\n            amount,\\n            \\\"\\\"\\n        );\\n        _sendMessageToChild(\\n            abi.encode(\\n                msg.sender,\\n                uint256(TokenType.SilverBoost),\\n                amount,\\n                false\\n            )\\n        );\\n    }\\n\\n    /// @notice Stake gold boosts with the requested tokenID.\\n    /// @param amount The amount of boosts to stake.\\n    function stakeGoldBoosts(uint128 amount) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(amount != 0, \\\"Staking 0 is not allowed.\\\");\\n        userInfo[msg.sender].stakedGoldBoosts += amount;\\n        boostContract.safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            1,\\n            amount,\\n            \\\"\\\"\\n        );\\n        _sendMessageToChild(\\n            abi.encode(msg.sender, uint256(TokenType.GoldBoost), amount, true)\\n        );\\n    }\\n\\n    /// @notice Unstake gold boosts with the requested tokenID.\\n    /// @param amount The amount of boosts to stake.\\n    function unstakeGoldBoosts(uint128 amount) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(amount != 0, \\\"Unstaking 0 is not allowed.\\\");\\n        userInfo[msg.sender].stakedGoldBoosts -= amount;\\n        boostContract.safeTransferFrom(\\n            address(this),\\n            msg.sender,\\n            1,\\n            amount,\\n            \\\"\\\"\\n        );\\n        _sendMessageToChild(\\n            abi.encode(msg.sender, uint256(TokenType.GoldBoost), amount, false)\\n        );\\n    }\\n\\n    function stakeBoosts(uint128 silverAmount, uint128 goldAmount) public {\\n        if (silverAmount != 0) stakeSilverBoosts(silverAmount);\\n        if (goldAmount != 0) stakeGoldBoosts(goldAmount);\\n    }\\n\\n    function unstakeBoosts(uint128 silverAmount, uint128 goldAmount) public {\\n        if (silverAmount != 0) unstakeSilverBoosts(silverAmount);\\n        if (goldAmount != 0) unstakeGoldBoosts(goldAmount);\\n    }\\n\\n    /// @notice Stake a Pixlet Canvas with the requested tokenID.\\n    /// @param tokenId The token ID of the pixlet canvas to stake.\\n    function stakePixletCanvas(uint256 tokenId) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(\\n            userInfo[msg.sender].stakedPixletCanvas == 0,\\n            \\\"You already have a pixlet canvas staked.\\\"\\n        );\\n\\n        userInfo[msg.sender].stakedPixletCanvas = tokenId;\\n        pixletContract.safeTransferFrom(\\n            msg.sender,\\n            address(this),\\n            tokenId,\\n            1,\\n            \\\"\\\"\\n        );\\n\\n        _sendMessageToChild(\\n            abi.encode(msg.sender, uint256(TokenType.PixletCanvas), 1, true)\\n        );\\n    }\\n\\n    /// @notice Unstake your Pixlet Canvas.\\n    function unstakePixletCanvas() public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(\\n            userInfo[msg.sender].stakedPixletCanvas != 0,\\n            \\\"You do not have a pixlet canvas staked.\\\"\\n        );\\n\\n        pixletContract.safeTransferFrom(\\n            address(this),\\n            msg.sender,\\n            userInfo[msg.sender].stakedPixletCanvas,\\n            1,\\n            \\\"\\\"\\n        );\\n        userInfo[msg.sender].stakedPixletCanvas = 0;\\n\\n        _sendMessageToChild(\\n            abi.encode(msg.sender, uint256(TokenType.PixletCanvas), 1, false)\\n        );\\n    }\\n\\n    /// @notice Stake a Llamadraws.\\n    /// @param tokenId The token ID of the llamadraws to stake.\\n    function stakeLlamaDraws(uint256 tokenId) public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(\\n            userInfo[msg.sender].stakedLlamaDraws == 0,\\n            \\\"You already have a llamadraws staked.\\\"\\n        );\\n\\n        userInfo[msg.sender].stakedLlamaDraws = tokenId;\\n        llamaDrawsContract.transferFrom(msg.sender, address(this), tokenId);\\n\\n        _sendMessageToChild(\\n            abi.encode(msg.sender, uint256(TokenType.LlamaDraws), 1, true)\\n        );\\n    }\\n\\n    /// @notice Unstake your Llamadraws.\\n    function unstakeLlamaDraws() public {\\n        require(!stakingPaused, \\\"Staking is currently paused.\\\");\\n        require(\\n            userInfo[msg.sender].stakedLlamaDraws != 0,\\n            \\\"You do not have a llamadraws staked.\\\"\\n        );\\n\\n        llamaDrawsContract.transferFrom(\\n            address(this),\\n            msg.sender,\\n            userInfo[msg.sender].stakedLlamaDraws\\n        );\\n        userInfo[msg.sender].stakedLlamaDraws = 0;\\n\\n        _sendMessageToChild(\\n            abi.encode(msg.sender, uint256(TokenType.LlamaDraws), 1, false)\\n        );\\n    }\\n\\n    function _processMessageFromChild(bytes memory message) internal override {\\n        // We don\\u0027t need a message from child\\n    }\\n\\n    function containsElement(uint[] memory elements, uint tokenId) internal returns (bool) {\\n        for (uint256 i = 0; i \\u003c elements.length; i++) {\\n           if(elements[i] == tokenId) return true;\\n        }\\n        return false;\\n    }\\n\\n\\n    /*///////////////////////////////////////////////////////////////\\n                        ERC ON RECEIVED LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        bytes calldata data\\n    ) external returns (bytes4) {\\n        return ERC721TokenReceiver.onERC721Received.selector;\\n    }\\n\\n    /**\\n     * @notice Handle the receipt of a single ERC1155 token type.\\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeTransferFrom` after the balance has been updated.\\n     * This function MAY throw to revert and reject the transfer.\\n     * Return of other amount than the magic value MUST result in the transaction being reverted.\\n     * Note: The token contract address is always the message sender.\\n     * @param operator  The address which called the `safeTransferFrom` function.\\n     * @param from      The address which previously owned the token.\\n     * @param id        The id of the token being transferred.\\n     * @param amount    The amount of tokens being transferred.\\n     * @param data      Additional data with no specified format.\\n     * @return           `bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"))`.\\n     */\\n    function onERC1155Received(\\n        address operator,\\n        address from,\\n        uint256 id,\\n        uint256 amount,\\n        bytes calldata data\\n    ) external returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155Received.selector;\\n    }\\n\\n    /**\\n     * @notice Handle the receipt of multiple ERC1155 token types.\\n     * @dev An ERC1155-compliant smart contract MUST call this function on the token recipient contract, at the end of a `safeBatchTransferFrom` after the balances have been updated.\\n     * This function MAY throw to revert and reject the transfer.\\n     * Return of other amount than the magic value WILL result in the transaction being reverted.\\n     * Note: The token contract address is always the message sender.\\n     * @param operator  The address which called the `safeBatchTransferFrom` function.\\n     * @param from      The address which previously owned the token.\\n     * @param ids       An array containing ids of each token being transferred.\\n     * @param amounts   An array containing amounts of each token being transferred.\\n     * @param data      Additional data with no specified format.\\n     * @return           `bytes4(keccak256(\\\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\\\"))`.\\n     */\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        uint256[] calldata amounts,\\n        bytes calldata data\\n    ) external returns (bytes4) {\\n        return ERC1155TokenReceiver.onERC1155BatchReceived.selector;\\n    }\\n}\\n\"},\"Merkle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nlibrary Merkle {\\n    function checkMembership(\\n        bytes32 leaf,\\n        uint256 index,\\n        bytes32 rootHash,\\n        bytes memory proof\\n    ) internal pure returns (bool) {\\n        require(proof.length % 32 == 0, \\\"Invalid proof length\\\");\\n        uint256 proofHeight = proof.length / 32;\\n        // Proof of size n means, height of the tree is n+1.\\n        // In a tree of height n+1, max #leafs possible is 2 ^ n\\n        require(index \\u003c 2**proofHeight, \\\"Leaf index is too big\\\");\\n\\n        bytes32 proofElement;\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 32; i \\u003c= proof.length; i += 32) {\\n            assembly {\\n                proofElement := mload(add(proof, i))\\n            }\\n\\n            if (index % 2 == 0) {\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n\\n            index = index / 2;\\n        }\\n        return computedHash == rootHash;\\n    }\\n}\\n\"},\"MerklePatriciaProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport {RLPReader} from \\\"./RLPReader.sol\\\";\\n\\nlibrary MerklePatriciaProof {\\n    /*\\n     * @dev Verifies a merkle patricia proof.\\n     * @param value The terminating value in the trie.\\n     * @param encodedPath The path in the trie leading to value.\\n     * @param rlpParentNodes The rlp encoded stack of nodes.\\n     * @param root The root hash of the trie.\\n     * @return The boolean validity of the proof.\\n     */\\n    function verify(\\n        bytes memory value,\\n        bytes memory encodedPath,\\n        bytes memory rlpParentNodes,\\n        bytes32 root\\n    ) internal pure returns (bool) {\\n        RLPReader.RLPItem memory item = RLPReader.toRlpItem(rlpParentNodes);\\n        RLPReader.RLPItem[] memory parentNodes = RLPReader.toList(item);\\n\\n        bytes memory currentNode;\\n        RLPReader.RLPItem[] memory currentNodeList;\\n\\n        bytes32 nodeKey = root;\\n        uint256 pathPtr = 0;\\n\\n        bytes memory path = _getNibbleArray(encodedPath);\\n        if (path.length == 0) {\\n            return false;\\n        }\\n\\n        for (uint256 i = 0; i \\u003c parentNodes.length; i++) {\\n            if (pathPtr \\u003e path.length) {\\n                return false;\\n            }\\n\\n            currentNode = RLPReader.toRlpBytes(parentNodes[i]);\\n            if (nodeKey != keccak256(currentNode)) {\\n                return false;\\n            }\\n            currentNodeList = RLPReader.toList(parentNodes[i]);\\n\\n            if (currentNodeList.length == 17) {\\n                if (pathPtr == path.length) {\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[16])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                uint8 nextPathNibble = uint8(path[pathPtr]);\\n                if (nextPathNibble \\u003e 16) {\\n                    return false;\\n                }\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[nextPathNibble]));\\n                pathPtr += 1;\\n            } else if (currentNodeList.length == 2) {\\n                uint256 traversed = _nibblesToTraverse(RLPReader.toBytes(currentNodeList[0]), path, pathPtr);\\n                if (pathPtr + traversed == path.length) {\\n                    //leaf node\\n                    if (keccak256(RLPReader.toBytes(currentNodeList[1])) == keccak256(value)) {\\n                        return true;\\n                    } else {\\n                        return false;\\n                    }\\n                }\\n\\n                //extension node\\n                if (traversed == 0) {\\n                    return false;\\n                }\\n\\n                pathPtr += traversed;\\n                nodeKey = bytes32(RLPReader.toUintStrict(currentNodeList[1]));\\n            } else {\\n                return false;\\n            }\\n        }\\n    }\\n\\n    function _nibblesToTraverse(\\n        bytes memory encodedPartialPath,\\n        bytes memory path,\\n        uint256 pathPtr\\n    ) private pure returns (uint256) {\\n        uint256 len = 0;\\n        // encodedPartialPath has elements that are each two hex characters (1 byte), but partialPath\\n        // and slicedPath have elements that are each one hex character (1 nibble)\\n        bytes memory partialPath = _getNibbleArray(encodedPartialPath);\\n        bytes memory slicedPath = new bytes(partialPath.length);\\n\\n        // pathPtr counts nibbles in path\\n        // partialPath.length is a number of nibbles\\n        for (uint256 i = pathPtr; i \\u003c pathPtr + partialPath.length; i++) {\\n            bytes1 pathNibble = path[i];\\n            slicedPath[i - pathPtr] = pathNibble;\\n        }\\n\\n        if (keccak256(partialPath) == keccak256(slicedPath)) {\\n            len = partialPath.length;\\n        } else {\\n            len = 0;\\n        }\\n        return len;\\n    }\\n\\n    // bytes b must be hp encoded\\n    function _getNibbleArray(bytes memory b) internal pure returns (bytes memory) {\\n        bytes memory nibbles = \\\"\\\";\\n        if (b.length \\u003e 0) {\\n            uint8 offset;\\n            uint8 hpNibble = uint8(_getNthNibbleOfBytes(0, b));\\n            if (hpNibble == 1 || hpNibble == 3) {\\n                nibbles = new bytes(b.length * 2 - 1);\\n                bytes1 oddNibble = _getNthNibbleOfBytes(1, b);\\n                nibbles[0] = oddNibble;\\n                offset = 1;\\n            } else {\\n                nibbles = new bytes(b.length * 2 - 2);\\n                offset = 0;\\n            }\\n\\n            for (uint256 i = offset; i \\u003c nibbles.length; i++) {\\n                nibbles[i] = _getNthNibbleOfBytes(i - offset + 2, b);\\n            }\\n        }\\n        return nibbles;\\n    }\\n\\n    function _getNthNibbleOfBytes(uint256 n, bytes memory str) private pure returns (bytes1) {\\n        return bytes1(n % 2 == 0 ? uint8(str[n / 2]) / 0x10 : uint8(str[n / 2]) % 0x10);\\n    }\\n}\\n\"},\"Ownable.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.10;\\n\\nerror NotOwner();\\n\\n// https://github.com/m1guelpf/erc721-drop/blob/main/src/LilOwnable.sol\\nabstract contract Ownable {\\n    address internal _owner;\\n\\n    event OwnershipTransferred(\\n        address indexed previousOwner,\\n        address indexed newOwner\\n    );\\n\\n    modifier onlyOwner() {\\n        require(_owner == msg.sender);\\n        _;\\n    }\\n\\n    constructor() {\\n        _owner = msg.sender;\\n    }\\n\\n    function owner() external view returns (address) {\\n        return _owner;\\n    }\\n\\n    function transferOwnership(address _newOwner) external {\\n        if (msg.sender != _owner) revert NotOwner();\\n\\n        _owner = _newOwner;\\n    }\\n\\n    function renounceOwnership() public {\\n        if (msg.sender != _owner) revert NotOwner();\\n\\n        _owner = address(0);\\n    }\\n\\n    function supportsInterface(bytes4 interfaceId)\\n        public\\n        pure\\n        virtual\\n        returns (bool)\\n    {\\n        return interfaceId == 0x7f5828d0; // ERC165 Interface ID for ERC173\\n    }\\n}\\n\"},\"RLPReader.sol\":{\"content\":\"/*\\n * @author Hamdi Allam hamdi.allam97@gmail.com\\n * Please reach out with any questions or concerns\\n */\\npragma solidity ^0.8.0;\\n\\nlibrary RLPReader {\\n    uint8 constant STRING_SHORT_START = 0x80;\\n    uint8 constant STRING_LONG_START = 0xb8;\\n    uint8 constant LIST_SHORT_START = 0xc0;\\n    uint8 constant LIST_LONG_START = 0xf8;\\n    uint8 constant WORD_SIZE = 32;\\n\\n    struct RLPItem {\\n        uint256 len;\\n        uint256 memPtr;\\n    }\\n\\n    struct Iterator {\\n        RLPItem item; // Item that\\u0027s being iterated over.\\n        uint256 nextPtr; // Position of the next item in the list.\\n    }\\n\\n    /*\\n     * @dev Returns the next element in the iteration. Reverts if it has not next element.\\n     * @param self The iterator.\\n     * @return The next element in the iteration.\\n     */\\n    function next(Iterator memory self) internal pure returns (RLPItem memory) {\\n        require(hasNext(self));\\n\\n        uint256 ptr = self.nextPtr;\\n        uint256 itemLength = _itemLength(ptr);\\n        self.nextPtr = ptr + itemLength;\\n\\n        return RLPItem(itemLength, ptr);\\n    }\\n\\n    /*\\n     * @dev Returns true if the iteration has more elements.\\n     * @param self The iterator.\\n     * @return true if the iteration has more elements.\\n     */\\n    function hasNext(Iterator memory self) internal pure returns (bool) {\\n        RLPItem memory item = self.item;\\n        return self.nextPtr \\u003c item.memPtr + item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\\n        uint256 memPtr;\\n        assembly {\\n            memPtr := add(item, 0x20)\\n        }\\n\\n        return RLPItem(item.length, memPtr);\\n    }\\n\\n    /*\\n     * @dev Create an iterator. Reverts if item is not a list.\\n     * @param self The RLP item.\\n     * @return An \\u0027Iterator\\u0027 over the item.\\n     */\\n    function iterator(RLPItem memory self) internal pure returns (Iterator memory) {\\n        require(isList(self));\\n\\n        uint256 ptr = self.memPtr + _payloadOffset(self.memPtr);\\n        return Iterator(self, ptr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function rlpLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len;\\n    }\\n\\n    /*\\n     * @param item RLP encoded bytes\\n     */\\n    function payloadLen(RLPItem memory item) internal pure returns (uint256) {\\n        return item.len - _payloadOffset(item.memPtr);\\n    }\\n\\n    /*\\n     * @param item RLP encoded list in bytes\\n     */\\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory) {\\n        require(isList(item));\\n\\n        uint256 items = numItems(item);\\n        RLPItem[] memory result = new RLPItem[](items);\\n\\n        uint256 memPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 dataLen;\\n        for (uint256 i = 0; i \\u003c items; i++) {\\n            dataLen = _itemLength(memPtr);\\n            result[i] = RLPItem(dataLen, memPtr);\\n            memPtr = memPtr + dataLen;\\n        }\\n\\n        return result;\\n    }\\n\\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\\n    function isList(RLPItem memory item) internal pure returns (bool) {\\n        if (item.len == 0) return false;\\n\\n        uint8 byte0;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c LIST_SHORT_START) return false;\\n        return true;\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toRlpBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of RLP encoded bytes.\\n     */\\n    function rlpBytesKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        uint256 ptr = item.memPtr;\\n        uint256 len = item.len;\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(ptr, len)\\n        }\\n        return result;\\n    }\\n\\n    function payloadLocation(RLPItem memory item) internal pure returns (uint256, uint256) {\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 memPtr = item.memPtr + offset;\\n        uint256 len = item.len - offset; // data length\\n        return (memPtr, len);\\n    }\\n\\n    /*\\n     * @dev A cheaper version of keccak256(toBytes(item)) that avoids copying memory.\\n     * @return keccak256 hash of the item payload.\\n     */\\n    function payloadKeccak256(RLPItem memory item) internal pure returns (bytes32) {\\n        (uint256 memPtr, uint256 len) = payloadLocation(item);\\n        bytes32 result;\\n        assembly {\\n            result := keccak256(memPtr, len)\\n        }\\n        return result;\\n    }\\n\\n    /** RLPItem conversions into data types **/\\n\\n    // @returns raw rlp encoding in bytes\\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        bytes memory result = new bytes(item.len);\\n        if (result.length == 0) return result;\\n\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr, ptr, item.len);\\n        return result;\\n    }\\n\\n    // any non-zero byte is considered true\\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\\n        require(item.len == 1);\\n        uint256 result;\\n        uint256 memPtr = item.memPtr;\\n        assembly {\\n            result := byte(0, mload(memPtr))\\n        }\\n\\n        return result == 0 ? false : true;\\n    }\\n\\n    function toAddress(RLPItem memory item) internal pure returns (address) {\\n        // 1 byte for the length prefix\\n        require(item.len == 21);\\n\\n        return address(uint160(toUint(item)));\\n    }\\n\\n    function toUint(RLPItem memory item) internal pure returns (uint256) {\\n        require(item.len \\u003e 0 \\u0026\\u0026 item.len \\u003c= 33);\\n\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 len = item.len - offset;\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + offset;\\n        assembly {\\n            result := mload(memPtr)\\n\\n            // shfit to the correct location if neccesary\\n            if lt(len, 32) {\\n                result := div(result, exp(256, sub(32, len)))\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    // enforces 32 byte length\\n    function toUintStrict(RLPItem memory item) internal pure returns (uint256) {\\n        // one byte prefix\\n        require(item.len == 33);\\n\\n        uint256 result;\\n        uint256 memPtr = item.memPtr + 1;\\n        assembly {\\n            result := mload(memPtr)\\n        }\\n\\n        return result;\\n    }\\n\\n    function toBytes(RLPItem memory item) internal pure returns (bytes memory) {\\n        require(item.len \\u003e 0);\\n\\n        uint256 offset = _payloadOffset(item.memPtr);\\n        uint256 len = item.len - offset; // data length\\n        bytes memory result = new bytes(len);\\n\\n        uint256 destPtr;\\n        assembly {\\n            destPtr := add(0x20, result)\\n        }\\n\\n        copy(item.memPtr + offset, destPtr, len);\\n        return result;\\n    }\\n\\n    /*\\n     * Private Helpers\\n     */\\n\\n    // @return number of payload items inside an encoded list.\\n    function numItems(RLPItem memory item) private pure returns (uint256) {\\n        if (item.len == 0) return 0;\\n\\n        uint256 count = 0;\\n        uint256 currPtr = item.memPtr + _payloadOffset(item.memPtr);\\n        uint256 endPtr = item.memPtr + item.len;\\n        while (currPtr \\u003c endPtr) {\\n            currPtr = currPtr + _itemLength(currPtr); // skip over an item\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n\\n    // @return entire rlp item byte length\\n    function _itemLength(uint256 memPtr) private pure returns (uint256) {\\n        uint256 itemLen;\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c STRING_SHORT_START) itemLen = 1;\\n        else if (byte0 \\u003c STRING_LONG_START) itemLen = byte0 - STRING_SHORT_START + 1;\\n        else if (byte0 \\u003c LIST_SHORT_START) {\\n            assembly {\\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\\n                memPtr := add(memPtr, 1) // skip over the first byte\\n                /* 32 byte word size */\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        } else if (byte0 \\u003c LIST_LONG_START) {\\n            itemLen = byte0 - LIST_SHORT_START + 1;\\n        } else {\\n            assembly {\\n                let byteLen := sub(byte0, 0xf7)\\n                memPtr := add(memPtr, 1)\\n\\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\\n                itemLen := add(dataLen, add(byteLen, 1))\\n            }\\n        }\\n\\n        return itemLen;\\n    }\\n\\n    // @return number of bytes until the data\\n    function _payloadOffset(uint256 memPtr) private pure returns (uint256) {\\n        uint256 byte0;\\n        assembly {\\n            byte0 := byte(0, mload(memPtr))\\n        }\\n\\n        if (byte0 \\u003c STRING_SHORT_START) return 0;\\n        else if (byte0 \\u003c STRING_LONG_START || (byte0 \\u003e= LIST_SHORT_START \\u0026\\u0026 byte0 \\u003c LIST_LONG_START)) return 1;\\n        else if (byte0 \\u003c LIST_SHORT_START)\\n            // being explicit\\n            return byte0 - (STRING_LONG_START - 1) + 1;\\n        else return byte0 - (LIST_LONG_START - 1) + 1;\\n    }\\n\\n    /*\\n     * @param src Pointer to source\\n     * @param dest Pointer to destination\\n     * @param len Amount of memory to copy from the source\\n     */\\n    function copy(\\n        uint256 src,\\n        uint256 dest,\\n        uint256 len\\n    ) private pure {\\n        if (len == 0) return;\\n\\n        // copy as many word sizes as possible\\n        for (; len \\u003e= WORD_SIZE; len -= WORD_SIZE) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += WORD_SIZE;\\n            dest += WORD_SIZE;\\n        }\\n\\n        if (len == 0) return;\\n\\n        // left over bytes. Mask is used to remove unwanted bytes from the word\\n        uint256 mask = 256**(WORD_SIZE - len) - 1;\\n\\n        assembly {\\n            let srcpart := and(mload(src), not(mask)) // zero out src\\n            let destpart := and(mload(dest), mask) // retrieve the bytes\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n}\\n\"},\"SpitToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.12;\\n\\nimport \\\"./ERC20.sol\\\";\\nimport \\\"./FXBaseChildTunnel.sol\\\";\\nimport \\\"./Ownable.sol\\\";\\n\\n/**\\n   __ _                                               \\n  / /| | __ _ _ __ ___   __ _/\\\\   /\\\\___ _ __ ___  ___ \\n / / | |/ _` | \\u0027_ ` _ \\\\ / _` \\\\ \\\\ / / _ \\\\ \\u0027__/ __|/ _ \\\\\\n/ /__| | (_| | | | | | | (_| |\\\\ V /  __/ |  \\\\__ \\\\  __/\\n\\\\____/_|\\\\__,_|_| |_| |_|\\\\__,_| \\\\_/ \\\\___|_|  |___/\\\\___|\\n\\n**/\\n\\n/// @title $SPIT Token\\n/// @author delta devs (https://twitter.com/deltadevelopers)\\n\\nenum TokenType {\\n    StaticLlama,\\n    AnimatedLlama,\\n    SilverBoost,\\n    GoldBoost,\\n    PixletCanvas,\\n    LlamaDraws\\n}\\n\\ncontract SpitToken is ERC20, FxBaseChildTunnel, Ownable {\\n    /*///////////////////////////////////////////////////////////////\\n                            STORAGE\\n    /////////////////////////////////////////////////////////////*/\\n\\n    struct Rewards {\\n        uint256 staticLlama;\\n        uint256 animatedLlama;\\n        uint256 silverEnergy;\\n        uint256 goldEnergy;\\n        uint256 pixletCanvas;\\n        uint256 llamaDraws;\\n    }\\n\\n    /// @notice The current reward rates per token type.\\n    Rewards public rewards;\\n\\n    /// @notice Keeps track of the staking balances (how much is being staked) of each token type for all holders.\\n    mapping(address =\\u003e mapping(uint256 =\\u003e uint256)) public balances;\\n\\n    /// @notice Keeps track of the timestamp of when a holder last withdrew their rewards.\\n    mapping(address =\\u003e uint256) public lastUpdated;\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            CONSTRUCTOR\\n    //////////////////////////////////////////////////////////////*/\\n\\n    constructor(address _fxChild)\\n        FxBaseChildTunnel(_fxChild)\\n        ERC20(\\\"Spit Token\\\", \\\"SPIT\\\", 18)\\n    {\\n        rewards.staticLlama = (uint256(10) * 1e18) / 1 days;\\n        rewards.animatedLlama = (uint256(30) * 1e18) / 1 days;\\n        rewards.silverEnergy = (uint256(4) * 1e18) / 1 days;\\n        rewards.goldEnergy = (uint256(12) * 1e18) / 1 days;\\n        rewards.llamaDraws = (uint256(1) * 1e18) / 1 days;\\n        rewards.pixletCanvas = (uint256(1) * 1e18) / 1 days;\\n\\n        _mint(address(this), 100_000_000 * 1e18);\\n        uint256 allocation = (30_000_000 + 5_000_000 + 5_000_000 + 2_500_000) *\\n            1e18;\\n        balanceOf[address(this)] -= allocation;\\n\\n        unchecked {\\n            balanceOf[\\n                0xcc5cDaB325689Bcd654aB8611c528e60CC8CBe6A\\n            ] += (30_000_000 * 1e18);\\n            balanceOf[\\n                0x58B96f5C8ef1CdD7e12a9b71Bbbe575E7B26b142\\n            ] += (5_000_000 * 1e18);\\n            balanceOf[\\n                0x58caDf06fcC222f573F81B08B6Cc156e420D35d7\\n            ] += (5_000_000 * 1e18);\\n            balanceOf[\\n                0x5D31E4A33470e1a15e54aAdD1d913b613fd0E9ED\\n            ] += (2_500_000 * 1e18);\\n        }\\n\\n        emit Transfer(\\n            address(this),\\n            0xcc5cDaB325689Bcd654aB8611c528e60CC8CBe6A,\\n            30_000_000 * 1e18\\n        );\\n        emit Transfer(\\n            address(this),\\n            0x58B96f5C8ef1CdD7e12a9b71Bbbe575E7B26b142,\\n            5_000_000 * 1e18\\n        );\\n        emit Transfer(\\n            address(this),\\n            0x58caDf06fcC222f573F81B08B6Cc156e420D35d7,\\n            5_000_000 * 1e18\\n        );\\n        emit Transfer(\\n            address(this),\\n            0x5D31E4A33470e1a15e54aAdD1d913b613fd0E9ED,\\n            2_500_000 * 1e18\\n        );\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            STAKING LOGIC\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Called when withdrawing rewards. $SPIT is transferred to the address, and the lastUpdated field is updated.\\n    /// @param account The address to mint to.\\n    modifier updateReward(address account) {\\n        uint256 amount = earned(account);\\n        balanceOf[address(this)] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[account] += amount;\\n        }\\n\\n        lastUpdated[account] = block.timestamp;\\n        emit Transfer(address(this), account, amount);\\n        _;\\n    }\\n\\n    /// @notice Internal call to stake an amount of a specific token type.\\n    /// @param account The address which will be staking.\\n    /// @param tokenType The token type to stake.\\n    /// @param amount The amount to stake.\\n    function processStake(\\n        address account,\\n        TokenType tokenType,\\n        uint256 amount\\n    ) internal updateReward(account) {\\n        balances[account][uint256(tokenType)] += amount;\\n    }\\n\\n    /// @notice Internal call to unstake an amount of a specific token type.\\n    /// @param account The address which will be unstaking.\\n    /// @param tokenType The token type to unstake.\\n    /// @param amount The amount to unstake.\\n    function processUnstake(\\n        address account,\\n        TokenType tokenType,\\n        uint256 amount\\n    ) internal updateReward(account) {\\n        balances[account][uint256(tokenType)] -= amount;\\n    }\\n\\n    /**\\n     * @notice Process message received from FxChild\\n     * @param stateId unique state id\\n     * @param sender root message sender\\n     * @param message bytes message that was sent from Root Tunnel\\n     */\\n    function _processMessageFromRoot(\\n        uint256 stateId,\\n        address sender,\\n        bytes memory message\\n    ) internal override validateSender(sender) {\\n        (address from, uint256 token, uint256 count, bool action) = abi.decode(\\n            message,\\n            (address, uint256, uint256, bool)\\n        );\\n        action\\n            ? processStake(from, TokenType(token), count)\\n            : processUnstake(from, TokenType(token), count);\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            USER UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Forwards a user\\u0027s purchase in SPIT to this contract using EIP-2612\\n    /// @dev This function exists so that the permit and transfer can be done in a single transaction.\\n    function purchaseUtility(\\n        address owner,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) public updateReward(owner) {\\n        permit(owner, msg.sender, value, deadline, v, r, s);\\n        transferFrom(owner, address(this), value);\\n    }\\n\\n    /// @notice Calculates the total amount of rewards accumulated for a staker, for staking all owned token types.\\n    /// @dev Calculates based on when the staker last withdrew rewards, and compares it with the current block\\u0027s timestamp.\\n    /// @param account The account to calculate the accumulated rewards for.\\n    function earned(address account) public view returns (uint256) {\\n        return\\n            spitPerSecond(account) * (block.timestamp - lastUpdated[account]);\\n    }\\n\\n    /// @notice Calculates the current balance of the user including the unclaimed rewards.\\n    /// @dev Unclaimed rewards are withdrawn automatically when a utility purchase is made or an unstake/stake occurs.\\n    function totalBalance(address account) public view returns (uint256) {\\n        return balanceOf[account] + earned(account);\\n    }\\n\\n    /// @notice Calculates the amount of SPIT earned per second by the given user\\n    /// @param account The account to calculate the accumulated rewards for.\\n    function spitPerSecond(address account) public view returns (uint256) {\\n        return ((balances[account][0] * rewards.staticLlama) +\\n            (balances[account][1] * rewards.animatedLlama) +\\n            (min(balances[account][2], balances[account][0]) *\\n                rewards.silverEnergy) +\\n            (min(balances[account][3], balances[account][1]) *\\n                rewards.goldEnergy) +\\n            (balances[account][4] * rewards.pixletCanvas) +\\n            (balances[account][5] * rewards.llamaDraws));\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                            ADMIN UTILITIES\\n    //////////////////////////////////////////////////////////////*/\\n\\n    /// @notice Allows the contract owner to burn SPIT owned by the contract.\\n    function burn(uint256 amount) public onlyOwner {\\n        _burn(address(this), amount);\\n    }\\n\\n    /// @notice Allows the contract owner to airdrop SPIT owned by the contract.\\n    function airdrop(address[] calldata accounts, uint256[] calldata amounts) public onlyOwner {\\n        require(accounts.length == amounts.length);\\n        for(uint i = 0; i \\u003c accounts.length; i++) {\\n            uint amount = amounts[i];\\n            balanceOf[address(this)] -= amount;\\n\\n            // Cannot overflow because the sum of all user\\n            // balances can\\u0027t exceed the max uint256 value.\\n            unchecked {\\n                balanceOf[accounts[i]] += amount;\\n            }\\n\\n            emit Transfer(address(this), accounts[i], amount);\\n        }\\n    }\\n\\n    /// @notice Allows the contract owner to mint SPIT to the contract.\\n    function mint(uint256 amount) public onlyOwner {\\n        _mint(address(this), amount);\\n    }\\n\\n    /// @notice Withdraw  $SPIT being held on this contract to the requested address.\\n    /// @param recipient The address to withdraw the funds to.\\n    /// @param amount The amount of SPIT to withdraw\\n    function withdrawSpit(address recipient, uint256 amount) public onlyOwner {\\n        balanceOf[address(this)] -= amount;\\n\\n        // Cannot overflow because the sum of all user\\n        // balances can\\u0027t exceed the max uint256 value.\\n        unchecked {\\n            balanceOf[recipient] += amount;\\n        }\\n\\n        emit Transfer(address(this), recipient, amount);\\n    }\\n\\n    /// @notice Allows the contract deployer to sets the reward rates for each token type.\\n    /// @param staticLlama The reward rate for staking a static llama.\\n    /// @param animatedLlama The reward rate for staking an animated llama.\\n    /// @param silverEnergy The reward rate for staking a silver llama boost.\\n    /// @param goldEnergy The reward rate for staking a gold llama boost.\\n    /// @param pixletCanvas The reward rate for staking a pixlet canvas.\\n    function setRewardRates(\\n        uint256 staticLlama,\\n        uint256 animatedLlama,\\n        uint256 silverEnergy,\\n        uint256 goldEnergy,\\n        uint256 pixletCanvas,\\n        uint256 llamaDraws\\n    ) public onlyOwner {\\n        rewards.staticLlama = staticLlama;\\n        rewards.animatedLlama = animatedLlama;\\n        rewards.silverEnergy = silverEnergy;\\n        rewards.goldEnergy = goldEnergy;\\n        rewards.pixletCanvas = pixletCanvas;\\n        rewards.llamaDraws = llamaDraws;\\n    }\\n\\n    function updateFxRootRunnel(address _fxRootTunnel) external onlyOwner {\\n        fxRootTunnel = _fxRootTunnel;\\n    }\\n\\n    /*///////////////////////////////////////////////////////////////\\n                                HELPERS\\n    //////////////////////////////////////////////////////////////*/\\n\\n    function min(uint256 x, uint256 y) internal pure returns (uint256) {\\n        return x \\u003c y ? x : y;\\n    }\\n}\\n\"}}", "ABI": "[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"checkpointManager\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"fxRoot\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pixellatedLlamaContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_llamaDrawsContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_boostContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pixletContract\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"NotOwner\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"SEND_MESSAGE_EVENT_SIG\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"boostContract\",\"outputs\":[{\"internalType\":\"contract ERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"llamas\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128\",\"name\":\"silverBoosts\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"goldBoosts\",\"type\":\"uint128\"},{\"internalType\":\"uint256\",\"name\":\"pixletStudio\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"llamaDraws\",\"type\":\"uint256\"}],\"name\":\"bulkStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"llamas\",\"type\":\"uint256[]\"},{\"internalType\":\"uint128\",\"name\":\"silverBoosts\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"goldBoosts\",\"type\":\"uint128\"},{\"internalType\":\"bool\",\"name\":\"pixletStudio\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"llamaDraws\",\"type\":\"bool\"}],\"name\":\"bulkUnstake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"checkpointManager\",\"outputs\":[{\"internalType\":\"contract ICheckpointManager\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxChildTunnel\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"fxRoot\",\"outputs\":[{\"internalType\":\"contract IFxStateSender\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getStakedTokens\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"llamas\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256\",\"name\":\"pixletCanvas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"llamaDraws\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"silverBoosts\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"goldBoosts\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"llamaDrawsContract\",\"outputs\":[{\"internalType\":\"contract ERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"ids\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155BatchReceived\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"id\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pixellatedLlamaContract\",\"outputs\":[{\"internalType\":\"contract ERC721\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pixletContract\",\"outputs\":[{\"internalType\":\"contract ERC1155\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"processedExits\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"inputData\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pixellatedLlamaContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_llamaDrawsContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_boostContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_pixletContract\",\"type\":\"address\"}],\"name\":\"setContractAddresses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_fxChildTunnel\",\"type\":\"address\"}],\"name\":\"setFxChildTunnel\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"paused\",\"type\":\"bool\"}],\"name\":\"setStakingPaused\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"silverAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"goldAmount\",\"type\":\"uint128\"}],\"name\":\"stakeBoosts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stakeGoldBoosts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stakeLlama\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stakeLlamaDraws\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"stakeMultipleLlamas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"stakePixletCanvas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"stakeSilverBoosts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"stakingPaused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"silverAmount\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"goldAmount\",\"type\":\"uint128\"}],\"name\":\"unstakeBoosts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"unstakeGoldBoosts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"unstakeLlama\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakeLlamaDraws\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"unstakeMultipleLlamas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"unstakePixletCanvas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint128\",\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"unstakeSilverBoosts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"userInfo\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakedPixletCanvas\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakedLlamaDraws\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"stakedSilverBoosts\",\"type\":\"uint128\"},{\"internalType\":\"uint128\",\"name\":\"stakedGoldBoosts\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "LlamaZoo", "CompilerVersion": "v0.8.13+commit.abaa5c0e", "OptimizationUsed": "1", "Runs": "9999", "ConstructorArguments": "00000000000000000000000086e4dc95c7fbdbf52e33d563bbdb00823894c287000000000000000000000000fe5e5d361b2ad62c541bab87c45a0b9b018389a20000000000000000000000009df8aa7c681f33e442a0d57b838555da863504f300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000bd4d37e0907c9f564aaa0a7528837b81b25c6050000000000000000000000000612dbc8671270768a10d1f6d5d988fc4ff23a1b", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://9217d194649c8ac2c51aa00479d69ea51ac54bd1aa40db13a821cd0d44e3efe1"}