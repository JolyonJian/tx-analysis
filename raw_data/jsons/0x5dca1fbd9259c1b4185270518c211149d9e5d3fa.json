{"SourceCode": "{{\r\n  \"language\": \"Solidity\",\r\n  \"sources\": {\r\n    \"contracts/stake/BloodShedBearsStaking.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\\\";\\nimport \\\"@openzeppelin/contracts/access/Ownable.sol\\\";\\nimport \\\"@openzeppelin/contracts/security/Pausable.sol\\\";\\n\\ninterface ICollection721 {\\n    function isOwnerOfBatch(uint256[] calldata tokenIds_, address address_) external view returns (bool);\\n    function ownerOf(uint256 tokenId) external view returns (address);\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n}\\n\\ninterface IMintPass {\\n    function balanceOf(address account, uint256 id) external view returns (uint256);\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 amount,\\n        bytes memory data\\n    ) external;\\n}\\n\\ninterface IToken {\\n    function add(address wallet, uint256 amount) external;\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n    function mintTokens(address to, uint256 amount) external;\\n}\\n\\ninterface IGameStats {\\n    function getLevelBoosts(address collection, uint256[] calldata tokenIds) external view returns (uint256[] memory);\\n    function getLevelBoost(address collection, uint256 tokenId) external view returns (uint256);\\n    function getLevel(address collection, uint256 tokenId) external returns (uint256);\\n    function setTokensData(\\n        address collection,\\n        uint256[] calldata tokenIds,\\n        uint256[] calldata levels,\\n        bool[] calldata factions,\\n        bool[] calldata elites\\n    ) external;\\n    function isClaimSuccessful(\\n        address collection,\\n        uint256 tokenId,\\n        uint256 amount,\\n        uint256 stakeType\\n    ) external returns (bool);\\n    function setStakedTokenData(\\n        address collection,\\n        address owner,\\n        uint256 stakeType,\\n        uint256[] calldata tokenIds\\n    ) external;\\n    function unsetStakedTokenData(\\n        address collection,\\n        uint256[] calldata tokenIds\\n    ) external;\\n}\\n\\ncontract BloodShedBearsStaking is Ownable, Pausable {\\n    struct CollectionSettings {\\n        bool hasLevel;\\n        uint256 baseYieldRate;\\n    }\\n\\n    struct StakeData {\\n        uint256 stakeType;\\n        uint256 claimDate;\\n        uint256 houseTokenId;\\n    }\\n\\n    struct HouseEnrol {\\n        uint256 enrolDate;\\n        uint256 tokenId;\\n    }\\n\\n    struct UnStakeSelection {\\n        address collectionAddress;\\n        uint256[] tokens;\\n    }\\n\\n    struct StakeSelection {\\n        uint256 targetHouse;\\n        uint256 stakeType;\\n        address collectionAddress;\\n        uint256[] tokens;\\n        uint256[] levels;\\n        bool[] factions;\\n        bool[] elites;\\n        bytes[] signatures;\\n    }\\n\\n    struct StakedTokens {\\n        uint256 tokenId;\\n        uint256 stakeType;\\n        uint256 claimDate;\\n        uint256 houseTokenId;\\n    }\\n\\n    address private signerAddress;\\n\\n    mapping(string => address) public contractsAddressesMap;\\n    mapping(string => uint256) public stakeTypesVariables;\\n\\n    mapping(address => mapping(address => uint256[])) public stakedTokensByWallet;\\n    mapping(address => mapping(uint256 => StakeData)) public stakedTokensData;\\n\\n    uint256 public treeHouseBoost = 30;\\n    mapping(uint256 => mapping(address => HouseEnrol[])) public treeHousesEnrolments;\\n\\n    mapping(address => CollectionSettings) public collectionsSettings;\\n    address[] public collections;\\n\\n    // PARTNER COLLECTIONS\\n    mapping(address => uint256) public partnerCollectionYield;\\n    mapping(address => mapping(uint256 => bool)) public claimedPartnerTokens;\\n\\n    // MINT PASSES\\n    mapping(address => uint256) public walletsStakedPasses;\\n    mapping(address => uint256) public passesStakeDate;\\n\\n    // ADMIN\\n    function addCollectionSettings(\\n        CollectionSettings[] calldata settings_,\\n        address[] calldata collections_\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i < collections_.length; ++i) {\\n            CollectionSettings storage cs = collectionsSettings[collections_[i]];\\n            cs.baseYieldRate = settings_[i].baseYieldRate;\\n            cs.hasLevel = settings_[i].hasLevel;\\n        }\\n        collections = collections_;\\n    }\\n\\n    function setTreeHouseBoost(uint256 boost_) external onlyOwner {\\n        treeHouseBoost = boost_;\\n    }\\n\\n    function setSignerAddress(address signerAddress_) external onlyOwner {\\n        signerAddress = signerAddress_;\\n    }\\n\\n    function setContractAddressesKeys(\\n        string[] calldata keys_,\\n        address[] calldata collections_\\n    ) external onlyOwner {\\n        for (uint i = 0; i < keys_.length; ++i) {\\n            contractsAddressesMap[keys_[i]] = collections_[i];\\n        }\\n    }\\n\\n    function setStakeTypesKeys(\\n        string[] calldata keys_,\\n        uint256[] calldata stakeTypesIndexes_\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i < keys_.length; ++i) {\\n            stakeTypesVariables[keys_[i]] = stakeTypesIndexes_[i];\\n        }\\n    }\\n\\n    function setPartnerProjectsYielding(\\n        address[] calldata addresses_,\\n        uint256[] calldata yieldingAmounts_\\n    ) external onlyOwner {\\n        for (uint256 i = 0; i <  addresses_.length; ++i) {\\n            partnerCollectionYield[addresses_[i]] = yieldingAmounts_[i];\\n        }\\n    }\\n\\n    // UTILS\\n    function _moveTokenInTheListStake(\\n        uint256[] storage list,\\n        uint256 tokenId\\n    ) internal {\\n        uint256 foundIndex;\\n        uint256 i;\\n        for (; i < list.length; ++i) {\\n            if (list[i] == tokenId) {\\n                foundIndex = i;\\n                break;\\n            }\\n        }\\n\\n        require(i != list.length, \\\"NOT OWNED\\\");\\n\\n        if (foundIndex != list.length - 1) {\\n            uint256 t = list[foundIndex];\\n            list[foundIndex] = list[list.length - 1];\\n            list[list.length - 1] = t;\\n        }\\n    }\\n\\n    function _moveTokenInTheListHouse(\\n        HouseEnrol[] storage list,\\n        uint256 tokenId\\n    ) internal  {\\n        uint256 foundIndex;\\n        uint256 i;\\n        for (; i < list.length; ++i) {\\n            if (list[i].tokenId == tokenId) {\\n                foundIndex = i;\\n                break;\\n            }\\n        }\\n\\n        require(i != list.length, \\\"NOT OWNED\\\");\\n\\n        if (foundIndex != list.length - 1) {\\n            HouseEnrol memory he = list[foundIndex];\\n            list[foundIndex] = list[list.length - 1];\\n            list[list.length - 1] = he;\\n        }\\n    }\\n\\n    function onERC721Received(address, address, uint256, bytes calldata) external pure returns(bytes4) {\\n        return bytes4(keccak256(\\\"onERC721Received(address,address,uint256,bytes)\\\"));\\n    }\\n\\n    function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure returns (bytes4) {\\n        return bytes4(keccak256(\\\"onERC1155Received(address,address,uint256,uint256,bytes)\\\"));\\n    }\\n\\n    function _validateMultipleSignature(\\n        StakeSelection[] calldata selections_\\n    ) internal {\\n        for (uint256 i = 0; i < selections_.length; i++) {\\n            if (selections_[i].signatures.length == 0) {\\n                continue;\\n            }\\n\\n            bool isValid = true;\\n\\n            for (uint256 j = 0; j < selections_[i].tokens.length; j++) {\\n                bytes32 dataHash = keccak256(abi.encodePacked(\\n                        selections_[i].collectionAddress,\\n                        selections_[i].tokens[j],\\n                        selections_[i].levels[j],\\n                        selections_[i].elites[j],\\n                        selections_[i].factions[j]\\n                    ));\\n\\n                bytes32 message = ECDSA.toEthSignedMessageHash(dataHash);\\n                address receivedAddress = ECDSA.recover(message, selections_[i].signatures[j]);\\n                isValid = isValid && (receivedAddress != address(0) && receivedAddress == signerAddress);\\n            }\\n\\n            require(isValid);\\n\\n            IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).setTokensData(\\n                selections_[i].collectionAddress,\\n                selections_[i].tokens,\\n                selections_[i].levels,\\n                selections_[i].factions,\\n                selections_[i].elites\\n            );\\n        }\\n    }\\n\\n    // MINT PASS\\n\\n    function stakePasses(\\n        uint256 amount_,\\n        bool withdrawCurrentYield\\n    ) external whenNotPaused {\\n        require(IMintPass(contractsAddressesMap[\\\"mintPass\\\"]).balanceOf(msg.sender, 0) >= amount_);\\n\\n        if (walletsStakedPasses[msg.sender] != 0) {\\n            if (withdrawCurrentYield) {\\n                withdrawPassesYield();\\n            } else {\\n                transferPassesYieldIntoInternalWallet(msg.sender);\\n            }\\n        } else {\\n            passesStakeDate[msg.sender] = block.timestamp;\\n        }\\n\\n        walletsStakedPasses[msg.sender] += amount_;\\n        IMintPass(contractsAddressesMap[\\\"mintPass\\\"]).safeTransferFrom(msg.sender, address(this), 0, amount_, \\\"\\\");\\n    }\\n\\n    function unStakePasses(bool withdraw) external whenNotPaused  {\\n        if (withdraw) {\\n            withdrawPassesYield();\\n        } else {\\n            transferPassesYieldIntoInternalWallet(msg.sender);\\n        }\\n\\n        IMintPass(contractsAddressesMap[\\\"mintPass\\\"]).safeTransferFrom(address(this), msg.sender, 0, walletsStakedPasses[msg.sender], \\\"\\\");\\n\\n        walletsStakedPasses[msg.sender] = 0;\\n    }\\n\\n    function withdrawPassesYield() public whenNotPaused {\\n        IToken(contractsAddressesMap[\\\"token\\\"]).mintTokens(msg.sender, _claimMetaPassEarning(msg.sender));\\n    }\\n\\n    function transferPassesYieldIntoInternalWallet(address wallet_) public whenNotPaused {\\n        IToken(contractsAddressesMap[\\\"token\\\"]).add(wallet_, _claimMetaPassEarning(msg.sender));\\n    }\\n\\n    function _claimMetaPassEarning(address wallet_) internal returns (uint256) {\\n        uint256 amount = calculateMetaPassesYield(wallet_);\\n        passesStakeDate[wallet_] = block.timestamp;\\n\\n        return amount;\\n    }\\n\\n    function calculateMetaPassesYield(address wallet_) public view returns (uint256) {\\n        return (block.timestamp - passesStakeDate[wallet_]) *\\n            walletsStakedPasses[wallet_] *\\n            collectionsSettings[contractsAddressesMap[\\\"mintPass\\\"]].baseYieldRate / 1 days;\\n    }\\n\\n    // PARTNER PROJECTS\\n\\n    function claimPartnerTokens(\\n        address collection_,\\n        uint256[] calldata tokenIds_,\\n        bool withdrawYield\\n    ) external whenNotPaused {\\n        require(partnerCollectionYield[collection_] != 0);\\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\\n            require(ICollection721(collection_).ownerOf(tokenIds_[i]) == msg.sender);\\n            claimedPartnerTokens[collection_][tokenIds_[i]] = true;\\n        }\\n        if (withdrawYield) {\\n            IToken(contractsAddressesMap[\\\"token\\\"]).mintTokens(msg.sender, partnerCollectionYield[collection_] * tokenIds_.length);\\n        } else {\\n            IToken(contractsAddressesMap[\\\"token\\\"]).add(msg.sender, partnerCollectionYield[collection_] * tokenIds_.length);\\n        }\\n    }\\n\\n    // STAKE\\n\\n    function _getHouseOccupancy(uint256 houseId) internal view returns (uint256) {\\n        uint256 occupancy = 0;\\n\\n        for (uint256 i = 0; i < collections.length; ++i) {\\n            occupancy += treeHousesEnrolments[houseId][collections[i]].length;\\n        }\\n\\n        return occupancy;\\n    }\\n\\n    function isOwner(address wallet_, address collection_, uint256 tokenId_) public view returns (bool) {\\n        for (uint256 i = 0; i <  stakedTokensByWallet[wallet_][collection_].length; ++i) {\\n            if (stakedTokensByWallet[wallet_][collection_][i] == tokenId_) {\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n\\n    function stakeTokens(StakeSelection[] calldata selections_) external whenNotPaused {\\n        _validateMultipleSignature(selections_);\\n\\n        for (uint256 i = 0; i < selections_.length; ++i) {\\n            require(ICollection721(selections_[i].collectionAddress).isOwnerOfBatch(selections_[i].tokens, msg.sender));\\n\\n            if (selections_[i].collectionAddress == contractsAddressesMap[\\\"tokenGenerator\\\"]) {\\n                require(selections_[i].stakeType == stakeTypesVariables[\\\"treeHouse\\\"]);\\n            }\\n\\n            if (selections_[i].collectionAddress == contractsAddressesMap[\\\"treeHouse\\\"]) {\\n                require(selections_[i].stakeType == stakeTypesVariables[\\\"home\\\"]);\\n            }\\n\\n            bool stack = selections_[i].stakeType == stakeTypesVariables[\\\"treeHouse\\\"];\\n\\n            if (stack) {\\n                require(isOwner(msg.sender, contractsAddressesMap[\\\"treeHouse\\\"], selections_[i].targetHouse));\\n                require(\\n                    selections_[i].tokens.length + _getHouseOccupancy(selections_[i].targetHouse)\\n                    <= IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).getLevel(\\n                            contractsAddressesMap[\\\"treeHouse\\\"],\\n                            selections_[i].targetHouse\\n                ));\\n            }\\n\\n            for (uint256 j = 0; j < selections_[i].tokens.length; ++j) {\\n                _enterStakeStance(\\n                    selections_[i].collectionAddress,\\n                    selections_[i].tokens[j],\\n                    selections_[i].stakeType,\\n                    false\\n                );\\n\\n                if (stack) {\\n                    _enterStackStance(\\n                        selections_[i].collectionAddress,\\n                        selections_[i].tokens[j],\\n                        selections_[i].targetHouse\\n                    );\\n                }\\n                ICollection721(selections_[i].collectionAddress)\\n                    .safeTransferFrom(msg.sender, address(this), selections_[i].tokens[j]);\\n            }\\n\\n            IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).setStakedTokenData(\\n                selections_[i].collectionAddress,\\n                msg.sender,\\n                selections_[i].stakeType,\\n                selections_[i].tokens\\n            );\\n\\n            delete stack;\\n        }\\n    }\\n\\n    function _enterStakeStance(\\n        address collection_,\\n        uint256 tokenId_,\\n        uint256 stakeType_,\\n        bool skipPushing\\n    ) internal {\\n        if (!skipPushing) {\\n            stakedTokensByWallet[msg.sender][collection_].push(tokenId_);\\n        }\\n        StakeData storage stake = stakedTokensData[collection_][tokenId_];\\n        stake.stakeType = stakeType_;\\n        stake.claimDate = block.timestamp;\\n    }\\n\\n    function _enterStackStance(\\n        address collection_,\\n        uint256 tokenId_,\\n        uint256 treeHouseId_\\n    ) internal {\\n        treeHousesEnrolments[treeHouseId_][collection_].push(HouseEnrol({\\n            enrolDate : block.timestamp,\\n            tokenId: tokenId_\\n        }));\\n        stakedTokensData[collection_][tokenId_].houseTokenId = treeHouseId_;\\n    }\\n\\n    function unStakeTokens(UnStakeSelection[] calldata selections_) external whenNotPaused {\\n        uint256 totalAccumulatedYield;\\n        for (uint256 i = 0; i < selections_.length; ++i) {\\n            totalAccumulatedYield += _exitStakeStanceMany(\\n                selections_[i].collectionAddress,\\n                selections_[i].tokens,\\n                true,\\n                true,\\n                false\\n            );\\n\\n            IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).unsetStakedTokenData(\\n                selections_[i].collectionAddress,\\n                selections_[i].tokens\\n            );\\n        }\\n\\n        IToken(contractsAddressesMap[\\\"token\\\"]).add(msg.sender, totalAccumulatedYield);\\n    }\\n\\n    function _exitStakeStanceMany(\\n        address collection_,\\n        uint256[] calldata tokenIds_,\\n        bool transferTokens,\\n        bool updateClaimDate,\\n        bool skipPopping\\n    ) internal returns(uint256) {\\n        uint256 yieldedAmount;\\n\\n        uint256[] memory levelBoosts;\\n\\n        if(collectionsSettings[collection_].hasLevel) {\\n            levelBoosts = IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).getLevelBoosts(collection_, tokenIds_);\\n        } else {\\n            levelBoosts = new uint256[](tokenIds_.length);\\n        }\\n\\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\\n            require(isOwner(msg.sender, collection_, tokenIds_[i]));\\n\\n            yieldedAmount += _getYield(collection_, tokenIds_[i], levelBoosts[i], updateClaimDate);\\n\\n            _exitStakeStance(collection_, tokenIds_[i], skipPopping);\\n\\n            if (transferTokens) {\\n                ICollection721(collection_).safeTransferFrom(address(this), msg.sender, tokenIds_[i]);\\n            }\\n        }\\n\\n        delete levelBoosts;\\n\\n        return yieldedAmount;\\n    }\\n\\n    function _exitStakeStance(\\n        address collection_,\\n        uint256 tokenId_,\\n        bool skipPopping\\n    ) internal {\\n        if (collection_ == contractsAddressesMap[\\\"treeHouse\\\"]) {\\n            require(_getHouseOccupancy(tokenId_) == 0);\\n        }\\n\\n        if (!skipPopping) {\\n            _moveTokenInTheListStake(stakedTokensByWallet[msg.sender][collection_], tokenId_);\\n            stakedTokensByWallet[msg.sender][collection_].pop();\\n        }\\n\\n        if (stakedTokensData[collection_][tokenId_].stakeType == stakeTypesVariables[\\\"treeHouse\\\"]) {\\n            _exitStackStance(collection_, tokenId_);\\n        }\\n\\n        delete stakedTokensData[collection_][tokenId_];\\n    }\\n\\n    function _exitStackStance(\\n        address collection_,\\n        uint256 tokenId_\\n    ) internal {\\n        _moveTokenInTheListHouse(\\n            treeHousesEnrolments[stakedTokensData[collection_][tokenId_].houseTokenId][collection_],\\n            tokenId_\\n        );\\n        treeHousesEnrolments[stakedTokensData[collection_][tokenId_].houseTokenId][collection_].pop();\\n    }\\n\\n    function moveIntoDifferentStake(StakeSelection[] calldata selections_) external whenNotPaused {\\n        uint256 totalAccumulatedYield;\\n        for (uint256 i = 0; i < selections_.length; ++i) {\\n            totalAccumulatedYield += _exitStakeStanceMany(\\n                selections_[i].collectionAddress,\\n                selections_[i].tokens,\\n                false,\\n                false,\\n                true\\n            );\\n\\n            IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).unsetStakedTokenData(\\n                selections_[i].collectionAddress,\\n                selections_[i].tokens\\n            );\\n\\n            require(selections_[i].collectionAddress != contractsAddressesMap[\\\"tokenGenerator\\\"]);\\n            require(selections_[i].collectionAddress != contractsAddressesMap[\\\"treeHouse\\\"]);\\n\\n            bool stack = selections_[i].stakeType == stakeTypesVariables[\\\"treeHouse\\\"];\\n\\n            if (stack) {\\n                require(isOwner(msg.sender, contractsAddressesMap[\\\"treeHouse\\\"], selections_[i].targetHouse));\\n                require(\\n                    selections_[i].tokens.length + _getHouseOccupancy(selections_[i].targetHouse)\\n                    <= IGameStats(contractsAddressesMap[\\\"gameStats\\\"])\\n                        .getLevel(contractsAddressesMap[\\\"treeHouse\\\"], selections_[i].targetHouse)\\n                );\\n            }\\n            for (uint256 j = 0; j < selections_[i].tokens.length; ++j) {\\n                _enterStakeStance(\\n                    selections_[i].collectionAddress,\\n                    selections_[i].tokens[j],\\n                    selections_[i].stakeType,\\n                    true\\n                );\\n                if (stack) {\\n                    _enterStackStance(\\n                        selections_[i].collectionAddress,\\n                        selections_[i].tokens[j],\\n                        selections_[i].targetHouse\\n                    );\\n                }\\n            }\\n\\n            IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).setStakedTokenData(\\n                selections_[i].collectionAddress,\\n                msg.sender,\\n                selections_[i].stakeType,\\n                selections_[i].tokens\\n            );\\n        }\\n\\n        IToken(contractsAddressesMap[\\\"token\\\"]).add(msg.sender, totalAccumulatedYield);\\n\\n        delete totalAccumulatedYield;\\n    }\\n\\n    // TOKENS\\n\\n    function _getYield(\\n        address collection_,\\n        uint256 tokenId_,\\n        uint256 tokenLevelBoost,\\n        bool updateClaimField\\n    ) internal returns (uint256) {\\n        uint256 yield = collectionsSettings[collection_].baseYieldRate *\\n        (block.timestamp - stakedTokensData[collection_][tokenId_].claimDate) / 1 days;\\n\\n        if (stakedTokensData[collection_][tokenId_].stakeType == stakeTypesVariables[\\\"training\\\"]) {\\n            yield /= 2;\\n        }\\n\\n        if (stakedTokensData[collection_][tokenId_].stakeType == stakeTypesVariables[\\\"battle\\\"]) {\\n            yield += yield / 2;\\n        }\\n\\n        if (collectionsSettings[collection_].hasLevel) {\\n            yield += yield * tokenLevelBoost / 100;\\n        }\\n\\n        if (stakedTokensData[collection_][tokenId_].stakeType == stakeTypesVariables[\\\"treeHouse\\\"]) {\\n\\n            HouseEnrol[] storage houseEnrols = treeHousesEnrolments[stakedTokensData[collection_][tokenId_].houseTokenId][collection_];\\n\\n            uint256 foundIndex;\\n            uint256 i;\\n            for (; i < houseEnrols.length; ++i) {\\n                if (houseEnrols[i].tokenId == tokenId_) {\\n                    foundIndex = i;\\n                    break;\\n                }\\n            }\\n\\n            require(i != houseEnrols.length, \\\"NOT OWNED\\\");\\n\\n            yield += (block.timestamp - houseEnrols[foundIndex].enrolDate) *\\n                collectionsSettings[collection_].baseYieldRate *\\n                treeHouseBoost /\\n                100 days;\\n\\n            if (updateClaimField) {\\n                houseEnrols[foundIndex].enrolDate = block.timestamp;\\n            }\\n        }\\n\\n        if (stakedTokensData[collection_][tokenId_].stakeType != stakeTypesVariables[\\\"training\\\"]) {\\n            if (\\n                !IGameStats(contractsAddressesMap[\\\"gameStats\\\"])\\n                    .isClaimSuccessful(\\n                        collection_,\\n                        tokenId_,\\n                        yield,\\n                        stakedTokensData[collection_][tokenId_].stakeType)\\n            ) {\\n                yield = 0;\\n            }\\n        }\\n\\n        if (updateClaimField) {\\n            stakedTokensData[collection_][tokenId_].claimDate = block.timestamp;\\n        }\\n\\n        return yield;\\n    }\\n\\n    function claimYield(\\n        address collection_,\\n        uint256[] memory tokenIds_\\n    ) external whenNotPaused returns (uint256) {\\n\\n        uint256 amount;\\n        uint256[] memory levelBoosts;\\n\\n        if(collectionsSettings[collection_].hasLevel) {\\n            levelBoosts = IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).getLevelBoosts(collection_, tokenIds_);\\n        } else {\\n            levelBoosts = new uint256[](tokenIds_.length);\\n        }\\n\\n        for (uint256 i = 0; i <  tokenIds_.length; ++i) {\\n            require(isOwner(msg.sender, collection_, tokenIds_[i]));\\n            amount += _getYield(collection_, tokenIds_[i], levelBoosts[i], true);\\n        }\\n\\n        IToken(contractsAddressesMap[\\\"token\\\"]).add(msg.sender, amount);\\n\\n        delete levelBoosts;\\n\\n        return amount;\\n    }\\n\\n\\n    function claimYieldForAll() external whenNotPaused {\\n        uint256 totalYield;\\n        for (uint256 i = 0; i < collections.length; ++i) {\\n            if (stakedTokensByWallet[msg.sender][collections[i]].length > 0) {\\n\\n                uint256[] memory levelBoosts;\\n\\n                if(collectionsSettings[collections[i]].hasLevel) {\\n                    levelBoosts = IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).getLevelBoosts(collections[i], stakedTokensByWallet[msg.sender][collections[i]]);\\n                } else {\\n                    levelBoosts = new uint256[](stakedTokensByWallet[msg.sender][collections[i]].length);\\n                }\\n\\n                for (uint256 j = 0; j < stakedTokensByWallet[msg.sender][collections[i]].length; ++j) {\\n                    totalYield += _getYield(\\n                        collections[i],\\n                        stakedTokensByWallet[msg.sender][collections[i]][j],\\n                        levelBoosts[j],\\n                        true\\n                    );\\n                }\\n            }\\n        }\\n\\n        IToken(contractsAddressesMap[\\\"token\\\"]).add(msg.sender, totalYield);\\n\\n        delete totalYield;\\n    }\\n\\n    function calculateYieldSafe(address collection_, uint256[] memory tokenIds_) public view returns(uint256) {\\n        uint256 totalYield;\\n        for (uint256 i = 0; i < tokenIds_.length; ++i) {\\n            totalYield += _getYieldSafe(collection_, tokenIds_[i]);\\n        }\\n\\n        return totalYield;\\n    }\\n\\n    function calculateYieldForAll(address wallet_) external view returns(uint256) {\\n        uint256 totalYield;\\n\\n        for (uint256 i = 0; i < collections.length; ++i) {\\n            if (stakedTokensByWallet[wallet_][collections[i]].length > 0) {\\n               totalYield += calculateYieldSafe(collections[i], stakedTokensByWallet[wallet_][collections[i]]);\\n            }\\n        }\\n\\n        return totalYield;\\n    }\\n\\n    function _getYieldSafe(\\n        address collection_,\\n        uint256 tokenId_\\n    ) internal view returns (uint256) {\\n        uint256 yield = collectionsSettings[collection_].baseYieldRate *\\n        (block.timestamp - stakedTokensData[collection_][tokenId_].claimDate) / 1 days;\\n\\n        if (stakedTokensData[collection_][tokenId_].stakeType == stakeTypesVariables[\\\"training\\\"]) {\\n            yield = yield / 2;\\n        }\\n\\n        if (collectionsSettings[collection_].hasLevel) {\\n            yield += yield * IGameStats(contractsAddressesMap[\\\"gameStats\\\"]).getLevelBoost(collection_, tokenId_) / 100;\\n        }\\n\\n        if (stakedTokensData[collection_][tokenId_].stakeType == stakeTypesVariables[\\\"treeHouse\\\"]) {\\n\\n            HouseEnrol[] storage houseEnrols = treeHousesEnrolments[stakedTokensData[collection_][tokenId_].houseTokenId][collection_];\\n\\n            uint256 foundIndex;\\n            uint256 i;\\n            for (; i < houseEnrols.length; ++i) {\\n                if (houseEnrols[i].tokenId == tokenId_) {\\n                    foundIndex = i;\\n                    break;\\n                }\\n            }\\n\\n            require(i != houseEnrols.length, \\\"NOT OWNED\\\");\\n\\n            yield +=\\n            (block.timestamp - houseEnrols[foundIndex].enrolDate) *\\n            collectionsSettings[collection_].baseYieldRate *\\n            treeHouseBoost /\\n            100 days;\\n        }\\n\\n        return yield;\\n    }\\n\\n    function getStakedTokens(address wallet_, address collection_) external view returns (StakedTokens[] memory) {\\n        StakedTokens[] memory stakedTokens = new StakedTokens[](stakedTokensByWallet[wallet_][collection_].length);\\n\\n        for (uint256 i = 0; i < stakedTokensByWallet[wallet_][collection_].length; ++i) {\\n            stakedTokens[i].tokenId = stakedTokensByWallet[wallet_][collection_][i];\\n            stakedTokens[i].stakeType = stakedTokensData[collection_][stakedTokensByWallet[wallet_][collection_][i]].stakeType;\\n            stakedTokens[i].claimDate = stakedTokensData[collection_][stakedTokensByWallet[wallet_][collection_][i]].claimDate;\\n            stakedTokens[i].houseTokenId = stakedTokensData[collection_][stakedTokensByWallet[wallet_][collection_][i]].houseTokenId;\\n        }\\n\\n        return stakedTokens;\\n    }\\n\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../Strings.sol\\\";\\n\\n/**\\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\\n *\\n * These functions can be used to verify that a message was signed by the holder\\n * of the private keys of a given address.\\n */\\nlibrary ECDSA {\\n    enum RecoverError {\\n        NoError,\\n        InvalidSignature,\\n        InvalidSignatureLength,\\n        InvalidSignatureS,\\n        InvalidSignatureV\\n    }\\n\\n    function _throwError(RecoverError error) private pure {\\n        if (error == RecoverError.NoError) {\\n            return; // no error: do nothing\\n        } else if (error == RecoverError.InvalidSignature) {\\n            revert(\\\"ECDSA: invalid signature\\\");\\n        } else if (error == RecoverError.InvalidSignatureLength) {\\n            revert(\\\"ECDSA: invalid signature length\\\");\\n        } else if (error == RecoverError.InvalidSignatureS) {\\n            revert(\\\"ECDSA: invalid signature 's' value\\\");\\n        } else if (error == RecoverError.InvalidSignatureV) {\\n            revert(\\\"ECDSA: invalid signature 'v' value\\\");\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature` or error string. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     *\\n     * Documentation for signature generation:\\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\\n        // Check the signature length\\n        // - case 65: r,s,v signature (standard)\\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\\n        if (signature.length == 65) {\\n            bytes32 r;\\n            bytes32 s;\\n            uint8 v;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                s := mload(add(signature, 0x40))\\n                v := byte(0, mload(add(signature, 0x60)))\\n            }\\n            return tryRecover(hash, v, r, s);\\n        } else if (signature.length == 64) {\\n            bytes32 r;\\n            bytes32 vs;\\n            // ecrecover takes the signature parameters, and the only way to get them\\n            // currently is to use assembly.\\n            assembly {\\n                r := mload(add(signature, 0x20))\\n                vs := mload(add(signature, 0x40))\\n            }\\n            return tryRecover(hash, r, vs);\\n        } else {\\n            return (address(0), RecoverError.InvalidSignatureLength);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the address that signed a hashed message (`hash`) with\\n     * `signature`. This address can then be used for verification purposes.\\n     *\\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\\n     * this function rejects them by requiring the `s` value to be in the lower\\n     * half order, and the `v` value to be either 27 or 28.\\n     *\\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\\n     * verification to be secure: it is possible to craft signatures that\\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\\n     * this is by receiving a hash of the original message (which may otherwise\\n     * be too long), and then calling {toEthSignedMessageHash} on it.\\n     */\\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\\n     *\\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address, RecoverError) {\\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\\n        return tryRecover(hash, v, r, s);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\\n     *\\n     * _Available since v4.2._\\n     */\\n    function recover(\\n        bytes32 hash,\\n        bytes32 r,\\n        bytes32 vs\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function tryRecover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address, RecoverError) {\\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\\n        // the valid range for s in (301): 0 < s < secp256k1n \u00f7 2 + 1, and for v in (302): v \u2208 {27, 28}. Most\\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\\n        //\\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\\n        // these malleable signatures as well.\\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\\n            return (address(0), RecoverError.InvalidSignatureS);\\n        }\\n        if (v != 27 && v != 28) {\\n            return (address(0), RecoverError.InvalidSignatureV);\\n        }\\n\\n        // If the signature is valid (and not malleable), return the signer address\\n        address signer = ecrecover(hash, v, r, s);\\n        if (signer == address(0)) {\\n            return (address(0), RecoverError.InvalidSignature);\\n        }\\n\\n        return (signer, RecoverError.NoError);\\n    }\\n\\n    /**\\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\\n     * `r` and `s` signature fields separately.\\n     */\\n    function recover(\\n        bytes32 hash,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal pure returns (address) {\\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\\n        _throwError(error);\\n        return recovered;\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\\n        // 32 is the length in bytes of hash,\\n        // enforced by the type signature above\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n32\\\", hash));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\\n     * produces hash corresponding to the one signed with the\\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\\n     * JSON-RPC method as part of EIP-191.\\n     *\\n     * See {recover}.\\n     */\\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19Ethereum Signed Message:\\\\n\\\", Strings.toString(s.length), s));\\n    }\\n\\n    /**\\n     * @dev Returns an Ethereum Signed Typed Data, created from a\\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\\n     * to the one signed with the\\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\\n     * JSON-RPC method as part of EIP-712.\\n     *\\n     * See {recover}.\\n     */\\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\\n        return keccak256(abi.encodePacked(\\\"\\\\x19\\\\x01\\\", domainSeparator, structHash));\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/access/Ownable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract Ownable is Context {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    constructor() {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby removing any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/security/Pausable.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (security/Pausable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/Context.sol\\\";\\n\\n/**\\n * @dev Contract module which allows children to implement an emergency stop\\n * mechanism that can be triggered by an authorized account.\\n *\\n * This module is used through inheritance. It will make available the\\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\\n * the functions of your contract. Note that they will not be pausable by\\n * simply including this module, only once the modifiers are put in place.\\n */\\nabstract contract Pausable is Context {\\n    /**\\n     * @dev Emitted when the pause is triggered by `account`.\\n     */\\n    event Paused(address account);\\n\\n    /**\\n     * @dev Emitted when the pause is lifted by `account`.\\n     */\\n    event Unpaused(address account);\\n\\n    bool private _paused;\\n\\n    /**\\n     * @dev Initializes the contract in unpaused state.\\n     */\\n    constructor() {\\n        _paused = false;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is paused, and false otherwise.\\n     */\\n    function paused() public view virtual returns (bool) {\\n        return _paused;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is not paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    modifier whenNotPaused() {\\n        require(!paused(), \\\"Pausable: paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Modifier to make a function callable only when the contract is paused.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    modifier whenPaused() {\\n        require(paused(), \\\"Pausable: not paused\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Triggers stopped state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must not be paused.\\n     */\\n    function _pause() internal virtual whenNotPaused {\\n        _paused = true;\\n        emit Paused(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Returns to normal state.\\n     *\\n     * Requirements:\\n     *\\n     * - The contract must be paused.\\n     */\\n    function _unpause() internal virtual whenPaused {\\n        _paused = false;\\n        emit Unpaused(_msgSender());\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Strings.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev String operations.\\n */\\nlibrary Strings {\\n    bytes16 private constant _HEX_SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\\n     */\\n    function toString(uint256 value) internal pure returns (string memory) {\\n        // Inspired by OraclizeAPI's implementation - MIT licence\\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n\\n        if (value == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 digits;\\n        while (temp != 0) {\\n            digits++;\\n            temp /= 10;\\n        }\\n        bytes memory buffer = new bytes(digits);\\n        while (value != 0) {\\n            digits -= 1;\\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\\n            value /= 10;\\n        }\\n        return string(buffer);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\\n     */\\n    function toHexString(uint256 value) internal pure returns (string memory) {\\n        if (value == 0) {\\n            return \\\"0x00\\\";\\n        }\\n        uint256 temp = value;\\n        uint256 length = 0;\\n        while (temp != 0) {\\n            length++;\\n            temp >>= 8;\\n        }\\n        return toHexString(value, length);\\n    }\\n\\n    /**\\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\"\r\n    },\r\n    \"@openzeppelin/contracts/utils/Context.sol\": {\r\n      \"content\": \"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n}\\n\"\r\n    }\r\n  },\r\n  \"settings\": {\r\n    \"optimizer\": {\r\n      \"enabled\": true,\r\n      \"runs\": 200\r\n    },\r\n    \"outputSelection\": {\r\n      \"*\": {\r\n        \"*\": [\r\n          \"evm.bytecode\",\r\n          \"evm.deployedBytecode\",\r\n          \"devdoc\",\r\n          \"userdoc\",\r\n          \"metadata\",\r\n          \"abi\"\r\n        ]\r\n      }\r\n    },\r\n    \"libraries\": {}\r\n  }\r\n}}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"Unpaused\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"bool\",\"name\":\"hasLevel\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"baseYieldRate\",\"type\":\"uint256\"}],\"internalType\":\"struct BloodShedBearsStaking.CollectionSettings[]\",\"name\":\"settings_\",\"type\":\"tuple[]\"},{\"internalType\":\"address[]\",\"name\":\"collections_\",\"type\":\"address[]\"}],\"name\":\"addCollectionSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet_\",\"type\":\"address\"}],\"name\":\"calculateMetaPassesYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet_\",\"type\":\"address\"}],\"name\":\"calculateYieldForAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"calculateYieldSafe\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"},{\"internalType\":\"bool\",\"name\":\"withdrawYield\",\"type\":\"bool\"}],\"name\":\"claimPartnerTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"claimYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimYieldForAll\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedPartnerTokens\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"collections\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"collectionsSettings\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"hasLevel\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"baseYieldRate\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"contractsAddressesMap\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"}],\"name\":\"getStakedTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"houseTokenId\",\"type\":\"uint256\"}],\"internalType\":\"struct BloodShedBearsStaking.StakedTokens[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"collection_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"isOwner\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"targetHouse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"levels\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"factions\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"elites\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"internalType\":\"struct BloodShedBearsStaking.StakeSelection[]\",\"name\":\"selections_\",\"type\":\"tuple[]\"}],\"name\":\"moveIntoDifferentStake\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC1155Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"partnerCollectionYield\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"passesStakeDate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"keys_\",\"type\":\"string[]\"},{\"internalType\":\"address[]\",\"name\":\"collections_\",\"type\":\"address[]\"}],\"name\":\"setContractAddressesKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"addresses_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"yieldingAmounts_\",\"type\":\"uint256[]\"}],\"name\":\"setPartnerProjectsYielding\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"signerAddress_\",\"type\":\"address\"}],\"name\":\"setSignerAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string[]\",\"name\":\"keys_\",\"type\":\"string[]\"},{\"internalType\":\"uint256[]\",\"name\":\"stakeTypesIndexes_\",\"type\":\"uint256[]\"}],\"name\":\"setStakeTypesKeys\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"boost_\",\"type\":\"uint256\"}],\"name\":\"setTreeHouseBoost\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"withdrawCurrentYield\",\"type\":\"bool\"}],\"name\":\"stakePasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"targetHouse\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"levels\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"factions\",\"type\":\"bool[]\"},{\"internalType\":\"bool[]\",\"name\":\"elites\",\"type\":\"bool[]\"},{\"internalType\":\"bytes[]\",\"name\":\"signatures\",\"type\":\"bytes[]\"}],\"internalType\":\"struct BloodShedBearsStaking.StakeSelection[]\",\"name\":\"selections_\",\"type\":\"tuple[]\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"stakeTypesVariables\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedTokensByWallet\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stakedTokensData\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"stakeType\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"claimDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"houseTokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wallet_\",\"type\":\"address\"}],\"name\":\"transferPassesYieldIntoInternalWallet\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"treeHouseBoost\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"treeHousesEnrolments\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"enrolDate\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"withdraw\",\"type\":\"bool\"}],\"name\":\"unStakePasses\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"collectionAddress\",\"type\":\"address\"},{\"internalType\":\"uint256[]\",\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"internalType\":\"struct BloodShedBearsStaking.UnStakeSelection[]\",\"name\":\"selections_\",\"type\":\"tuple[]\"}],\"name\":\"unStakeTokens\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"walletsStakedPasses\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawPassesYield\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]", "ContractName": "BloodShedBearsStaking", "CompilerVersion": "v0.8.10+commit.fc410830", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": ""}