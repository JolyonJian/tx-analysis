{"SourceCode": "pragma solidity ^0.4.15;\r\n\r\n/**\r\n * Standard ERC20 token\r\n *\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n *\r\n * This is the token contract for trade.io, join the trading revolution.\r\n * It utilizes Majoolr's TokenLib library to reduce custom source code surface\r\n * area and increase overall security. Majoolr provides smart contract services\r\n * and security reviews for contract deployments in addition to working on open\r\n * source projects in the Ethereum community.\r\n * For further information: trade.io, majoolr.io\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\ncontract TIOToken {\r\n  using TokenLib for TokenLib.TokenStorage;\r\n\r\n  TokenLib.TokenStorage token;\r\n\r\n  function TIOToken(address owner,\r\n                    string name, //TradeToken\r\n                    string symbol, //TIO\r\n                    uint8 decimals, //18\r\n                    uint256 initialSupply, // 555000000000000000000000000\r\n                    bool allowMinting) //false\r\n  {\r\n    token.init(owner, name, symbol, decimals, initialSupply, allowMinting);\r\n  }\r\n\r\n  function owner() constant returns (address) {\r\n    return token.owner;\r\n  }\r\n\r\n  function name() constant returns (string) {\r\n    return token.name;\r\n  }\r\n\r\n  function symbol() constant returns (string) {\r\n    return token.symbol;\r\n  }\r\n\r\n  function decimals() constant returns (uint8) {\r\n    return token.decimals;\r\n  }\r\n\r\n  function initialSupply() constant returns (uint256) {\r\n    return token.INITIAL_SUPPLY;\r\n  }\r\n\r\n  function totalSupply() constant returns (uint256) {\r\n    return token.totalSupply;\r\n  }\r\n\r\n  function balanceOf(address who) constant returns (uint256) {\r\n    return token.balanceOf(who);\r\n  }\r\n\r\n  function allowance(address owner, address spender) constant returns (uint256) {\r\n    return token.allowance(owner, spender);\r\n  }\r\n\r\n  function transfer(address to, uint value) returns (bool ok) {\r\n    return token.transfer(to, value);\r\n  }\r\n\r\n  function transferFrom(address from, address to, uint value) returns (bool ok) {\r\n    return token.transferFrom(from, to, value);\r\n  }\r\n\r\n  function approve(address spender, uint value) returns (bool ok) {\r\n    return token.approve(spender, value);\r\n  }\r\n\r\n  function changeOwner(address newOwner) returns (bool ok) {\r\n    return token.changeOwner(newOwner);\r\n  }\r\n\r\n  function burnToken(uint256 amount) returns (bool ok) {\r\n    return token.burnToken(amount);\r\n  }\r\n}\r\n\r\nlibrary TokenLib {\r\n  using BasicMathLib for uint256;\r\n\r\n  struct TokenStorage {\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    string name;\r\n    string symbol;\r\n    uint256 totalSupply;\r\n    uint256 INITIAL_SUPPLY;\r\n    address owner;\r\n    uint8 decimals;\r\n    bool stillMinting;\r\n  }\r\n\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  event OwnerChange(address from, address to);\r\n  event Burn(address indexed burner, uint256 value);\r\n  event MintingClosed(bool mintingClosed);\r\n\r\n  /// @dev Called by the Standard Token upon creation.\r\n  /// @param self Stored token from token contract\r\n  /// @param _name Name of the new token\r\n  /// @param _symbol Symbol of the new token\r\n  /// @param _decimals Decimal places for the token represented\r\n  /// @param _initial_supply The initial token supply\r\n  /// @param _allowMinting True if additional tokens can be created, false otherwise\r\n  function init(TokenStorage storage self,\r\n                address _owner,\r\n                string _name,\r\n                string _symbol,\r\n                uint8 _decimals,\r\n                uint256 _initial_supply,\r\n                bool _allowMinting)\r\n  {\r\n    require(self.INITIAL_SUPPLY == 0);\r\n    self.name = _name;\r\n    self.symbol = _symbol;\r\n    self.totalSupply = _initial_supply;\r\n    self.INITIAL_SUPPLY = _initial_supply;\r\n    self.decimals = _decimals;\r\n    self.owner = _owner;\r\n    self.stillMinting = _allowMinting;\r\n    self.balances[_owner] = _initial_supply;\r\n  }\r\n\r\n  /// @dev Transfer tokens from caller's account to another account.\r\n  /// @param self Stored token from token contract\r\n  /// @param _to Address to send tokens\r\n  /// @param _value Number of tokens to send\r\n  /// @return True if completed\r\n  function transfer(TokenStorage storage self, address _to, uint256 _value) returns (bool) {\r\n    bool err;\r\n    uint256 balance;\r\n\r\n    (err,balance) = self.balances[msg.sender].minus(_value);\r\n    require(!err);\r\n    self.balances[msg.sender] = balance;\r\n    //It's not possible to overflow token supply\r\n    self.balances[_to] = self.balances[_to] + _value;\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Authorized caller transfers tokens from one account to another\r\n  /// @param self Stored token from token contract\r\n  /// @param _from Address to send tokens from\r\n  /// @param _to Address to send tokens to\r\n  /// @param _value Number of tokens to send\r\n  /// @return True if completed\r\n  function transferFrom(TokenStorage storage self,\r\n                        address _from,\r\n                        address _to,\r\n                        uint256 _value)\r\n                        returns (bool)\r\n  {\r\n    var _allowance = self.allowed[_from][msg.sender];\r\n    bool err;\r\n    uint256 balanceOwner;\r\n    uint256 balanceSpender;\r\n\r\n    (err,balanceOwner) = self.balances[_from].minus(_value);\r\n    require(!err);\r\n\r\n    (err,balanceSpender) = _allowance.minus(_value);\r\n    require(!err);\r\n\r\n    self.balances[_from] = balanceOwner;\r\n    self.allowed[_from][msg.sender] = balanceSpender;\r\n    self.balances[_to] = self.balances[_to] + _value;\r\n\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Retrieve token balance for an account\r\n  /// @param self Stored token from token contract\r\n  /// @param _owner Address to retrieve balance of\r\n  /// @return balance The number of tokens in the subject account\r\n  function balanceOf(TokenStorage storage self, address _owner) constant returns (uint256 balance) {\r\n    return self.balances[_owner];\r\n  }\r\n\r\n  /// @dev Authorize an account to send tokens on caller's behalf\r\n  /// @param self Stored token from token contract\r\n  /// @param _spender Address to authorize\r\n  /// @param _value Number of tokens authorized account may send\r\n  /// @return True if completed\r\n  function approve(TokenStorage storage self, address _spender, uint256 _value) returns (bool) {\r\n    self.allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Remaining tokens third party spender has to send\r\n  /// @param self Stored token from token contract\r\n  /// @param _owner Address of token holder\r\n  /// @param _spender Address of authorized spender\r\n  /// @return remaining Number of tokens spender has left in owner's account\r\n  function allowance(TokenStorage storage self, address _owner, address _spender) constant returns (uint256 remaining) {\r\n    return self.allowed[_owner][_spender];\r\n  }\r\n\r\n  /// @dev Authorize third party transfer by increasing/decreasing allowed rather than setting it\r\n  /// @param self Stored token from token contract\r\n  /// @param _spender Address to authorize\r\n  /// @param _valueChange Increase or decrease in number of tokens authorized account may send\r\n  /// @param _increase True if increasing allowance, false if decreasing allowance\r\n  /// @return True if completed\r\n  function approveChange (TokenStorage storage self, address _spender, uint256 _valueChange, bool _increase)\r\n                          returns (bool)\r\n  {\r\n    uint256 _newAllowed;\r\n    bool err;\r\n\r\n    if(_increase) {\r\n      (err, _newAllowed) = self.allowed[msg.sender][_spender].plus(_valueChange);\r\n      require(!err);\r\n\r\n      self.allowed[msg.sender][_spender] = _newAllowed;\r\n    } else {\r\n      if (_valueChange > self.allowed[msg.sender][_spender]) {\r\n        self.allowed[msg.sender][_spender] = 0;\r\n      } else {\r\n        _newAllowed = self.allowed[msg.sender][_spender] - _valueChange;\r\n        self.allowed[msg.sender][_spender] = _newAllowed;\r\n      }\r\n    }\r\n\r\n    Approval(msg.sender, _spender, _newAllowed);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Change owning address of the token contract, specifically for minting\r\n  /// @param self Stored token from token contract\r\n  /// @param _newOwner Address for the new owner\r\n  /// @return True if completed\r\n  function changeOwner(TokenStorage storage self, address _newOwner) returns (bool) {\r\n    require((self.owner == msg.sender) && (_newOwner > 0));\r\n\r\n    self.owner = _newOwner;\r\n    OwnerChange(msg.sender, _newOwner);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Mints additional tokens, new tokens go to owner\r\n  /// @param self Stored token from token contract\r\n  /// @param _amount Number of tokens to mint\r\n  /// @return True if completed\r\n  function mintToken(TokenStorage storage self, uint256 _amount) returns (bool) {\r\n    require((self.owner == msg.sender) && self.stillMinting);\r\n    uint256 _newAmount;\r\n    bool err;\r\n\r\n    (err, _newAmount) = self.totalSupply.plus(_amount);\r\n    require(!err);\r\n\r\n    self.totalSupply =  _newAmount;\r\n    self.balances[self.owner] = self.balances[self.owner] + _amount;\r\n    Transfer(0x0, self.owner, _amount);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Permanent stops minting\r\n  /// @param self Stored token from token contract\r\n  /// @return True if completed\r\n  function closeMint(TokenStorage storage self) returns (bool) {\r\n    require(self.owner == msg.sender);\r\n\r\n    self.stillMinting = false;\r\n    MintingClosed(true);\r\n    return true;\r\n  }\r\n\r\n  /// @dev Permanently burn tokens\r\n  /// @param self Stored token from token contract\r\n  /// @param _amount Amount of tokens to burn\r\n  /// @return True if completed\r\n  function burnToken(TokenStorage storage self, uint256 _amount) returns (bool) {\r\n      uint256 _newBalance;\r\n      bool err;\r\n\r\n      (err, _newBalance) = self.balances[msg.sender].minus(_amount);\r\n      require(!err);\r\n\r\n      self.balances[msg.sender] = _newBalance;\r\n      self.totalSupply = self.totalSupply - _amount;\r\n      Burn(msg.sender, _amount);\r\n      Transfer(msg.sender, 0x0, _amount);\r\n      return true;\r\n  }\r\n}\r\n\r\nlibrary BasicMathLib {\r\n  event Err(string typeErr);\r\n\r\n  /// @dev Multiplies two numbers and checks for overflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is overflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The product of a and b, or 0 if there is overflow\r\n  function times(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := mul(a,b)\r\n      switch or(iszero(b), eq(div(res,b), a))\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n    if (err)\r\n      Err(\"times func overflow\");\r\n  }\r\n\r\n  /// @dev Divides two numbers but checks for 0 in the divisor first.\r\n  /// Does not throw but rather logs an Err event if 0 is in the divisor.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if `b` is 0\r\n  /// @return res The quotient of a and b, or 0 if `b` is 0\r\n  function dividedBy(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\r\n    assembly{\r\n      switch iszero(b)\r\n      case 0 {\r\n        res := div(a,b)\r\n        mstore(add(mload(0x40),0x20),res)\r\n        return(mload(0x40),0x40)\r\n      }\r\n    }\r\n    Err(\"tried to divide by zero\");\r\n    return (true, 0);\r\n  }\r\n\r\n  /// @dev Adds two numbers and checks for overflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is overflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is overflow\r\n  /// @return res The sum of a and b, or 0 if there is overflow\r\n  function plus(uint256 a, uint256 b) constant returns (bool err, uint256 res) {\r\n    assembly{\r\n      res := add(a,b)\r\n      switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b)))\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n    if (err)\r\n      Err(\"plus func overflow\");\r\n  }\r\n\r\n  /// @dev Subtracts two numbers and checks for underflow before returning.\r\n  /// Does not throw but rather logs an Err event if there is underflow.\r\n  /// @param a First number\r\n  /// @param b Second number\r\n  /// @return err False normally, or true if there is underflow\r\n  /// @return res The difference between a and b, or 0 if there is underflow\r\n  function minus(uint256 a, uint256 b) constant returns (bool err,uint256 res) {\r\n    assembly{\r\n      res := sub(a,b)\r\n      switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1)\r\n      case 0 {\r\n        err := 1\r\n        res := 0\r\n      }\r\n    }\r\n    if (err)\r\n      Err(\"minus func underflow\");\r\n  }\r\n}", "ABI": "[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnToken\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"initialSupply\",\"type\":\"uint256\"},{\"name\":\"allowMinting\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"constructor\"}]", "ContractName": "TIOToken", "CompilerVersion": "v0.4.15+commit.bbb8e64f", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "00000000000000000000000058f75ddacffb183a30f69fe58a67a0d0985fce0f00000000000000000000000000000000000000000000000000000000000000c000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000001cb15d24956472c0b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000a5472616465546f6b656e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000354494f0000000000000000000000000000000000000000000000000000000000", "EVMVersion": "Default", "Library": "TokenLib:02d509d0af485c8da54d8aeb42c624e7d9e2eeb6", "LicenseType": "", "Proxy": "0", "Implementation": "", "SwarmSource": "bzzr://c70195bae37bf8c2ee4de38d725c612844956da342158b0bf73b8d614d8c8875"}