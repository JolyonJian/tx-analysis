{"SourceCode": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\n// Open0x Ownable (by 0xInuarashi)\r\nabstract contract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed oldOwner_, address indexed newOwner_);\r\n    constructor() { owner = msg.sender; }\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender, \"Ownable: caller is not the owner\");\r\n        _;\r\n    }\r\n    function _transferOwnership(address newOwner_) internal virtual {\r\n        address _oldOwner = owner;\r\n        owner = newOwner_;\r\n        emit OwnershipTransferred(_oldOwner, newOwner_);    \r\n    }\r\n    function transferOwnership(address newOwner_) public virtual onlyOwner {\r\n        require(newOwner_ != address(0x0), \"Ownable: new owner is the zero address!\");\r\n        _transferOwnership(newOwner_);\r\n    }\r\n    function renounceOwnership() public virtual onlyOwner {\r\n        _transferOwnership(address(0x0));\r\n    }\r\n}\r\n\r\ninterface iCT {\r\n\r\n    struct ownerAndStake {\r\n        address owner;\r\n        uint40 timestamp;\r\n    }\r\n    \r\n    function totalSupply() external view returns (uint256);\r\n    function _ownerOf(uint256 tokenId_) external view returns (ownerAndStake memory);\r\n    function ownerOf(uint256 tokenId_) external view returns (address);\r\n    function isStaked(uint256 tokenId_) external view returns (bool);\r\n    function tokenIdStartsAt() external view returns (uint256);\r\n\r\n    function validateOwnershipOfTokens(address owner_, uint256[] calldata tokenIds_) \r\n    external view returns (bool);\r\n    function validateOwnershipOfStakedTokens(address owner_,\r\n    uint256[] calldata tokenIds_) external view returns (bool);\r\n\r\n    function stakeTurtles(uint256[] calldata tokenIds_) external;\r\n    function updateTurtles(uint256[] calldata tokenIds_) external;\r\n    function unstakeTurtles(uint256[] calldata tokenIds_) external;\r\n\r\n    function tokenURI(uint256 tokenId_) external view returns (string memory);\r\n}\r\n\r\ninterface iShell {\r\n    function mint(address to_, uint256 amount_) external;\r\n}\r\n\r\n// This is a proof-of-stake (token represents stake) contract\r\n// Custom made with love by 0xInuarashi.eth\r\ncontract sCyberTurtles is Ownable {\r\n    string public name = \"Staked Cyber Turtles\";\r\n    string public symbol = \"sCyber\";\r\n\r\n    // We largely interface with CyberTurtles\r\n    iCT public CT = iCT(0x81BC389D02c3054649643E590ce57fAAAB3BF38B); // note: change\r\n    function setCT(address address_) external onlyOwner {\r\n        CT = iCT(address_);\r\n    }\r\n\r\n    iShell public SHELL = iShell(0x81BC389D02c3054649643E590ce57fAAAB3BF38B); // note: c\r\n    function setShell(address address_) external onlyOwner {\r\n        SHELL = iShell(address_);\r\n    }\r\n\r\n    // Yield Info\r\n    uint256 public yieldStartTime = 1643670000; // 2021-01-31_18-00_EST\r\n    uint256 public yieldEndTime = 1959202800; // 10 years\r\n    uint256 public yieldRate = 100 ether;\r\n\r\n    // Magic Events\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    // Magic Logic\r\n    function totalSupply() public view returns (uint256) {\r\n        uint256 _totalSupply;\r\n        uint256 _startId = CT.tokenIdStartsAt();\r\n        for (uint256 i = _startId; i <= CT.totalSupply() + _startId; i++) {\r\n            if (CT.isStaked(i)) { _totalSupply++; }\r\n        }\r\n        return _totalSupply;\r\n    }\r\n\r\n    function ownerOf(uint256 tokenId_) public view returns (address) {\r\n        iCT.ownerAndStake memory _ownerAndStake = CT._ownerOf(tokenId_);\r\n        address _owner = _ownerAndStake.timestamp > 0 ?\r\n             _ownerAndStake.owner : address(0);\r\n        return _owner;\r\n    }\r\n\r\n    function balanceOf(address address_) public view returns (uint256) {\r\n        uint256 _startId = CT.tokenIdStartsAt();\r\n        uint256 _balance;\r\n        for (uint256 i = _startId; i <= CT.totalSupply() + _startId; i++) {\r\n            if (ownerOf(i) == address_) { _balance++; }\r\n        }\r\n        return _balance;\r\n    }\r\n\r\n    // Internal Claim Function\r\n    function _getPendingTokens(uint256 tokenId_) internal view returns (uint256) {\r\n        uint256 _timestamp = uint256(CT._ownerOf(tokenId_).timestamp);\r\n        if (_timestamp == 0 || _timestamp > yieldEndTime) return 0;\r\n\r\n        uint256 _timeCurrentOrEnded = yieldEndTime > block.timestamp ? \r\n            block.timestamp : yieldEndTime;\r\n        uint256 _timeElapsed = _timeCurrentOrEnded - _timestamp;\r\n\r\n        return (_timeElapsed * yieldRate) / 1 days;\r\n    }\r\n    function _getPendingTokensMany(uint256[] memory tokenIds_) internal view\r\n    returns (uint256) {\r\n        uint256 _pendingTokens;\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            _pendingTokens += _getPendingTokens(tokenIds_[i]);\r\n        }\r\n        return _pendingTokens;\r\n    }\r\n\r\n    function getPendingTokens(uint256 tokenId_) public view returns (uint256) {\r\n        return _getPendingTokens(tokenId_);\r\n    }\r\n    function getPendingTokensMany(uint256[] calldata tokenIds_) public view \r\n    returns (uint256) {\r\n        return _getPendingTokensMany(tokenIds_);\r\n    }\r\n    function getPendingTokensOfAddress(address address_) public view \r\n    returns (uint256) {\r\n        uint256[] memory _tokensOfAddress = walletOfOwner(address_);\r\n        return _getPendingTokensMany(_tokensOfAddress);\r\n    }\r\n\r\n    function _claim(address to_, uint256[] memory tokenIds_) internal {\r\n        uint256 _pendingTokens;\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            _pendingTokens += _getPendingTokens(tokenIds_[i]);\r\n        }\r\n        SHELL.mint(to_, _pendingTokens);\r\n    }\r\n\r\n    function claim(uint256[] calldata tokenIds_) external {\r\n        require(CT.validateOwnershipOfStakedTokens(msg.sender, tokenIds_),\r\n            \"You are not the owner or token is unstaked!\");\r\n\r\n        _claim(msg.sender, tokenIds_);\r\n        CT.updateTurtles(tokenIds_); // This updates the timestamp\r\n    }\r\n    function stakeTurtles(uint256[] calldata tokenIds_) external {\r\n        require(CT.validateOwnershipOfTokens(msg.sender, tokenIds_),\r\n            \"You are not the owner or token is already staked!\");\r\n\r\n        CT.stakeTurtles(tokenIds_); // Set timestamp to block.timestamp\r\n\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            emit Transfer(address(0), msg.sender, tokenIds_[i]); // Mint sToken\r\n        }\r\n    }   \r\n    function unstakeTurtles(uint256[] calldata tokenIds_) external {\r\n        require(CT.validateOwnershipOfStakedTokens(msg.sender, tokenIds_),\r\n            \"You are not the owner or token is unstaked!\");\r\n\r\n        _claim(msg.sender, tokenIds_);\r\n        CT.unstakeTurtles(tokenIds_); // Set timestamp to 0\r\n\r\n        for (uint256 i = 0; i < tokenIds_.length; i++) {\r\n            emit Transfer(msg.sender, address(0), tokenIds_[i]); // Burn sToken\r\n        }\r\n    }\r\n\r\n    function mintStakedTokenAsCyberTurtles(address to_, uint256 tokenId_) external {\r\n        require(msg.sender == address(CT), \"You are not CT!\");\r\n        emit Transfer(address(0), to_, tokenId_);\r\n    }\r\n\r\n    function walletOfOwner(address address_) public virtual view \r\n    returns (uint256[] memory) {\r\n        uint256 _balance = balanceOf(address_);\r\n        if (_balance == 0) return new uint256[](0);\r\n\r\n        uint256[] memory _tokens = new uint256[] (_balance);\r\n        uint256 _index;\r\n        uint256 _loopThrough = CT.totalSupply() + 1;\r\n        for (uint256 i = 0; i < _loopThrough; i++) {\r\n            if (ownerOf(i) == address(0x0) && _tokens[_balance - 1] == 0) {\r\n                _loopThrough++; \r\n            }\r\n            if (ownerOf(i) == address_) { \r\n                _tokens[_index] = i; _index++; \r\n            }\r\n        }\r\n        return _tokens;\r\n    }\r\n\r\n    // TokenURI Stuff\r\n    string internal baseTokenURI; string internal baseTokenURI_EXT;\r\n    function _toString(uint256 value_) internal pure returns (string memory) {\r\n        if (value_ == 0) { return \"0\"; }\r\n        uint256 _iterate = value_; uint256 _digits;\r\n        while (_iterate != 0) { _digits++; _iterate /= 10; } // get digits in value_\r\n        bytes memory _buffer = new bytes(_digits);\r\n        while (value_ != 0) { _digits--; _buffer[_digits] = bytes1(uint8(\r\n            48 + uint256(value_ % 10 ))); value_ /= 10; } // create bytes of value_\r\n        return string(_buffer); // return string converted bytes of value_\r\n    }\r\n    function setBaseTokenURI(string memory uri_) external onlyOwner {\r\n        baseTokenURI = uri_;\r\n    }\r\n    function setBaseTokenURI_EXT(string memory ext_) external onlyOwner {\r\n        baseTokenURI_EXT = ext_;\r\n    }\r\n    function tokenURI(uint256 tokenId_) public view virtual returns (string memory) {\r\n        require(ownerOf(tokenId_) != address(0), \r\n            \"ERC721I: tokenURI() Token does not exist!\");\r\n\r\n        return string(abi.encodePacked(baseTokenURI, \r\n            _toString(tokenId_), baseTokenURI_EXT));\r\n    }\r\n\r\n    // OZ ERC721 Stuff\r\n    function supportsInterface(bytes4 interfaceId_) public pure returns (bool) {\r\n        return (interfaceId_ == 0x80ac58cd || interfaceId_ == 0x5b5e139f);\r\n    }\r\n}", "ABI": "[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"oldOwner_\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"CT\",\"outputs\":[{\"internalType\":\"contract iCT\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"SHELL\",\"outputs\":[{\"internalType\":\"contract iShell\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"getPendingTokens\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"getPendingTokensMany\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"getPendingTokensOfAddress\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"mintStakedTokenAsCyberTurtles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"uri_\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"ext_\",\"type\":\"string\"}],\"name\":\"setBaseTokenURI_EXT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setCT\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"setShell\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"stakeTurtles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId_\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"tokenId_\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner_\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"tokenIds_\",\"type\":\"uint256[]\"}],\"name\":\"unstakeTurtles\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"address_\",\"type\":\"address\"}],\"name\":\"walletOfOwner\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldRate\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"yieldStartTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}]", "ContractName": "sCyberTurtles", "CompilerVersion": "v0.8.7+commit.e28d00a7", "OptimizationUsed": "1", "Runs": "200", "ConstructorArguments": "", "EVMVersion": "Default", "Library": "", "LicenseType": "MIT", "Proxy": "0", "Implementation": "", "SwarmSource": "ipfs://4a7023342e0546e9fc2094e188bf3451dd14ffc6e954fdfbf752304dcda634ca"}